; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\ip_arp_udp_tcp.o --depend=.\ouput\ip_arp_udp_tcp.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\ip_arp_udp_tcp.crf Source\Net\ip_arp_udp_tcp.c]
                          THUMB

                          AREA ||i.checksum||, CODE, READONLY, ALIGN=1

                  checksum PROC
;;;52     // The RFC has also a C code example: http://www.faqs.org/rfcs/rfc1071.html
;;;53     unsigned  int checksum(unsigned char *buf, unsigned  int len,unsigned char type)
000000  4603              MOV      r3,r0
;;;54     {
;;;55         // type 0=ip 
;;;56         //      1=udp
;;;57         //      2=tcp
;;;58         unsigned long sum = 0;
000002  2000              MOVS     r0,#0
;;;59         
;;;60         //if(type==0){
;;;61         //        // do not add anything
;;;62         //}
;;;63         if(type==1)
000004  2a01              CMP      r2,#1
000006  d002              BEQ      |L1.14|
;;;64         {
;;;65             sum+=IP_PROTO_UDP_V; // protocol udp
;;;66             // the length here is the length of udp (data+header len)
;;;67             // =length given to this function - (IP.scr+IP.dst length)
;;;68             sum+=len-8; // = real tcp len
;;;69         }
;;;70         if(type==2)
000008  2a02              CMP      r2,#2
00000a  d003              BEQ      |L1.20|
00000c  e00b              B        |L1.38|
                  |L1.14|
00000e  f1010011          ADD      r0,r1,#0x11           ;68
000012  e001              B        |L1.24|
                  |L1.20|
;;;71         {
;;;72             sum+=IP_PROTO_TCP_V; 
000014  1d80              ADDS     r0,r0,#6
;;;73             // the length here is the length of tcp (data+header len)
;;;74             // =length given to this function - (IP.scr+IP.dst length)
;;;75             sum+=len-8; // = real tcp len
000016  4408              ADD      r0,r0,r1
                  |L1.24|
000018  3808              SUBS     r0,r0,#8              ;68
00001a  e004              B        |L1.38|
                  |L1.28|
;;;76         }
;;;77         // build the sum of 16bit words
;;;78         while(len >1)
;;;79         {
;;;80             sum += 0xFFFF & (*buf<<8|*(buf+1));
00001c  f8332b02          LDRH     r2,[r3],#2
;;;81             buf+=2;
;;;82             len-=2;
000020  1e89              SUBS     r1,r1,#2
000022  ba52              REV16    r2,r2                 ;80
000024  4410              ADD      r0,r0,r2              ;80
                  |L1.38|
000026  2901              CMP      r1,#1                 ;78
000028  d8f8              BHI      |L1.28|
;;;83         }
;;;84         // if there is a byte left then add it (padded with zero)
;;;85         if (len)
00002a  b131              CBZ      r1,|L1.58|
;;;86         {
;;;87             sum += (0xFF & *buf)<<8;
00002c  7819              LDRB     r1,[r3,#0]
00002e  eb002001          ADD      r0,r0,r1,LSL #8
000032  e002              B        |L1.58|
                  |L1.52|
;;;88         }
;;;89         // now calculate the sum over the bytes in the sum
;;;90         // until the result is only 16bit long
;;;91         while (sum>>16)
;;;92         {
;;;93             sum = (sum & 0xFFFF)+(sum >> 16);
000034  b281              UXTH     r1,r0
000036  eb014010          ADD      r0,r1,r0,LSR #16
                  |L1.58|
00003a  0c01              LSRS     r1,r0,#16             ;91
00003c  d1fa              BNE      |L1.52|
;;;94         }
;;;95         // build 1's complement:
;;;96         return( (unsigned  int) sum ^ 0xFFFF);
00003e  f64f71ff          MOV      r1,#0xffff
000042  4048              EORS     r0,r0,r1
;;;97     }
000044  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i.eth_type_is_arp_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_arp_and_my_ip PROC
;;;116    
;;;117    unsigned char eth_type_is_arp_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;118    {
;;;119        unsigned char i=0;
000002  2200              MOVS     r2,#0
;;;120        //  
;;;121        if (len<41)
000004  2929              CMP      r1,#0x29
000006  d30c              BCC      |L2.34|
;;;122        {
;;;123            return(0);
;;;124        }
;;;125        if(buf[ETH_TYPE_H_P] != ETHTYPE_ARP_H_V || buf[ETH_TYPE_L_P] != ETHTYPE_ARP_L_V)
000008  7b01              LDRB     r1,[r0,#0xc]
00000a  2908              CMP      r1,#8
00000c  d109              BNE      |L2.34|
00000e  7b41              LDRB     r1,[r0,#0xd]
000010  2906              CMP      r1,#6
000012  d106              BNE      |L2.34|
;;;126        {
;;;127            return(0);
;;;128        }
;;;129        while(i<4)
;;;130        {
;;;131            if(buf[ETH_ARP_DST_IP_P+i] != ipaddr[i])
000014  4907              LDR      r1,|L2.52|
                  |L2.22|
000016  1883              ADDS     r3,r0,r2
000018  f8933026          LDRB     r3,[r3,#0x26]
00001c  5c8c              LDRB     r4,[r1,r2]
00001e  42a3              CMP      r3,r4
000020  d001              BEQ      |L2.38|
                  |L2.34|
;;;132            {
;;;133                return(0);
000022  2000              MOVS     r0,#0
;;;134            }
;;;135            i++;
;;;136        }
;;;137        return(1);
;;;138    }
000024  bd10              POP      {r4,pc}
                  |L2.38|
000026  1c52              ADDS     r2,r2,#1              ;135
000028  b2d2              UXTB     r2,r2                 ;135
00002a  2a04              CMP      r2,#4                 ;129
00002c  d3f3              BCC      |L2.22|
00002e  2001              MOVS     r0,#1                 ;137
000030  bd10              POP      {r4,pc}
;;;139    
                          ENDP

000032  0000              DCW      0x0000
                  |L2.52|
                          DCD      ||.data||+0xc

                          AREA ||i.eth_type_is_ip_and_my_ip||, CODE, READONLY, ALIGN=2

                  eth_type_is_ip_and_my_ip PROC
;;;139    
;;;140    unsigned char eth_type_is_ip_and_my_ip(unsigned char *buf,unsigned  int len)
000000  b510              PUSH     {r4,lr}
;;;141    {
;;;142        unsigned char i=0;
000002  2200              MOVS     r2,#0
;;;143        //eth+ip+udp header is 42
;;;144        if (len<42)
000004  292a              CMP      r1,#0x2a
000006  d30d              BCC      |L3.36|
;;;145        {
;;;146            return(0);
;;;147        }
;;;148        if(buf[ETH_TYPE_H_P]!=ETHTYPE_IP_H_V || buf[ETH_TYPE_L_P]!=ETHTYPE_IP_L_V)
000008  7b01              LDRB     r1,[r0,#0xc]
00000a  2908              CMP      r1,#8
00000c  d10a              BNE      |L3.36|
00000e  7b41              LDRB     r1,[r0,#0xd]
000010  b941              CBNZ     r1,|L3.36|
;;;149        {
;;;150            return(0);
;;;151        }
;;;152        if (buf[IP_HEADER_LEN_VER_P]!=0x45)
000012  7b81              LDRB     r1,[r0,#0xe]
000014  2945              CMP      r1,#0x45
000016  d105              BNE      |L3.36|
;;;153        {
;;;154            // must be IP V4 and 20 byte header
;;;155            return(0);
;;;156        }
;;;157        while(i<4)
;;;158        {
;;;159            if(buf[IP_DST_P+i]!=ipaddr[i])
000018  4906              LDR      r1,|L3.52|
                  |L3.26|
00001a  1883              ADDS     r3,r0,r2
00001c  7f9b              LDRB     r3,[r3,#0x1e]
00001e  5c8c              LDRB     r4,[r1,r2]
000020  42a3              CMP      r3,r4
000022  d001              BEQ      |L3.40|
                  |L3.36|
;;;160            {
;;;161                return(0);
000024  2000              MOVS     r0,#0
;;;162            }
;;;163            i++;
;;;164        }
;;;165        return(1);
;;;166    }
000026  bd10              POP      {r4,pc}
                  |L3.40|
000028  1c52              ADDS     r2,r2,#1              ;163
00002a  b2d2              UXTB     r2,r2                 ;163
00002c  2a04              CMP      r2,#4                 ;157
00002e  d3f4              BCC      |L3.26|
000030  2001              MOVS     r0,#1                 ;165
000032  bd10              POP      {r4,pc}
;;;167    // make a return eth header from a received eth packet
                          ENDP

                  |L3.52|
                          DCD      ||.data||+0xc

                          AREA ||i.fill_ip_hdr_checksum||, CODE, READONLY, ALIGN=1

                  fill_ip_hdr_checksum PROC
;;;179    }
;;;180    void fill_ip_hdr_checksum(unsigned char *buf)
000000  b510              PUSH     {r4,lr}
;;;181    {
000002  4604              MOV      r4,r0
;;;182        unsigned  int ck;
;;;183        // clear the 2 byte checksum
;;;184        buf[IP_CHECKSUM_P]=0;
000004  2000              MOVS     r0,#0
000006  7620              STRB     r0,[r4,#0x18]
;;;185        buf[IP_CHECKSUM_P+1]=0;
000008  7660              STRB     r0,[r4,#0x19]
;;;186        buf[IP_FLAGS_P]=0x40; // don't fragment
00000a  2140              MOVS     r1,#0x40
00000c  7521              STRB     r1,[r4,#0x14]
;;;187        buf[IP_FLAGS_P+1]=0;  // fragement offset
00000e  7560              STRB     r0,[r4,#0x15]
;;;188        buf[IP_TTL_P]=64; // ttl
000010  75a1              STRB     r1,[r4,#0x16]
;;;189        // calculate the checksum:
;;;190        ck=checksum(&buf[IP_P], IP_HEADER_LEN,0);
000012  4602              MOV      r2,r0
000014  2114              MOVS     r1,#0x14
000016  f104000e          ADD      r0,r4,#0xe
00001a  f7fffffe          BL       checksum
;;;191        buf[IP_CHECKSUM_P]=ck>>8;
00001e  0a01              LSRS     r1,r0,#8
000020  7621              STRB     r1,[r4,#0x18]
;;;192        buf[IP_CHECKSUM_P+1]=ck& 0xff;
000022  7660              STRB     r0,[r4,#0x19]
;;;193    }
000024  bd10              POP      {r4,pc}
;;;194    
                          ENDP


                          AREA ||i.fill_tcp_data||, CODE, READONLY, ALIGN=1

                  fill_tcp_data PROC
;;;437    // this string could be filled.
;;;438    unsigned  int fill_tcp_data(unsigned char *buf,unsigned  int pos, const char *s)
000000  b510              PUSH     {r4,lr}
;;;439    {
000002  4603              MOV      r3,r0
000004  4608              MOV      r0,r1
;;;440        // fill in tcp data at position pos
;;;441        //
;;;442        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;443        while (*s) 
;;;444        {
;;;445            buf[TCP_CHECKSUM_L_P+3+pos]=*s;
;;;446            pos++;
;;;447            s++;
000006  e004              B        |L5.18|
                  |L5.8|
000008  181c              ADDS     r4,r3,r0              ;445
00000a  1c40              ADDS     r0,r0,#1              ;446
00000c  f8841036          STRB     r1,[r4,#0x36]         ;445
000010  1c52              ADDS     r2,r2,#1
                  |L5.18|
000012  7811              LDRB     r1,[r2,#0]            ;443
000014  2900              CMP      r1,#0                 ;443
000016  d1f7              BNE      |L5.8|
;;;448        }
;;;449        return(pos);
;;;450    }
000018  bd10              POP      {r4,pc}
;;;451    
                          ENDP


                          AREA ||i.fill_tcp_data_p||, CODE, READONLY, ALIGN=1

                  fill_tcp_data_p PROC
;;;418    // this string could be filled.
;;;419    unsigned  int fill_tcp_data_p(unsigned char *buf,unsigned  int pos, const unsigned char *progmem_s)
000000  b510              PUSH     {r4,lr}
;;;420    {
000002  4603              MOV      r3,r0
000004  4608              MOV      r0,r1
;;;421        char c;
;;;422        // fill in tcp data at position pos
;;;423        //
;;;424        // with no options the data starts after the checksum + 2 more bytes (urgent ptr)
;;;425    	 
;;;426    
;;;427        while ((c = pgm_read_byte(progmem_s++))) 
;;;428        {
;;;429            buf[TCP_CHECKSUM_L_P+3+pos]=c;
;;;430            pos++;
000006  e003              B        |L6.16|
                  |L6.8|
000008  181c              ADDS     r4,r3,r0              ;429
00000a  1c40              ADDS     r0,r0,#1
00000c  f8841036          STRB     r1,[r4,#0x36]         ;429
                  |L6.16|
000010  f8121b01          LDRB     r1,[r2],#1            ;427
000014  2900              CMP      r1,#0                 ;427
000016  d1f7              BNE      |L6.8|
;;;431        }
;;;432        return(pos);
;;;433    }
000018  bd10              POP      {r4,pc}
;;;434    
                          ENDP


                          AREA ||i.get_tcp_data_pointer||, CODE, READONLY, ALIGN=2

                  get_tcp_data_pointer PROC
;;;390    // You must call init_len_info once before calling this function
;;;391    unsigned  int get_tcp_data_pointer(void)
000000  4803              LDR      r0,|L7.16|
;;;392    {
;;;393        if (info_data_len)
000002  6881              LDR      r1,[r0,#8]  ; info_data_len
000004  b111              CBZ      r1,|L7.12|
;;;394        {
;;;395            return((unsigned  int)TCP_SRC_PORT_H_P+info_hdr_len);
000006  6840              LDR      r0,[r0,#4]  ; info_hdr_len
000008  3022              ADDS     r0,r0,#0x22
;;;396        }
;;;397        else
;;;398        {
;;;399            return(0);
;;;400        }
;;;401    }
00000a  4770              BX       lr
                  |L7.12|
00000c  2000              MOVS     r0,#0                 ;399
00000e  4770              BX       lr
;;;402    
                          ENDP

                  |L7.16|
                          DCD      ||.data||

                          AREA ||i.init_ip_arp_udp_tcp||, CODE, READONLY, ALIGN=2

                  init_ip_arp_udp_tcp PROC
;;;99     // you must call this function once before you use any of the other functions:
;;;100    void init_ip_arp_udp_tcp(unsigned char *mymac,unsigned char *myip,unsigned char wwwp)
000000  b510              PUSH     {r4,lr}
;;;101    {
;;;102        unsigned char i=0;
;;;103        wwwport=wwwp;
000002  4c0a              LDR      r4,|L8.44|
000004  2300              MOVS     r3,#0                 ;102
000006  7022              STRB     r2,[r4,#0]
;;;104        while(i<4)
;;;105        {
;;;106            ipaddr[i]=myip[i];
000008  f104020c          ADD      r2,r4,#0xc
                  |L8.12|
00000c  5ccc              LDRB     r4,[r1,r3]
00000e  54d4              STRB     r4,[r2,r3]
;;;107            i++;
000010  1c5b              ADDS     r3,r3,#1
000012  b2db              UXTB     r3,r3
000014  2b04              CMP      r3,#4                 ;104
000016  d3f9              BCC      |L8.12|
;;;108        }
;;;109        i=0;
;;;110        while(i<6)
;;;111        {
;;;112            macaddr[i]=mymac[i];
000018  4a04              LDR      r2,|L8.44|
00001a  2100              MOVS     r1,#0                 ;109
00001c  3210              ADDS     r2,r2,#0x10
                  |L8.30|
00001e  5c43              LDRB     r3,[r0,r1]
000020  5453              STRB     r3,[r2,r1]
;;;113            i++;
000022  1c49              ADDS     r1,r1,#1
000024  b2c9              UXTB     r1,r1
000026  2906              CMP      r1,#6                 ;110
000028  d3f9              BCC      |L8.30|
;;;114        }
;;;115    }
00002a  bd10              POP      {r4,pc}
;;;116    
                          ENDP

                  |L8.44|
                          DCD      ||.data||

                          AREA ||i.init_len_info||, CODE, READONLY, ALIGN=2

                  init_len_info PROC
;;;403    // do some basic length calculations and store the result in static varibales
;;;404    void init_len_info(unsigned char *buf)
000000  8a01              LDRH     r1,[r0,#0x10]
;;;405    {
;;;406        info_data_len=(buf[IP_TOTLEN_H_P]<<8)|(buf[IP_TOTLEN_L_P]&0xff);
;;;407        info_data_len-=IP_HEADER_LEN;
;;;408        info_hdr_len=(buf[TCP_HEADER_LEN_P]>>4)*4; // generate len in bytes;
000002  f890002e          LDRB     r0,[r0,#0x2e]
000006  4a04              LDR      r2,|L9.24|
000008  0900              LSRS     r0,r0,#4
00000a  ba49              REV16    r1,r1                 ;406
00000c  0080              LSLS     r0,r0,#2
00000e  3914              SUBS     r1,r1,#0x14           ;407
;;;409        info_data_len-=info_hdr_len;
000010  6050              STR      r0,[r2,#4]  ; info_hdr_len
000012  1a08              SUBS     r0,r1,r0
000014  6090              STR      r0,[r2,#8]  ; info_data_len
;;;410        if (info_data_len<=0)
;;;411        {
;;;412            info_data_len=0;
;;;413        }
;;;414    }
000016  4770              BX       lr
;;;415    
                          ENDP

                  |L9.24|
                          DCD      ||.data||

                          AREA ||i.make_arp_answer_from_request||, CODE, READONLY, ALIGN=2

                  make_arp_answer_from_request PROC
;;;287    
;;;288    void make_arp_answer_from_request(unsigned char *buf)
000000  b570              PUSH     {r4-r6,lr}
;;;289    {
000002  4605              MOV      r5,r0
;;;290        unsigned char i=0;
000004  2400              MOVS     r4,#0
;;;291        //
;;;292        make_eth(buf);
000006  f7fffffe          BL       make_eth
;;;293        buf[ETH_ARP_OPCODE_H_P]=ETH_ARP_OPCODE_REPLY_H_V;   //arp ÏìÓ¦
00000a  2000              MOVS     r0,#0
00000c  7528              STRB     r0,[r5,#0x14]
;;;294        buf[ETH_ARP_OPCODE_L_P]=ETH_ARP_OPCODE_REPLY_L_V;
00000e  2002              MOVS     r0,#2
;;;295        // fill the mac addresses:
;;;296        while(i<6)
;;;297        {
;;;298            buf[ETH_ARP_DST_MAC_P+i]=buf[ETH_ARP_SRC_MAC_P+i];
;;;299            buf[ETH_ARP_SRC_MAC_P+i]=macaddr[i];
000010  490f              LDR      r1,|L10.80|
000012  7568              STRB     r0,[r5,#0x15]         ;294
                  |L10.20|
000014  1928              ADDS     r0,r5,r4              ;298
000016  7d82              LDRB     r2,[r0,#0x16]         ;298
000018  f8802020          STRB     r2,[r0,#0x20]         ;298
00001c  5d0a              LDRB     r2,[r1,r4]
;;;300            i++;
00001e  1c64              ADDS     r4,r4,#1
000020  b2e4              UXTB     r4,r4
000022  7582              STRB     r2,[r0,#0x16]         ;299
000024  2c06              CMP      r4,#6                 ;296
000026  d3f5              BCC      |L10.20|
;;;301        }
;;;302        i=0;
;;;303        while(i<4)
;;;304        {
;;;305            buf[ETH_ARP_DST_IP_P+i]=buf[ETH_ARP_SRC_IP_P+i];
;;;306            buf[ETH_ARP_SRC_IP_P+i]=ipaddr[i];
000028  4909              LDR      r1,|L10.80|
00002a  2200              MOVS     r2,#0                 ;302
00002c  1f09              SUBS     r1,r1,#4
                  |L10.46|
00002e  18a8              ADDS     r0,r5,r2              ;305
000030  7f03              LDRB     r3,[r0,#0x1c]         ;305
000032  f8803026          STRB     r3,[r0,#0x26]         ;305
000036  5c8b              LDRB     r3,[r1,r2]
;;;307            i++;
000038  1c52              ADDS     r2,r2,#1
00003a  b2d2              UXTB     r2,r2
00003c  7703              STRB     r3,[r0,#0x1c]         ;306
00003e  2a04              CMP      r2,#4                 ;303
000040  d3f5              BCC      |L10.46|
;;;308        }
;;;309        // eth+arp is 42 bytes:
;;;310        enc28j60PacketSend(42,buf); 
000042  4629              MOV      r1,r5
000044  e8bd4070          POP      {r4-r6,lr}
000048  202a              MOVS     r0,#0x2a
00004a  f7ffbffe          B.W      enc28j60PacketSend
;;;311    }
;;;312    
                          ENDP

00004e  0000              DCW      0x0000
                  |L10.80|
                          DCD      ||.data||+0x10

                          AREA ||i.make_echo_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_echo_reply_from_request PROC
;;;312    
;;;313    void make_echo_reply_from_request(unsigned char *buf,unsigned  int len)
000000  b570              PUSH     {r4-r6,lr}
;;;314    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;315        make_eth(buf);
000006  f7fffffe          BL       make_eth
;;;316        make_ip(buf);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       make_ip
;;;317        buf[ICMP_TYPE_P]=ICMP_TYPE_ECHOREPLY_V;	  //////»ØËÍÓ¦´ð////////////////////////////////////////////////////////////////////////////
000010  2000              MOVS     r0,#0
000012  f8840022          STRB     r0,[r4,#0x22]
;;;318        // we changed only the icmp.type field from request(=8) to reply(=0).
;;;319        // we can therefore easily correct the checksum:
;;;320        if (buf[ICMP_CHECKSUM_P] > (0xff-0x08))
000016  f8940024          LDRB     r0,[r4,#0x24]
00001a  28f7              CMP      r0,#0xf7
00001c  d904              BLS      |L11.40|
;;;321        {
;;;322            buf[ICMP_CHECKSUM_P+1]++;
00001e  f8941025          LDRB     r1,[r4,#0x25]
000022  1c49              ADDS     r1,r1,#1
000024  f8841025          STRB     r1,[r4,#0x25]
                  |L11.40|
;;;323        }
;;;324        buf[ICMP_CHECKSUM_P]+=0x08;
000028  3008              ADDS     r0,r0,#8
00002a  f8840024          STRB     r0,[r4,#0x24]
;;;325        //
;;;326        enc28j60PacketSend(len,buf);
00002e  4621              MOV      r1,r4
000030  4628              MOV      r0,r5
000032  e8bd4070          POP      {r4-r6,lr}
000036  f7ffbffe          B.W      enc28j60PacketSend
;;;327    }
;;;328    
                          ENDP


                          AREA ||i.make_eth||, CODE, READONLY, ALIGN=2

                  make_eth PROC
;;;167    // make a return eth header from a received eth packet
;;;168    void make_eth(unsigned char *buf)
000000  b510              PUSH     {r4,lr}
;;;169    {
;;;170        unsigned char i=0;
;;;171        //
;;;172        //copy the destination mac from the source and fill my mac into src
;;;173        while(i<6)
;;;174        {
;;;175            buf[ETH_DST_MAC +i]=buf[ETH_SRC_MAC +i];
;;;176            buf[ETH_SRC_MAC +i]=macaddr[i];
000002  4b06              LDR      r3,|L12.28|
000004  2100              MOVS     r1,#0                 ;170
                  |L12.6|
000006  1842              ADDS     r2,r0,r1              ;175
000008  7994              LDRB     r4,[r2,#6]            ;175
00000a  5444              STRB     r4,[r0,r1]            ;175
00000c  5c5c              LDRB     r4,[r3,r1]
;;;177            i++;
00000e  1c49              ADDS     r1,r1,#1
000010  b2c9              UXTB     r1,r1
000012  7194              STRB     r4,[r2,#6]            ;176
000014  2906              CMP      r1,#6                 ;173
000016  d3f6              BCC      |L12.6|
;;;178        }
;;;179    }
000018  bd10              POP      {r4,pc}
;;;180    void fill_ip_hdr_checksum(unsigned char *buf)
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
                          DCD      ||.data||+0x10

                          AREA ||i.make_ip||, CODE, READONLY, ALIGN=2

                  make_ip PROC
;;;195    // make a return ip header from a received ip packet
;;;196    void make_ip(unsigned char *buf)
000000  b410              PUSH     {r4}
;;;197    {
;;;198        unsigned char i=0;
;;;199        while(i<4)
;;;200        {
;;;201            buf[IP_DST_P+i]=buf[IP_SRC_P+i];
;;;202            buf[IP_SRC_P+i]=ipaddr[i];
000002  4b07              LDR      r3,|L13.32|
000004  2100              MOVS     r1,#0                 ;198
                  |L13.6|
000006  1842              ADDS     r2,r0,r1              ;201
000008  7e94              LDRB     r4,[r2,#0x1a]         ;201
00000a  7794              STRB     r4,[r2,#0x1e]         ;201
00000c  5c5c              LDRB     r4,[r3,r1]
;;;203            i++;
00000e  1c49              ADDS     r1,r1,#1
000010  b2c9              UXTB     r1,r1
000012  7694              STRB     r4,[r2,#0x1a]         ;202
000014  2904              CMP      r1,#4                 ;199
000016  d3f6              BCC      |L13.6|
;;;204        }
;;;205        fill_ip_hdr_checksum(buf);
000018  bc10              POP      {r4}
00001a  f7ffbffe          B.W      fill_ip_hdr_checksum
;;;206    }
;;;207    
                          ENDP

00001e  0000              DCW      0x0000
                  |L13.32|
                          DCD      ||.data||+0xc

                          AREA ||i.make_tcp_ack_from_any||, CODE, READONLY, ALIGN=2

                  make_tcp_ack_from_any PROC
;;;453    // This will modify the eth/ip/tcp header 
;;;454    void make_tcp_ack_from_any(unsigned char *buf)
000000  b510              PUSH     {r4,lr}
;;;455    {
000002  4604              MOV      r4,r0
;;;456        unsigned  int j;
;;;457        make_eth(buf);
000004  f7fffffe          BL       make_eth
;;;458        // fill the header:
;;;459        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V;
000008  2010              MOVS     r0,#0x10
00000a  f884002f          STRB     r0,[r4,#0x2f]
;;;460        if (info_data_len==0)
00000e  4811              LDR      r0,|L14.84|
;;;461        {
;;;462            // if there is no data then we must still acknoledge one packet
;;;463            make_tcphead(buf,1,0,1); // no options
;;;464        }
;;;465        else
;;;466        {
;;;467            make_tcphead(buf,info_data_len,0,1); // no options
000010  f04f0301          MOV      r3,#1
000014  f04f0200          MOV      r2,#0
000018  6881              LDR      r1,[r0,#8]            ;460  ; info_data_len
00001a  b901              CBNZ     r1,|L14.30|
00001c  2101              MOVS     r1,#1                 ;463
                  |L14.30|
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       make_tcphead
;;;468        }
;;;469        
;;;470        // total length field in the IP header must be set:
;;;471        // 20 bytes IP + 20 bytes tcp (when no options) 
;;;472        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN;
;;;473        buf[IP_TOTLEN_H_P]=j>>8;
000024  2000              MOVS     r0,#0
000026  7420              STRB     r0,[r4,#0x10]
;;;474        buf[IP_TOTLEN_L_P]=j& 0xff;
000028  2028              MOVS     r0,#0x28
00002a  7460              STRB     r0,[r4,#0x11]
;;;475        make_ip(buf);
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       make_ip
;;;476        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;477        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN,2);
000032  2202              MOVS     r2,#2
000034  211c              MOVS     r1,#0x1c
000036  f104001a          ADD      r0,r4,#0x1a
00003a  f7fffffe          BL       checksum
;;;478        buf[TCP_CHECKSUM_H_P]=j>>8;
00003e  0a01              LSRS     r1,r0,#8
000040  f8841032          STRB     r1,[r4,#0x32]
;;;479        buf[TCP_CHECKSUM_L_P]=j& 0xff;
000044  f8840033          STRB     r0,[r4,#0x33]
;;;480        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+ETH_HEADER_LEN,buf);
000048  4621              MOV      r1,r4
00004a  e8bd4010          POP      {r4,lr}
00004e  2036              MOVS     r0,#0x36
000050  f7ffbffe          B.W      enc28j60PacketSend
;;;481    }
;;;482    
                          ENDP

                  |L14.84|
                          DCD      ||.data||

                          AREA ||i.make_tcp_ack_with_data||, CODE, READONLY, ALIGN=1

                  make_tcp_ack_with_data PROC
;;;487    // length and checksum
;;;488    void make_tcp_ack_with_data(unsigned char *buf,unsigned  int dlen)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
000002  4604              MOV      r4,r0
;;;490        unsigned  int j;
;;;491        // fill the header:
;;;492        // This code requires that we send only one data packet
;;;493        // because we keep no state information. We must therefore set
;;;494        // the fin here:
;;;495        buf[TCP_FLAGS_P]=TCP_FLAGS_ACK_V|TCP_FLAGS_PUSH_V|TCP_FLAGS_FIN_V;
000004  2019              MOVS     r0,#0x19
000006  f884002f          STRB     r0,[r4,#0x2f]
00000a  460d              MOV      r5,r1                 ;489
;;;496        
;;;497        // total length field in the IP header must be set:
;;;498        // 20 bytes IP + 20 bytes tcp (when no options) + len of data
;;;499        j=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen;
00000c  f1010028          ADD      r0,r1,#0x28
;;;500        buf[IP_TOTLEN_H_P]=j>>8;
000010  0a01              LSRS     r1,r0,#8
000012  7421              STRB     r1,[r4,#0x10]
;;;501        buf[IP_TOTLEN_L_P]=j& 0xff;
000014  7460              STRB     r0,[r4,#0x11]
;;;502        fill_ip_hdr_checksum(buf);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       fill_ip_hdr_checksum
;;;503        // zero the checksum
;;;504        buf[TCP_CHECKSUM_H_P]=0;
00001c  2000              MOVS     r0,#0
00001e  f8840032          STRB     r0,[r4,#0x32]
;;;505        buf[TCP_CHECKSUM_L_P]=0;
000022  f8840033          STRB     r0,[r4,#0x33]
;;;506        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + data len
;;;507        j=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+dlen,2);
000026  2202              MOVS     r2,#2
000028  f105011c          ADD      r1,r5,#0x1c
00002c  f104001a          ADD      r0,r4,#0x1a
000030  f7fffffe          BL       checksum
;;;508        buf[TCP_CHECKSUM_H_P]=j>>8;
000034  0a01              LSRS     r1,r0,#8
000036  f8841032          STRB     r1,[r4,#0x32]
;;;509        buf[TCP_CHECKSUM_L_P]=j& 0xff;
00003a  f8840033          STRB     r0,[r4,#0x33]
;;;510        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+dlen+ETH_HEADER_LEN,buf);
00003e  4621              MOV      r1,r4
000040  f1050036          ADD      r0,r5,#0x36
000044  e8bd4070          POP      {r4-r6,lr}
000048  f7ffbffe          B.W      enc28j60PacketSend
;;;511    }
;;;512    
                          ENDP


                          AREA ||i.make_tcp_synack_from_syn||, CODE, READONLY, ALIGN=1

                  make_tcp_synack_from_syn PROC
;;;368    
;;;369    void make_tcp_synack_from_syn(unsigned char *buf)
000000  b510              PUSH     {r4,lr}
;;;370    {
000002  4604              MOV      r4,r0
;;;371        unsigned  int ck;
;;;372        make_eth(buf);
000004  f7fffffe          BL       make_eth
;;;373        // total length field in the IP header must be set:
;;;374        // 20 bytes IP + 24 bytes (20tcp+4tcp options)
;;;375        buf[IP_TOTLEN_H_P]=0;
000008  2000              MOVS     r0,#0
00000a  7420              STRB     r0,[r4,#0x10]
;;;376        buf[IP_TOTLEN_L_P]=IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4;
00000c  202c              MOVS     r0,#0x2c
00000e  7460              STRB     r0,[r4,#0x11]
;;;377        make_ip(buf);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       make_ip
;;;378        buf[TCP_FLAGS_P]=TCP_FLAGS_SYNACK_V;
000016  2012              MOVS     r0,#0x12
000018  f884002f          STRB     r0,[r4,#0x2f]
;;;379        make_tcphead(buf,1,1,0);
00001c  2201              MOVS     r2,#1
00001e  2300              MOVS     r3,#0
000020  4611              MOV      r1,r2
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       make_tcphead
;;;380        // calculate the checksum, len=8 (start from ip.src) + TCP_HEADER_LEN_PLAIN + 4 (one option: mss)
;;;381        ck=checksum(&buf[IP_SRC_P], 8+TCP_HEADER_LEN_PLAIN+4,2);
000028  2202              MOVS     r2,#2
00002a  2120              MOVS     r1,#0x20
00002c  f104001a          ADD      r0,r4,#0x1a
000030  f7fffffe          BL       checksum
;;;382        buf[TCP_CHECKSUM_H_P]=ck>>8;
000034  0a01              LSRS     r1,r0,#8
000036  f8841032          STRB     r1,[r4,#0x32]
;;;383        buf[TCP_CHECKSUM_L_P]=ck& 0xff;
00003a  f8840033          STRB     r0,[r4,#0x33]
;;;384        // add 4 for option mss:
;;;385        enc28j60PacketSend(IP_HEADER_LEN+TCP_HEADER_LEN_PLAIN+4+ETH_HEADER_LEN,buf);
00003e  4621              MOV      r1,r4
000040  e8bd4010          POP      {r4,lr}
000044  203a              MOVS     r0,#0x3a
000046  f7ffbffe          B.W      enc28j60PacketSend
;;;386    }
;;;387    
                          ENDP


                          AREA ||i.make_tcphead||, CODE, READONLY, ALIGN=2

                  make_tcphead PROC
;;;215    // otherwise it is copied from the packet we received
;;;216    void make_tcphead(unsigned char *buf,unsigned  int rel_ack_num,unsigned char mss,unsigned char cp_seq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;217    {
;;;218        unsigned char i=0;
000002  2400              MOVS     r4,#0
000004  4626              MOV      r6,r4
                  |L17.6|
;;;219        unsigned char tseq;
;;;220        while(i<2)
;;;221        {
;;;222            buf[TCP_DST_PORT_H_P+i]=buf[TCP_SRC_PORT_H_P+i];
000006  1905              ADDS     r5,r0,r4
;;;223            buf[TCP_SRC_PORT_H_P+i]=0; // clear source port
;;;224            i++;
000008  1c64              ADDS     r4,r4,#1
00000a  f8157f22          LDRB     r7,[r5,#0x22]!        ;222
00000e  b2e4              UXTB     r4,r4
000010  70af              STRB     r7,[r5,#2]            ;222
000012  702e              STRB     r6,[r5,#0]            ;223
000014  2c02              CMP      r4,#2                 ;220
000016  d3f6              BCC      |L17.6|
;;;225        }
;;;226        // set source port  (http):
;;;227        buf[TCP_SRC_PORT_L_P]=wwwport;
000018  f8dfc080          LDR      r12,|L17.156|
00001c  f89c4000          LDRB     r4,[r12,#0]  ; wwwport
000020  f8804023          STRB     r4,[r0,#0x23]
;;;228        i=4;
000024  2404              MOVS     r4,#4
                  |L17.38|
;;;229        // sequence numbers:
;;;230        // add the rel ack num to SEQACK
;;;231        while(i>0)
;;;232        {
;;;233            rel_ack_num=buf[TCP_SEQ_H_P+i-1]+rel_ack_num;
000026  1905              ADDS     r5,r0,r4
000028  f8157f25          LDRB     r7,[r5,#0x25]!
00002c  4439              ADD      r1,r1,r7
;;;234            tseq=buf[TCP_SEQACK_H_P+i-1];
00002e  792f              LDRB     r7,[r5,#4]
;;;235            buf[TCP_SEQACK_H_P+i-1]=0xff&rel_ack_num;
000030  7129              STRB     r1,[r5,#4]
000032  f1a50525          SUB      r5,r5,#0x25
;;;236            if (cp_seq)
000036  b113              CBZ      r3,|L17.62|
;;;237            {
;;;238                // copy the acknum sent to us into the sequence number
;;;239                buf[TCP_SEQ_H_P+i-1]=tseq;
000038  f8857025          STRB     r7,[r5,#0x25]
00003c  e001              B        |L17.66|
                  |L17.62|
;;;240            }
;;;241            else
;;;242            {
;;;243                buf[TCP_SEQ_H_P+i-1]= 0; // some preset vallue
00003e  f8856025          STRB     r6,[r5,#0x25]
                  |L17.66|
;;;244            }
;;;245            rel_ack_num=rel_ack_num>>8;
000042  0a09              LSRS     r1,r1,#8
;;;246            i--;
000044  1e64              SUBS     r4,r4,#1
000046  f01404ff          ANDS     r4,r4,#0xff
00004a  d1ec              BNE      |L17.38|
;;;247        }
;;;248        if (cp_seq==0)
00004c  b963              CBNZ     r3,|L17.104|
;;;249        {
;;;250            // put inital seq number
;;;251            buf[TCP_SEQ_H_P+0]= 0;
00004e  f8006f26          STRB     r6,[r0,#0x26]!
;;;252            buf[TCP_SEQ_H_P+1]= 0;
000052  7046              STRB     r6,[r0,#1]
;;;253            // we step only the second byte, this allows us to send packts 
;;;254            // with 255 bytes or 512 (if we step the initial seqnum by 2)
;;;255            buf[TCP_SEQ_H_P+2]= seqnum; 
000054  f89c1001          LDRB     r1,[r12,#1]  ; seqnum
000058  7081              STRB     r1,[r0,#2]
;;;256            buf[TCP_SEQ_H_P+3]= 0;
00005a  70c6              STRB     r6,[r0,#3]
;;;257            // step the inititial seq num by something we will not use
;;;258            // during this tcp session:
;;;259            seqnum+=2;
00005c  f1010102          ADD      r1,r1,#2
000060  f1a00026          SUB      r0,r0,#0x26           ;256
000064  f88c1001          STRB     r1,[r12,#1]
                  |L17.104|
;;;260        }
;;;261        // zero the checksum
;;;262        buf[TCP_CHECKSUM_H_P]=0;
000068  f8806032          STRB     r6,[r0,#0x32]
;;;263        buf[TCP_CHECKSUM_L_P]=0;
00006c  f8806033          STRB     r6,[r0,#0x33]
;;;264        
;;;265        // The tcp header length is only a 4 bit field (the upper 4 bits).
;;;266        // It is calculated in units of 4 bytes. 
;;;267        // E.g 24 bytes: 24/4=6 => 0x60=header len field
;;;268        //buf[TCP_HEADER_LEN_P]=(((TCP_HEADER_LEN_PLAIN+4)/4)) <<4; // 0x60
;;;269        if (mss)
000070  b182              CBZ      r2,|L17.148|
;;;270        {
;;;271            // the only option we set is MSS to 1408:
;;;272            // 1408 in hex is 0x580
;;;273            buf[TCP_OPTIONS_P]=2;
000072  f100002e          ADD      r0,r0,#0x2e
000076  2102              MOVS     r1,#2
000078  7201              STRB     r1,[r0,#8]
;;;274            buf[TCP_OPTIONS_P+1]=4;
00007a  f04f0104          MOV      r1,#4
00007e  7241              STRB     r1,[r0,#9]
;;;275            buf[TCP_OPTIONS_P+2]=0x05; 
000080  f04f0105          MOV      r1,#5
000084  7281              STRB     r1,[r0,#0xa]
;;;276            buf[TCP_OPTIONS_P+3]=0x80;
000086  f04f0180          MOV      r1,#0x80
00008a  72c1              STRB     r1,[r0,#0xb]
;;;277            // 24 bytes:
;;;278            buf[TCP_HEADER_LEN_P]=0x60;
00008c  f04f0160          MOV      r1,#0x60
000090  7001              STRB     r1,[r0,#0]
;;;279        }
;;;280        else
;;;281        {
;;;282            // no options:
;;;283            // 20 bytes:
;;;284            buf[TCP_HEADER_LEN_P]=0x50;
;;;285        }
;;;286    }
000092  bdf0              POP      {r4-r7,pc}
                  |L17.148|
000094  2150              MOVS     r1,#0x50              ;284
000096  f880102e          STRB     r1,[r0,#0x2e]         ;284
00009a  bdf0              POP      {r4-r7,pc}
;;;287    
                          ENDP

                  |L17.156|
                          DCD      ||.data||

                          AREA ||i.make_udp_reply_from_request||, CODE, READONLY, ALIGN=1

                  make_udp_reply_from_request PROC
;;;329    // you can send a max of 220 bytes of data
;;;330    void make_udp_reply_from_request(unsigned char *buf,char *data,unsigned int datalen,unsigned  int port)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;331    {
000004  4688              MOV      r8,r1
000006  4616              MOV      r6,r2
000008  461f              MOV      r7,r3
00000a  4604              MOV      r4,r0
;;;332        unsigned int i=0,j=0;
00000c  2500              MOVS     r5,#0
;;;333        unsigned  int ck;
;;;334        make_eth(buf);
00000e  f7fffffe          BL       make_eth
;;;335        //if (datalen>220)
;;;336        //	{
;;;337        //    datalen=220;
;;;338        //	}
;;;339        
;;;340        // total length field in the IP header must be set:
;;;341        i= IP_HEADER_LEN+UDP_HEADER_LEN+datalen;
000012  f106001c          ADD      r0,r6,#0x1c
;;;342        buf[IP_TOTLEN_H_P]=i>>8;
000016  0a01              LSRS     r1,r0,#8
000018  7421              STRB     r1,[r4,#0x10]
;;;343        buf[IP_TOTLEN_L_P]=i;
00001a  7460              STRB     r0,[r4,#0x11]
;;;344        make_ip(buf);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       make_ip
;;;345    
;;;346        buf[UDP_DST_PORT_H_P] =	buf[UDP_SRC_PORT_H_P];
000022  f8140f22          LDRB     r0,[r4,#0x22]!
000026  70a0              STRB     r0,[r4,#2]
;;;347        buf[UDP_DST_PORT_L_P] = buf[UDP_SRC_PORT_L_P];
000028  7860              LDRB     r0,[r4,#1]
00002a  70e0              STRB     r0,[r4,#3]
;;;348        buf[UDP_SRC_PORT_H_P] =	port >> 8;
00002c  0a38              LSRS     r0,r7,#8
00002e  7020              STRB     r0,[r4,#0]
;;;349        buf[UDP_SRC_PORT_L_P] =	port & 0xff;
000030  7067              STRB     r7,[r4,#1]
;;;350        // source port does not matter and is what the sender used.
;;;351        // calculte the udp length:
;;;352        buf[UDP_LEN_H_P]=datalen>>8;
000032  0a30              LSRS     r0,r6,#8
000034  7120              STRB     r0,[r4,#4]
;;;353        buf[UDP_LEN_L_P]=UDP_HEADER_LEN+datalen;
000036  f1060008          ADD      r0,r6,#8
00003a  7160              STRB     r0,[r4,#5]
;;;354        // zero the checksum
;;;355        buf[UDP_CHECKSUM_H_P]=0;
00003c  2000              MOVS     r0,#0
00003e  71a0              STRB     r0,[r4,#6]
;;;356        buf[UDP_CHECKSUM_L_P]=0;
000040  71e0              STRB     r0,[r4,#7]
000042  f1a40422          SUB      r4,r4,#0x22
;;;357        // copy the data:
;;;358        while(j<datalen)
000046  e005              B        |L18.84|
                  |L18.72|
;;;359        {
;;;360            buf[UDP_DATA_P+j]=data[j];
000048  f8180005          LDRB     r0,[r8,r5]
00004c  1961              ADDS     r1,r4,r5
;;;361            j++;
00004e  1c6d              ADDS     r5,r5,#1
000050  f881002a          STRB     r0,[r1,#0x2a]         ;360
                  |L18.84|
000054  42b5              CMP      r5,r6                 ;358
000056  d3f7              BCC      |L18.72|
;;;362        }
;;;363        ck=checksum(&buf[IP_SRC_P], 16 + datalen,1);
000058  2201              MOVS     r2,#1
00005a  f1060110          ADD      r1,r6,#0x10
00005e  f104001a          ADD      r0,r4,#0x1a
000062  f7fffffe          BL       checksum
;;;364        buf[UDP_CHECKSUM_H_P]=ck>>8;
000066  0a01              LSRS     r1,r0,#8
000068  f8841028          STRB     r1,[r4,#0x28]
;;;365        buf[UDP_CHECKSUM_L_P]=ck& 0xff;
00006c  f8840029          STRB     r0,[r4,#0x29]
;;;366        enc28j60PacketSend(UDP_HEADER_LEN+IP_HEADER_LEN+ETH_HEADER_LEN+datalen,buf);
000070  4621              MOV      r1,r4
000072  f106002a          ADD      r0,r6,#0x2a
000076  e8bd41f0          POP      {r4-r8,lr}
00007a  f7ffbffe          B.W      enc28j60PacketSend
;;;367    }
;;;368    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  wwwport
000000  50                DCB      0x50
                  seqnum
000001  0a0000            DCB      0x0a,0x00,0x00
                  info_hdr_len
                          DCD      0x00000000
                  info_data_len
                          DCD      0x00000000
                  ipaddr
                          DCD      0x00000000
                  macaddr
                          DCD      0x00000000
000014  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "Source\\Net\\ip_arp_udp_tcp.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_ip_arp_udp_tcp_c_checksum____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_ip_arp_udp_tcp_c_checksum____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_ip_arp_udp_tcp_c_checksum____REVSH|
#line 128
|__asm___16_ip_arp_udp_tcp_c_checksum____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
