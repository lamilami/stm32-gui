; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\mot.o --depend=.\ouput\mot.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\mot.crf Source\Mot\mot.c]
                          THUMB

                          AREA ||i.EXIT9_5||, CODE, READONLY, ALIGN=2

                  EXIT9_5 PROC
;;;775    #ifndef WIN_SIM
;;;776    void EXIT9_5()
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;777    {
;;;778       int i;
;;;779       if(EXTI_GetITStatus(EXTI_Line5) != RESET)// 默认为1	SW1
000004  2020              MOVS     r0,#0x20
000006  f7fffffe          BL       EXTI_GetITStatus
;;;780      {
;;;781      	EXTI_ClearITPendingBit(EXTI_Line5);
;;;782    	  	if((SW1 != init_sw1_state)&&(!sw1_already_oper))
;;;783    	{
;;;784    		for(i=0;i<1000;i++)
;;;785    		{
;;;786    		if(SW1 == init_sw1_state )
;;;787    		{
;;;788    		 
;;;789    		return;
;;;790    
;;;791    		}
;;;792    		}
;;;793    	  sw1_already_oper = 1;
;;;794    	  
;;;795    	  if(sw2_already_oper)
;;;796    	  {
;;;797    	  one_stop();
;;;798    
;;;799    	  }else{
;;;800    	   get_data.sw1_speed = get_data.speed;
;;;801    	   record.e_work_state[record.test_times] = GET_V1;
00000a  4e30              LDR      r6,|L1.204|
00000c  f8df80b8          LDR      r8,|L1.200|
000010  4f2f              LDR      r7,|L1.208|
000012  f04f0b01          MOV      r11,#1                ;793
000016  f04f0902          MOV      r9,#2
00001a  1cb5              ADDS     r5,r6,#2
00001c  f44f7a7a          MOV      r10,#0x3e8            ;784
000020  b1d8              CBZ      r0,|L1.90|
000022  2020              MOVS     r0,#0x20              ;781
000024  f7fffffe          BL       EXTI_ClearITPendingBit
000028  2120              MOVS     r1,#0x20              ;782
00002a  482a              LDR      r0,|L1.212|
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  78f9              LDRB     r1,[r7,#3]            ;782  ; init_sw1_state
000032  4288              CMP      r0,r1                 ;782
000034  d045              BEQ      |L1.194|
000036  7878              LDRB     r0,[r7,#1]            ;782  ; sw1_already_oper
000038  2800              CMP      r0,#0                 ;782
00003a  d142              BNE      |L1.194|
00003c  2400              MOVS     r4,#0                 ;784
                  |L1.62|
00003e  2120              MOVS     r1,#0x20              ;786
000040  4824              LDR      r0,|L1.212|
000042  f7fffffe          BL       GPIO_ReadInputDataBit
000046  78f9              LDRB     r1,[r7,#3]            ;786  ; init_sw1_state
000048  4288              CMP      r0,r1                 ;786
00004a  d03a              BEQ      |L1.194|
00004c  1c64              ADDS     r4,r4,#1              ;784
00004e  4554              CMP      r4,r10                ;784
000050  dbf5              BLT      |L1.62|
000052  f887b001          STRB     r11,[r7,#1]           ;793
000056  78b8              LDRB     r0,[r7,#2]            ;795  ; sw2_already_oper
000058  e01f              B        |L1.154|
                  |L1.90|
;;;802    	   get_data.e_work_state = GET_V1;
;;;803    	   TIM_Cmd(TIM7, ENABLE);
;;;804    	  }
;;;805    	}
;;;806    
;;;807      }else if(EXTI_GetITStatus(EXTI_Line6) != RESET)//默认为2
00005a  2040              MOVS     r0,#0x40
00005c  f7fffffe          BL       EXTI_GetITStatus
000060  2800              CMP      r0,#0
000062  d02e              BEQ      |L1.194|
;;;808      {
;;;809        EXTI_ClearITPendingBit(EXTI_Line6);
000064  2040              MOVS     r0,#0x40
000066  f7fffffe          BL       EXTI_ClearITPendingBit
;;;810      	if((SW2 != init_sw2_state)&&(!sw2_already_oper))
00006a  2140              MOVS     r1,#0x40
00006c  4819              LDR      r0,|L1.212|
00006e  f7fffffe          BL       GPIO_ReadInputDataBit
000072  7939              LDRB     r1,[r7,#4]  ; init_sw2_state
000074  4288              CMP      r0,r1
000076  d024              BEQ      |L1.194|
000078  78b8              LDRB     r0,[r7,#2]  ; sw2_already_oper
00007a  2800              CMP      r0,#0
00007c  d121              BNE      |L1.194|
;;;811    	{
;;;812    		for(i=0;i<1000;i++)
00007e  2400              MOVS     r4,#0
                  |L1.128|
;;;813    		{
;;;814    		if(SW2 == init_sw2_state )
000080  2140              MOVS     r1,#0x40
000082  4814              LDR      r0,|L1.212|
000084  f7fffffe          BL       GPIO_ReadInputDataBit
000088  7939              LDRB     r1,[r7,#4]  ; init_sw2_state
00008a  4288              CMP      r0,r1
00008c  d019              BEQ      |L1.194|
00008e  1c64              ADDS     r4,r4,#1              ;812
000090  4554              CMP      r4,r10                ;812
000092  dbf5              BLT      |L1.128|
;;;815    		{
;;;816    		return;
;;;817    		}
;;;818    		}
;;;819    	  sw2_already_oper = 1;
000094  f887b002          STRB     r11,[r7,#2]
;;;820    	  
;;;821    	  if(sw1_already_oper)
000098  7878              LDRB     r0,[r7,#1]  ; sw1_already_oper
                  |L1.154|
00009a  b118              CBZ      r0,|L1.164|
;;;822    	  {
;;;823    	  one_stop();
00009c  e8bd5ff0          POP      {r4-r12,lr}
0000a0  f7ffbffe          B.W      one_stop
                  |L1.164|
;;;824    	  }else{
;;;825    	   get_data.sw1_speed = get_data.speed;
0000a4  f8d81010          LDR      r1,[r8,#0x10]  ; get_data
;;;826    	   record.e_work_state[record.test_times] = GET_V1;
0000a8  f8c81014          STR      r1,[r8,#0x14]  ; get_data
0000ac  7832              LDRB     r2,[r6,#0]  ; record
;;;827    	   get_data.e_work_state = GET_V1;
;;;828    	   TIM_Cmd(TIM7, ENABLE);
0000ae  2101              MOVS     r1,#1
0000b0  4809              LDR      r0,|L1.216|
0000b2  f8029005          STRB     r9,[r2,r5]            ;826
0000b6  f8889000          STRB     r9,[r8,#0]            ;827
0000ba  e8bd5ff0          POP      {r4-r12,lr}
0000be  f7ffbffe          B.W      TIM_Cmd
                  |L1.194|
;;;829    	  }
;;;830    	}
;;;831      }
;;;832    }
0000c2  e8bd9ff0          POP      {r4-r12,pc}
;;;833    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L1.200|
                          DCD      get_data
                  |L1.204|
                          DCD      record
                  |L1.208|
                          DCD      ||.data||
                  |L1.212|
                          DCD      0x40011800
                  |L1.216|
                          DCD      0x40001400

                          AREA ||i.TIM2_Interrupt||, CODE, READONLY, ALIGN=2

                  TIM2_Interrupt PROC
;;;411    // 问题的解决 结合 次数显示法+基础滤波
;;;412    void TIM2_Interrupt(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;413    {	
;;;414    unsigned int i;
;;;415    
;;;416    #ifdef TEST_MODE_1
;;;417    
;;;418      if((TIM_GetITStatus(TIM2, TIM_IT_CC1) == SET)&&(TIM_GetITStatus(TIM2, TIM_IT_Update) != SET)) 
000004  2102              MOVS     r1,#2
000006  074e              LSLS     r6,r1,#29
000008  4630              MOV      r0,r6
00000a  f7fffffe          BL       TIM_GetITStatus
;;;419      {
;;;420      	for(i=0;i<1500;i++)	 // 3 基础滤波
;;;421    	{
;;;422    	  if(GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_0)!=0)
;;;423    	   {
;;;424    	   TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
;;;425    	   return;
;;;426    	   }
;;;427    	}
;;;428    
;;;429    	 if(last_cap_value == 0)
00000e  4d47              LDR      r5,|L2.300|
000010  2801              CMP      r0,#1                 ;418
000012  d134              BNE      |L2.126|
000014  2101              MOVS     r1,#1                 ;418
000016  4630              MOV      r0,r6                 ;418
000018  f7fffffe          BL       TIM_GetITStatus
00001c  2801              CMP      r0,#1                 ;418
00001e  d02e              BEQ      |L2.126|
000020  f8df810c          LDR      r8,|L2.304|
000024  2400              MOVS     r4,#0                 ;420
000026  f24057dc          MOV      r7,#0x5dc             ;420
                  |L2.42|
00002a  2101              MOVS     r1,#1                 ;422
00002c  4640              MOV      r0,r8                 ;422
00002e  f7fffffe          BL       GPIO_ReadInputDataBit
000032  b108              CBZ      r0,|L2.56|
                  |L2.52|
000034  2102              MOVS     r1,#2                 ;424
000036  e032              B        |L2.158|
                  |L2.56|
000038  1c64              ADDS     r4,r4,#1              ;420
00003a  42bc              CMP      r4,r7                 ;420
00003c  d3f5              BCC      |L2.42|
00003e  68a8              LDR      r0,[r5,#8]  ; last_cap_value
000040  2800              CMP      r0,#0
;;;430    	{
;;;431    	  last_cap_value = time_up*0x10000+TIM_GetCapture1(TIM2);
;;;432    	  last_speed = 0;
;;;433    
;;;434    	}else{
;;;435    	  current_cap_value = time_up*0x10000+ TIM_GetCapture1(TIM2);
000042  4630              MOV      r0,r6
000044  d00a              BEQ      |L2.92|
000046  f7fffffe          BL       TIM_GetCapture1
00004a  69e9              LDR      r1,[r5,#0x1c]  ; time_up
00004c  eb004101          ADD      r1,r0,r1,LSL #16
;;;436    	  if(current_cap_value > last_cap_value)
000050  61a9              STR      r1,[r5,#0x18]  ; current_cap_value
000052  68a8              LDR      r0,[r5,#8]  ; last_cap_value
000054  4281              CMP      r1,r0
000056  d90a              BLS      |L2.110|
;;;437    	  {
;;;438    	   bt_data = current_cap_value - last_cap_value;
000058  1a08              SUBS     r0,r1,r0
00005a  e00a              B        |L2.114|
                  |L2.92|
00005c  f7fffffe          BL       TIM_GetCapture1
000060  69e9              LDR      r1,[r5,#0x1c]         ;431  ; time_up
000062  eb004001          ADD      r0,r0,r1,LSL #16      ;431
000066  60a8              STR      r0,[r5,#8]            ;432  ; last_cap_value
000068  2000              MOVS     r0,#0                 ;432
00006a  60e8              STR      r0,[r5,#0xc]          ;432  ; last_speed
00006c  e7e2              B        |L2.52|
                  |L2.110|
;;;439    	  
;;;440    	  }else{
;;;441    	  	   
;;;442    	   bt_data = ((0xFFFFFFFF  - last_cap_value) + current_cap_value); 
00006e  43c0              MVNS     r0,r0
000070  4408              ADD      r0,r0,r1
                  |L2.114|
;;;443    	   
;;;444    	  }						  
;;;445    	  
;;;446    	  fresh_data();
000072  6128              STR      r0,[r5,#0x10]  ; bt_data
000074  f7fffffe          BL       fresh_data
;;;447    	  //if(judge()<= ONE_STOP)
;;;448    	  {
;;;449    		adjust_pwm_speed();
000078  f7fffffe          BL       adjust_pwm_speed
00007c  e7da              B        |L2.52|
                  |L2.126|
;;;450    	  }
;;;451    	  //judge_result();
;;;452    	}
;;;453    
;;;454    	TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);
;;;455    
;;;456      }else if((TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)&&(TIM_GetITStatus(TIM2, TIM_IT_CC1) != SET))
00007e  2101              MOVS     r1,#1
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       TIM_GetITStatus
000086  2801              CMP      r0,#1
000088  d10e              BNE      |L2.168|
00008a  2102              MOVS     r1,#2
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       TIM_GetITStatus
000092  2801              CMP      r0,#1
000094  d008              BEQ      |L2.168|
;;;457      {
;;;458    	time_up++;
000096  69e8              LDR      r0,[r5,#0x1c]  ; time_up
000098  1c40              ADDS     r0,r0,#1
;;;459    	TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
00009a  2101              MOVS     r1,#1
00009c  61e8              STR      r0,[r5,#0x1c]  ; time_up
                  |L2.158|
;;;460    
;;;461      }else if((TIM_GetITStatus(TIM2, TIM_IT_CC1) == SET)&&(TIM_GetITStatus(TIM2, TIM_IT_Update) == SET))
;;;462      {
;;;463    	 if(current_cap_value > 0xfff0)
;;;464    	 {
;;;465    	 current_cap_value = time_up*0x10000 + TIM_GetCapture1(TIM2);
;;;466    	 }else{
;;;467    	 current_cap_value = (time_up+1)*0x10000 + TIM_GetCapture1(TIM2);
;;;468    	 }
;;;469    	 if(last_cap_value == 0)
;;;470    	{
;;;471    	  last_cap_value = time_up*0x10000+TIM_GetCapture1(TIM2);
;;;472    
;;;473    	}else{
;;;474    	  current_cap_value = time_up*0x10000+ TIM_GetCapture1(TIM2);
;;;475    	  if(current_cap_value > last_cap_value)
;;;476    	  {
;;;477    
;;;478    	   bt_data = current_cap_value - last_cap_value;
;;;479    	  
;;;480    	  }else{
;;;481    	  
;;;482    	   bt_data = ((0xFFFFFFFF - last_cap_value) + current_cap_value); 
;;;483    	   
;;;484    	  }
;;;485    	  fresh_data();
;;;486    	  //if(judge()<= ONE_STOP)
;;;487    	  {
;;;488    		adjust_pwm_speed();
;;;489    	  }
;;;490    	  //judge_result();
;;;491    	} 
;;;492    	TIM_ClearITPendingBit(TIM2, TIM_IT_Update);
;;;493    	TIM_ClearITPendingBit(TIM2, TIM_IT_CC1);  
00009e  4630              MOV      r0,r6
0000a0  e8bd41f0          POP      {r4-r8,lr}
0000a4  f7ffbffe          B.W      TIM_ClearITPendingBit
                  |L2.168|
0000a8  2102              MOVS     r1,#2                 ;461
0000aa  4630              MOV      r0,r6                 ;461
0000ac  f7fffffe          BL       TIM_GetITStatus
0000b0  2801              CMP      r0,#1                 ;461
0000b2  d138              BNE      |L2.294|
0000b4  2101              MOVS     r1,#1                 ;461
0000b6  4630              MOV      r0,r6                 ;461
0000b8  f7fffffe          BL       TIM_GetITStatus
0000bc  2801              CMP      r0,#1                 ;461
0000be  d132              BNE      |L2.294|
0000c0  69a8              LDR      r0,[r5,#0x18]         ;463  ; current_cap_value
0000c2  f64f71f0          MOV      r1,#0xfff0            ;463
0000c6  4288              CMP      r0,r1                 ;463
0000c8  4630              MOV      r0,r6                 ;467
0000ca  d903              BLS      |L2.212|
0000cc  f7fffffe          BL       TIM_GetCapture1
0000d0  69e9              LDR      r1,[r5,#0x1c]         ;465  ; time_up
0000d2  e003              B        |L2.220|
                  |L2.212|
0000d4  f7fffffe          BL       TIM_GetCapture1
0000d8  69e9              LDR      r1,[r5,#0x1c]         ;467  ; time_up
0000da  1c49              ADDS     r1,r1,#1              ;467
                  |L2.220|
0000dc  eb004001          ADD      r0,r0,r1,LSL #16      ;467
0000e0  61a8              STR      r0,[r5,#0x18]         ;469  ; current_cap_value
0000e2  68a8              LDR      r0,[r5,#8]            ;469  ; last_cap_value
0000e4  2800              CMP      r0,#0                 ;469
0000e6  4630              MOV      r0,r6                 ;474
0000e8  d00a              BEQ      |L2.256|
0000ea  f7fffffe          BL       TIM_GetCapture1
0000ee  69e9              LDR      r1,[r5,#0x1c]         ;474  ; time_up
0000f0  eb004101          ADD      r1,r0,r1,LSL #16      ;474
0000f4  61a9              STR      r1,[r5,#0x18]         ;475  ; current_cap_value
0000f6  68a8              LDR      r0,[r5,#8]            ;475  ; last_cap_value
0000f8  4281              CMP      r1,r0                 ;475
0000fa  d908              BLS      |L2.270|
0000fc  1a08              SUBS     r0,r1,r0              ;478
0000fe  e008              B        |L2.274|
                  |L2.256|
000100  f7fffffe          BL       TIM_GetCapture1
000104  69e9              LDR      r1,[r5,#0x1c]         ;471  ; time_up
000106  eb004001          ADD      r0,r0,r1,LSL #16      ;471
00010a  60a8              STR      r0,[r5,#8]            ;471  ; last_cap_value
00010c  e006              B        |L2.284|
                  |L2.270|
00010e  43c0              MVNS     r0,r0                 ;482
000110  4408              ADD      r0,r0,r1              ;482
                  |L2.274|
000112  6128              STR      r0,[r5,#0x10]         ;485  ; bt_data
000114  f7fffffe          BL       fresh_data
000118  f7fffffe          BL       adjust_pwm_speed
                  |L2.284|
00011c  2101              MOVS     r1,#1                 ;492
00011e  4630              MOV      r0,r6                 ;492
000120  f7fffffe          BL       TIM_ClearITPendingBit
000124  e786              B        |L2.52|
                  |L2.294|
;;;494      }
;;;495     #endif
;;;496    }
000126  e8bd81f0          POP      {r4-r8,pc}
;;;497    
                          ENDP

00012a  0000              DCW      0x0000
                  |L2.300|
                          DCD      ||.data||
                  |L2.304|
                          DCD      0x40010800

                          AREA ||i.TIM5_Interrupt||, CODE, READONLY, ALIGN=2

                  TIM5_Interrupt PROC
;;;938    
;;;939    void TIM5_Interrupt(void)
000000  480d              LDR      r0,|L3.56|
;;;940    {
000002  b510              PUSH     {r4,lr}
;;;941    	float speed;
;;;942    	if(enable_sin)
000004  7801              LDRB     r1,[r0,#0]  ; enable_sin
000006  b181              CBZ      r1,|L3.42|
;;;943    	{
;;;944    	speed = ttpars.start_speed+sin_buf[mot_t_cal.counter&(mot_t_cal.div_times -1)];
000008  4c0c              LDR      r4,|L3.60|
00000a  6a40              LDR      r0,[r0,#0x24]  ; sin_buf
00000c  e9d42107          LDRD     r2,r1,[r4,#0x1c]
000010  1e52              SUBS     r2,r2,#1
000012  4011              ANDS     r1,r1,r2
000014  f8501021          LDR      r1,[r0,r1,LSL #2]
000018  4809              LDR      r0,|L3.64|
00001a  6940              LDR      r0,[r0,#0x14]  ; ttpars
00001c  f7fffffe          BL       __aeabi_fadd
;;;945    	set_speed(speed);
000020  f7fffffe          BL       set_speed
;;;946    	mot_t_cal.counter++;
000024  6a20              LDR      r0,[r4,#0x20]  ; mot_t_cal
000026  1c40              ADDS     r0,r0,#1
000028  6220              STR      r0,[r4,#0x20]  ; mot_t_cal
                  |L3.42|
;;;947    	}
;;;948    
;;;949    #ifndef WIN_SIM
;;;950    	TIM_ClearITPendingBit(TIM5, TIM_IT_Update);
00002a  e8bd4010          POP      {r4,lr}
00002e  2101              MOVS     r1,#1
000030  4804              LDR      r0,|L3.68|
000032  f7ffbffe          B.W      TIM_ClearITPendingBit
;;;951    #endif
;;;952    	
;;;953    #if 0
;;;954    	 if(etest_mode == TEST_MODE_COM){
;;;955    
;;;956    	 	if(get_data.time_us >= (ttpars.t0)*1000)
;;;957    		{
;;;958    			u0 = get_data.speed;
;;;959    			if(record.test_times == 0)
;;;960    			{
;;;961    			if(u0<ttpars.V1)
;;;962    				speed = u0+ dt*ttpars.a1;
;;;963    			else if(u0>ttpars.V1)
;;;964    				speed = u0+ dt*ttpars.a2;
;;;965    				
;;;966    			}else{
;;;967    			if(u0<ttpars.V1)
;;;968    				speed = u0+ dt*ttpars.a1;
;;;969    			else if((u0>ttpars.V1) &&(u0<ttpars.V2))
;;;970    				speed = u0+ dt*ttpars.a2;
;;;971    			else 
;;;972    				speed = u0+ dt*ttpars.a3;
;;;973    			motor_speed(speed);
;;;974    			}
;;;975    #endif
;;;976    
;;;977    }
;;;978    
                          ENDP

000036  0000              DCW      0x0000
                  |L3.56|
                          DCD      ||.data||
                  |L3.60|
                          DCD      ||.bss||+0x80c
                  |L3.64|
                          DCD      ttpars
                  |L3.68|
                          DCD      0x40000c00

                          AREA ||i.TIM7_Interrupt||, CODE, READONLY, ALIGN=2

                  TIM7_Interrupt PROC
;;;498    
;;;499    void TIM7_Interrupt(void)
000000  b510              PUSH     {r4,lr}
;;;500    {
;;;501    	
;;;502    	TIM_ClearITPendingBit(TIM7, TIM_IT_Update);
000002  2101              MOVS     r1,#1
000004  4809              LDR      r0,|L4.44|
000006  f7fffffe          BL       TIM_ClearITPendingBit
;;;503    
;;;504    	if(get_data.sw1_speed > tspeed_buf.speed_buf[tspeed_buf.in_loc&(BUF_SIZE-1)])
00000a  4809              LDR      r0,|L4.48|
00000c  6801              LDR      r1,[r0,#0]  ; tspeed_buf
00000e  f3c10108          UBFX     r1,r1,#0,#9
000012  eb000081          ADD      r0,r0,r1,LSL #2
000016  68c1              LDR      r1,[r0,#0xc]
000018  4806              LDR      r0,|L4.52|
00001a  6940              LDR      r0,[r0,#0x14]  ; get_data
00001c  f7fffffe          BL       __aeabi_cfrcmple
000020  d203              BCS      |L4.42|
;;;505    	{
;;;506    
;;;507    	one_stop();
000022  e8bd4010          POP      {r4,lr}
000026  f7ffbffe          B.W      one_stop
                  |L4.42|
;;;508    
;;;509    	}else{
;;;510    	
;;;511    	}
;;;512    	
;;;513    #if 0	
;;;514    	if(( CURRENT(ADCConvertedValue)!=0)&&(last_speed == get_data.speed)&&(get_data.speed!=0))
;;;515    	{
;;;516    	#if 0
;;;517    		motor_dir(0);
;;;518    		record_result(HAND_OFF);	
;;;519    	#endif
;;;520    	}
;;;521    #endif
;;;522    
;;;523    }
00002a  bd10              POP      {r4,pc}
;;;524    #endif
                          ENDP

                  |L4.44|
                          DCD      0x40001400
                  |L4.48|
                          DCD      ||.bss||
                  |L4.52|
                          DCD      get_data

                          AREA ||i.adjust_pwm_speed||, CODE, READONLY, ALIGN=2

                  adjust_pwm_speed PROC
;;;577    
;;;578    void adjust_pwm_speed()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;579    {
;;;580    	float u1,racc,u0,speed;
;;;581    
;;;582     if(current_interface == PORTABLE_LIMIT_SPEED_T)
000004  4847              LDR      r0,|L5.292|
;;;583     {
;;;584     	 if(etest_mode == TEST_MODE_T)// 跳变测试
;;;585    	 {
;;;586    	 	if((get_data.time_us >= (ttpars.t0+ttpars.t1)*1000)&&(get_data.time_us < (ttpars.t0+ttpars.t1+ttpars.t2)*1000))
000006  4f49              LDR      r7,|L5.300|
;;;587    		{
;;;588    			motor_speed(ttpars.start_speed+ttpars.dV);
;;;589    		}else{
;;;590    			motor_speed(ttpars.start_speed);
;;;591    		}
;;;592    	 }else if(etest_mode == TEST_MODE_COM){
;;;593    	 	if(get_data.time_us >= (ttpars.t0)*1000)
;;;594    		{
;;;595    			u0 = get_data.speed;
;;;596    			if(record.test_times == 0)
000008  6801              LDR      r1,[r0,#0]  ; current_interface
00000a  4847              LDR      r0,|L5.296|
00000c  693c              LDR      r4,[r7,#0x10]         ;582
00000e  296a              CMP      r1,#0x6a              ;582
000010  7803              LDRB     r3,[r0,#0]
000012  d009              BEQ      |L5.40|
;;;597    			{
;;;598    			if(u0<ttpars.V1)
;;;599    				speed = u0+ get_data.bt_time_s*ttpars.a1;
;;;600    			else if(u0>ttpars.V1)
;;;601    				speed = u0+ get_data.bt_time_s*ttpars.a2;
;;;602    				
;;;603    			}else{
;;;604    			if(u0<ttpars.V1)
;;;605    				speed = u0+ get_data.bt_time_s*ttpars.a1;
;;;606    			else if((u0>ttpars.V1) &&(u0<ttpars.V2))
;;;607    				speed = u0+ get_data.bt_time_s*ttpars.a2;
;;;608    			else 
;;;609    				speed = u0+ get_data.bt_time_s*ttpars.a3;
;;;610    
;;;611    			motor_speed(speed);
;;;612    			}
;;;613    		}else{
;;;614    			motor_speed(ttpars.start_speed);
;;;615    		}
;;;616    	 }else if(etest_mode == TEST_MODE_SIN){
;;;617    	 			
;;;618    			
;;;619    	 }
;;;620     }else{
;;;621    		u0 = get_data.speed;
000014  4626              MOV      r6,r4
;;;622    		if(record.test_times == 0)
;;;623    		{
;;;624    			if(u0<pars.v1)
000016  4c46              LDR      r4,|L5.304|
;;;625    				racc =pars.ak1;
;;;626    			else if(u0 > pars.v1)
;;;627    				racc = pars.ak2;
;;;628    			
;;;629    		}else if(record.test_times > 0)
;;;630    			{
;;;631    			if(u0<pars.v1)
000018  4630              MOV      r0,r6
00001a  6921              LDR      r1,[r4,#0x10]         ;622
00001c  b3bb              CBZ      r3,|L5.142|
00001e  f7fffffe          BL       __aeabi_cfcmple
000022  d25c              BCS      |L5.222|
                  |L5.36|
;;;632    				racc =pars.ak1;
000024  69a5              LDR      r5,[r4,#0x18]  ; pars
000026  e06c              B        |L5.258|
                  |L5.40|
000028  4842              LDR      r0,|L5.308|
00002a  4d43              LDR      r5,|L5.312|
00002c  7806              LDRB     r6,[r0,#0]            ;584  ; etest_mode
00002e  483f              LDR      r0,|L5.300|
000030  69a9              LDR      r1,[r5,#0x18]         ;586
000032  696a              LDR      r2,[r5,#0x14]         ;584
000034  6a00              LDR      r0,[r0,#0x20]         ;586
000036  2e02              CMP      r6,#2                 ;584
000038  d009              BEQ      |L5.78|
00003a  2e01              CMP      r6,#1                 ;592
00003c  d16f              BNE      |L5.286|
00003e  eb010641          ADD      r6,r1,r1,LSL #1       ;593
000042  ebc611c1          RSB      r1,r6,r1,LSL #7       ;593
000046  ebb00fc1          CMP      r0,r1,LSL #3          ;593
00004a  d217              BCS      |L5.124|
00004c  e014              B        |L5.120|
                  |L5.78|
00004e  6b2b              LDR      r3,[r5,#0x30]         ;586  ; ttpars
000050  4419              ADD      r1,r1,r3              ;586
000052  eb010341          ADD      r3,r1,r1,LSL #1       ;586
000056  ebc313c1          RSB      r3,r3,r1,LSL #7       ;586
00005a  ebb00fc3          CMP      r0,r3,LSL #3          ;586
00005e  d30b              BCC      |L5.120|
000060  6b6b              LDR      r3,[r5,#0x34]         ;586  ; ttpars
000062  4419              ADD      r1,r1,r3              ;586
000064  eb010341          ADD      r3,r1,r1,LSL #1       ;586
000068  ebc311c1          RSB      r1,r3,r1,LSL #7       ;586
00006c  ebb00fc1          CMP      r0,r1,LSL #3          ;586
000070  d202              BCS      |L5.120|
000072  4610              MOV      r0,r2                 ;588
000074  6be9              LDR      r1,[r5,#0x3c]         ;588  ; ttpars
000076  e014              B        |L5.162|
                  |L5.120|
000078  4610              MOV      r0,r2                 ;588
00007a  e04a              B        |L5.274|
                  |L5.124|
00007c  482e              LDR      r0,|L5.312|
00007e  69c1              LDR      r1,[r0,#0x1c]         ;604
000080  4620              MOV      r0,r4                 ;604
000082  b12b              CBZ      r3,|L5.144|
000084  f7fffffe          BL       __aeabi_cfcmple
000088  d20e              BCS      |L5.168|
00008a  6a69              LDR      r1,[r5,#0x24]         ;605  ; ttpars
00008c  e019              B        |L5.194|
                  |L5.142|
00008e  e01d              B        |L5.204|
                  |L5.144|
000090  f7fffffe          BL       __aeabi_cfcmple
000094  d343              BCC      |L5.286|
000096  4620              MOV      r0,r4                 ;600
000098  69e9              LDR      r1,[r5,#0x1c]         ;600  ; ttpars
00009a  e8bd41f0          POP      {r4-r8,lr}            ;600
00009e  f7ffbffe          B.W      __aeabi_cfrcmple
                  |L5.162|
0000a2  f7fffffe          BL       __aeabi_fadd
0000a6  e034              B        |L5.274|
                  |L5.168|
0000a8  4620              MOV      r0,r4                 ;606
0000aa  69e9              LDR      r1,[r5,#0x1c]         ;606  ; ttpars
0000ac  f7fffffe          BL       __aeabi_cfrcmple
0000b0  d206              BCS      |L5.192|
0000b2  4620              MOV      r0,r4                 ;606
0000b4  6a29              LDR      r1,[r5,#0x20]         ;606  ; ttpars
0000b6  f7fffffe          BL       __aeabi_cfcmple
0000ba  d201              BCS      |L5.192|
0000bc  6aa9              LDR      r1,[r5,#0x28]         ;607  ; ttpars
0000be  e000              B        |L5.194|
                  |L5.192|
0000c0  6ae9              LDR      r1,[r5,#0x2c]         ;609  ; ttpars
                  |L5.194|
0000c2  6a78              LDR      r0,[r7,#0x24]         ;607  ; get_data
0000c4  f7fffffe          BL       __aeabi_fmul
0000c8  4621              MOV      r1,r4                 ;607
0000ca  e7ea              B        |L5.162|
                  |L5.204|
0000cc  f7fffffe          BL       __aeabi_cfcmple
0000d0  d3a8              BCC      |L5.36|
0000d2  4630              MOV      r0,r6                 ;626
0000d4  6921              LDR      r1,[r4,#0x10]         ;626  ; pars
0000d6  f7fffffe          BL       __aeabi_cfrcmple
0000da  d212              BCS      |L5.258|
0000dc  e009              B        |L5.242|
                  |L5.222|
;;;633    			else if((u0 >pars.v1)&&(u0 < pars.v2))
0000de  4630              MOV      r0,r6
0000e0  6921              LDR      r1,[r4,#0x10]  ; pars
0000e2  f7fffffe          BL       __aeabi_cfrcmple
0000e6  d206              BCS      |L5.246|
0000e8  4630              MOV      r0,r6
0000ea  6961              LDR      r1,[r4,#0x14]  ; pars
0000ec  f7fffffe          BL       __aeabi_cfcmple
0000f0  d201              BCS      |L5.246|
                  |L5.242|
;;;634    				racc = pars.ak2;
0000f2  69e5              LDR      r5,[r4,#0x1c]  ; pars
0000f4  e005              B        |L5.258|
                  |L5.246|
;;;635    			else if(u0 > pars.v2)
0000f6  4630              MOV      r0,r6
0000f8  6961              LDR      r1,[r4,#0x14]  ; pars
0000fa  f7fffffe          BL       __aeabi_cfrcmple
0000fe  d200              BCS      |L5.258|
;;;636    				racc = pars.ak3;
000100  6a25              LDR      r5,[r4,#0x20]  ; pars
                  |L5.258|
;;;637    		}
;;;638    	 pars.pwm_acc = pars.pwm_acc + racc;
000102  68a0              LDR      r0,[r4,#8]  ; pars
000104  4629              MOV      r1,r5
000106  f7fffffe          BL       __aeabi_fadd
;;;639    	 if(pars.pwm_acc > LIMIT_PWM_ACC)
00010a  490c              LDR      r1,|L5.316|
00010c  60a0              STR      r0,[r4,#8]  ; pars
00010e  4288              CMP      r0,r1
000110  dc05              BGT      |L5.286|
                  |L5.274|
;;;640    	 return;
;;;641    	 else
;;;642    	 	motor_speed(pars.pwm_acc);
000112  f7fffffe          BL       __aeabi_f2iz
000116  e8bd41f0          POP      {r4-r8,lr}
00011a  f7ffbffe          B.W      motor_speed
                  |L5.286|
;;;643    	}
;;;644    
;;;645    // Ut(2) - U0*Ut - a*cir = 0	
;;;646    //	u1 = quadratic_equation(1,-u0,-racc*CACU_BASE(pars.R_mm));
;;;647    //	motor_speed(PWM_PER_SPEED(pars.R_mm)*u1);
;;;648    }
00011e  e8bd81f0          POP      {r4-r8,pc}
;;;649    
                          ENDP

000122  0000              DCW      0x0000
                  |L5.292|
                          DCD      current_interface
                  |L5.296|
                          DCD      record
                  |L5.300|
                          DCD      get_data
                  |L5.304|
                          DCD      pars
                  |L5.308|
                          DCD      etest_mode
                  |L5.312|
                          DCD      ttpars
                  |L5.316|
                          DCD      0x447a0000

                          AREA ||i.caculate_pars||, CODE, READONLY, ALIGN=2

                  caculate_pars PROC
;;;904    
;;;905    void caculate_pars(TMot_t_Cal*  mot_t_cal)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;906    {
;;;907    	unsigned int size;
;;;908    
;;;909    	mot_t_cal->R_r = ttpars.R_mm/ttpars.r_mm;
000004  4d1b              LDR      r5,|L6.116|
000006  4604              MOV      r4,r0                 ;906
000008  e9d51002          LDRD     r1,r0,[r5,#8]
00000c  f7fffffe          BL       __aeabi_fdiv
000010  60e0              STR      r0,[r4,#0xc]
000012  e9d50102          LDRD     r0,r1,[r5,#8]
;;;910    
;;;911    	mot_t_cal->r_R  = ttpars.r_mm/ttpars.R_mm;
000016  f7fffffe          BL       __aeabi_fdiv
;;;912    
;;;913    	mot_t_cal->encode_mm_per_plus = 2*3.1415926*ttpars.enc_r/ttpars.enc_n;
00001a  6160              STR      r0,[r4,#0x14]
00001c  6868              LDR      r0,[r5,#4]  ; ttpars
00001e  f7fffffe          BL       __aeabi_f2d
000022  4606              MOV      r6,r0
000024  460f              MOV      r7,r1
000026  6828              LDR      r0,[r5,#0]  ; ttpars
000028  f7fffffe          BL       __aeabi_f2d
00002c  4a12              LDR      r2,|L6.120|
00002e  4b13              LDR      r3,|L6.124|
000030  f7fffffe          BL       __aeabi_dmul
000034  4632              MOV      r2,r6
000036  463b              MOV      r3,r7
000038  f7fffffe          BL       __aeabi_ddiv
00003c  f7fffffe          BL       __aeabi_d2f
;;;914    
;;;915    			//	1000/ttpars.HZ  -- ms				
;;;916    	size = 	1000/(ttpars.HZ*DIV_TIMS_MS);								//		
000040  61a0              STR      r0,[r4,#0x18]
000042  6c28              LDR      r0,[r5,#0x40]  ; ttpars
000044  f7fffffe          BL       __aeabi_f2d
000048  f04f32ff          MOV      r2,#0xffffffff
00004c  f7fffffe          BL       __ARM_scalbn
000050  4602              MOV      r2,r0
000052  460b              MOV      r3,r1
000054  2000              MOVS     r0,#0
000056  490a              LDR      r1,|L6.128|
000058  f7fffffe          BL       __aeabi_ddiv
00005c  f7fffffe          BL       __aeabi_d2uiz
;;;917    	
;;;918    	mot_t_cal->k_sin = ttpars.Vp;
000060  6c69              LDR      r1,[r5,#0x44]  ; ttpars
;;;919    	
;;;920    	mot_t_cal->div_times = size;
;;;921    
;;;922    	sin_buf =  sin_1_4(size);
000062  6261              STR      r1,[r4,#0x24]
000064  61e0              STR      r0,[r4,#0x1c]
000066  f7fffffe          BL       sin_1_4
00006a  4906              LDR      r1,|L6.132|
00006c  6248              STR      r0,[r1,#0x24]  ; sin_buf
;;;923    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;924    
                          ENDP

000072  0000              DCW      0x0000
                  |L6.116|
                          DCD      ttpars
                  |L6.120|
                          DCD      0x4d12d84a
                  |L6.124|
                          DCD      0x401921fb
                  |L6.128|
                          DCD      0x408f4000
                  |L6.132|
                          DCD      ||.data||

                          AREA ||i.err_back||, CODE, READONLY, ALIGN=1

                  err_back PROC
;;;854    
;;;855    void err_back(EWorkState work_state)
000000  b510              PUSH     {r4,lr}
;;;856    {
;;;857    	test_stop();
000002  f7fffffe          BL       test_stop
;;;858    	delect_now_row();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      delect_now_row
;;;859    }
;;;860    
                          ENDP


                          AREA ||i.fresh_data||, CODE, READONLY, ALIGN=2

                  fresh_data PROC
;;;545    
;;;546    void fresh_data(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;547    {
;;;548    #ifndef WIN_SIM
;;;549    float cir; 
;;;550    
;;;551        current_frequence  = ((GET_SYS_CLK_HZ)*100)/(bt_data);
000004  f8dfa0e0          LDR      r10,|L8.232|
000008  4838              LDR      r0,|L8.236|
00000a  4655              MOV      r5,r10
00000c  f8da4010          LDR      r4,[r10,#0x10]  ; bt_data
000010  fbb0f0f4          UDIV     r0,r0,r4
000014  f7fffffe          BL       __aeabi_ui2f
;;;552    	current_frequence  =  current_frequence/100;
000018  4935              LDR      r1,|L8.240|
00001a  f7fffffe          BL       __aeabi_fdiv
00001e  4681              MOV      r9,r0
;;;553       
;;;554    	if(current_interface == PORTABLE_LIMIT_SPEED_T)
000020  6168              STR      r0,[r5,#0x14]  ; current_frequence
000022  4834              LDR      r0,|L8.244|
;;;555    	{
;;;556    	get_data.speed = mot_t_cal.encode_mm_per_plus/(1000*bt_data);
000024  f8df80d0          LDR      r8,|L8.248|
000028  6807              LDR      r7,[r0,#0]  ; current_interface
00002a  4620              MOV      r0,r4
;;;557    	
;;;558    	}else{
;;;559    	cir = (CACU_BASE(pars.R_mm)*GET_SYS_CLK_HZ)/(bt_data); //m/s 转为保留3位小数	
00002c  f7fffffe          BL       __aeabi_ui2d
000030  4606              MOV      r6,r0
000032  460d              MOV      r5,r1
000034  2f6a              CMP      r7,#0x6a              ;554
000036  d049              BEQ      |L8.204|
000038  4830              LDR      r0,|L8.252|
00003a  6840              LDR      r0,[r0,#4]  ; pars
00003c  f7fffffe          BL       __aeabi_f2d
000040  4a2f              LDR      r2,|L8.256|
000042  4b30              LDR      r3,|L8.260|
000044  f7fffffe          BL       __aeabi_dmul
000048  2200              MOVS     r2,#0
00004a  4b2f              LDR      r3,|L8.264|
00004c  f7fffffe          BL       __aeabi_dmul
000050  4632              MOV      r2,r6
000052  462b              MOV      r3,r5
000054  f7fffffe          BL       __aeabi_ddiv
000058  f7fffffe          BL       __aeabi_d2f
;;;560    	get_data.speed = cir/1000;
00005c  492b              LDR      r1,|L8.268|
00005e  f7fffffe          BL       __aeabi_fdiv
000062  f8c80010          STR      r0,[r8,#0x10]  ; get_data
                  |L8.102|
;;;561    	}
;;;562    
;;;563        get_data.frequence = current_frequence;
;;;564    	last_speed = get_data.speed;
000066  f8c89008          STR      r9,[r8,#8]  ; get_data
00006a  f8d87010          LDR      r7,[r8,#0x10]  ; get_data
;;;565    	last_cap_value = current_cap_value;
00006e  f8ca700c          STR      r7,[r10,#0xc]  ; last_speed
000072  f8da1018          LDR      r1,[r10,#0x18]  ; current_cap_value
;;;566    	
;;;567    	get_data.bt_time_s = 0.5*bt_data/1000000;
000076  f8ca1008          STR      r1,[r10,#8]  ; last_cap_value
00007a  4644              MOV      r4,r8                 ;563
00007c  f04f32ff          MOV      r2,#0xffffffff
000080  4630              MOV      r0,r6
000082  4629              MOV      r1,r5
000084  f7fffffe          BL       __ARM_scalbn
000088  4605              MOV      r5,r0
00008a  460e              MOV      r6,r1
00008c  2200              MOVS     r2,#0
00008e  4b20              LDR      r3,|L8.272|
000090  f7fffffe          BL       __aeabi_ddiv
000094  f7fffffe          BL       __aeabi_d2f
;;;568    	get_data.time_us = get_data.time_us + 0.5*bt_data;// 2M - 0.5us
000098  6260              STR      r0,[r4,#0x24]  ; get_data
00009a  6a20              LDR      r0,[r4,#0x20]  ; get_data
00009c  f7fffffe          BL       __aeabi_ui2d
0000a0  462a              MOV      r2,r5
0000a2  4633              MOV      r3,r6
0000a4  f7fffffe          BL       __aeabi_dadd
0000a8  f7fffffe          BL       __aeabi_d2uiz
;;;569    
;;;570    	tspeed_buf.speed_buf[tspeed_buf.in_loc&(BUF_SIZE-1)] = get_data.speed;
0000ac  6220              STR      r0,[r4,#0x20]  ; get_data
0000ae  4819              LDR      r0,|L8.276|
0000b0  6801              LDR      r1,[r0,#0]  ; tspeed_buf
0000b2  f3c10108          UBFX     r1,r1,#0,#9
0000b6  eb000181          ADD      r1,r0,r1,LSL #2
;;;571    	tspeed_buf.in_loc++;
0000ba  60cf              STR      r7,[r1,#0xc]
0000bc  6801              LDR      r1,[r0,#0]  ; tspeed_buf
0000be  1c49              ADDS     r1,r1,#1
;;;572    	tspeed_buf.in_data_size++;
0000c0  6001              STR      r1,[r0,#0]  ; tspeed_buf
0000c2  6881              LDR      r1,[r0,#8]  ; tspeed_buf
0000c4  1c49              ADDS     r1,r1,#1
0000c6  6081              STR      r1,[r0,#8]  ; tspeed_buf
;;;573    
;;;574    #endif
;;;575    }
0000c8  e8bd87f0          POP      {r4-r10,pc}
                  |L8.204|
0000cc  f44f707a          MOV      r0,#0x3e8             ;556
0000d0  4360              MULS     r0,r4,r0              ;556
0000d2  f7fffffe          BL       __aeabi_ui2f
0000d6  4601              MOV      r1,r0                 ;556
0000d8  480f              LDR      r0,|L8.280|
0000da  6980              LDR      r0,[r0,#0x18]         ;556  ; mot_t_cal
0000dc  f7fffffe          BL       __aeabi_fdiv
0000e0  f8c80010          STR      r0,[r8,#0x10]         ;556  ; get_data
0000e4  e7bf              B        |L8.102|
;;;576    
                          ENDP

0000e6  0000              DCW      0x0000
                  |L8.232|
                          DCD      ||.data||
                  |L8.236|
                          DCD      0x0bebc200
                  |L8.240|
                          DCD      0x42c80000
                  |L8.244|
                          DCD      current_interface
                  |L8.248|
                          DCD      get_data
                  |L8.252|
                          DCD      pars
                  |L8.256|
                          DCD      0xf01b866e
                  |L8.260|
                          DCD      0x401921f9
                  |L8.264|
                          DCD      0x413e8480
                  |L8.268|
                          DCD      0x447a0000
                  |L8.272|
                          DCD      0x412e8480
                  |L8.276|
                          DCD      ||.bss||
                  |L8.280|
                          DCD      ||.bss||+0x80c

                          AREA ||i.intit_sw_state||, CODE, READONLY, ALIGN=2

                  intit_sw_state PROC
;;;747    
;;;748    char intit_sw_state()
000000  b570              PUSH     {r4-r6,lr}
;;;749    {
;;;750     	unsigned char sw1_st1,sw2_st2;
;;;751    #ifndef WIN_SIM
;;;752    	 if(record.test_times == 1)
000002  4815              LDR      r0,|L9.88|
;;;753    		{
;;;754    		init_sw1_state = SW1;
000004  4e15              LDR      r6,|L9.92|
000006  4c16              LDR      r4,|L9.96|
000008  7800              LDRB     r0,[r0,#0]            ;752  ; record
;;;755    		init_sw2_state = SW2;
;;;756    		return 1;
;;;757    		}else{
;;;758    		sw1_st1 = SW1;
00000a  f04f0120          MOV      r1,#0x20
00000e  2801              CMP      r0,#1                 ;752
000010  d012              BEQ      |L9.56|
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GPIO_ReadInputDataBit
000018  4605              MOV      r5,r0
;;;759    		sw2_st2 = SW2;
00001a  2140              MOVS     r1,#0x40
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       GPIO_ReadInputDataBit
;;;760    		if((sw1_st1 != init_sw1_state)||(sw2_st2!= init_sw2_state))
000022  78e2              LDRB     r2,[r4,#3]  ; init_sw1_state
;;;761    			{
;;;762    		get_data.e_work_state = SWI_ERR;
000024  490f              LDR      r1,|L9.100|
000026  4295              CMP      r5,r2                 ;760
000028  d102              BNE      |L9.48|
00002a  7922              LDRB     r2,[r4,#4]            ;760  ; init_sw2_state
00002c  4290              CMP      r0,r2                 ;760
00002e  d00e              BEQ      |L9.78|
                  |L9.48|
000030  200a              MOVS     r0,#0xa
000032  7008              STRB     r0,[r1,#0]
;;;763    		
;;;764    		return 0;
000034  2000              MOVS     r0,#0
;;;765    			}else{
;;;766    		get_data.e_work_state = START_TEST;
;;;767    		return 1;
;;;768    			}
;;;769    		}
;;;770    #endif
;;;771    
;;;772    }
000036  bd70              POP      {r4-r6,pc}
                  |L9.56|
000038  4635              MOV      r5,r6                 ;754
00003a  4630              MOV      r0,r6                 ;754
00003c  f7fffffe          BL       GPIO_ReadInputDataBit
000040  70e0              STRB     r0,[r4,#3]            ;754
000042  2140              MOVS     r1,#0x40              ;755
000044  4628              MOV      r0,r5                 ;755
000046  f7fffffe          BL       GPIO_ReadInputDataBit
00004a  7120              STRB     r0,[r4,#4]            ;755
00004c  e001              B        |L9.82|
                  |L9.78|
00004e  2001              MOVS     r0,#1                 ;766
000050  7008              STRB     r0,[r1,#0]            ;766
                  |L9.82|
000052  2001              MOVS     r0,#1                 ;767
000054  bd70              POP      {r4-r6,pc}
;;;773    
                          ENDP

000056  0000              DCW      0x0000
                  |L9.88|
                          DCD      record
                  |L9.92|
                          DCD      0x40011800
                  |L9.96|
                          DCD      ||.data||
                  |L9.100|
                          DCD      get_data

                          AREA ||i.judge_result||, CODE, READONLY, ALIGN=2

                  judge_result PROC
;;;711    
;;;712    void judge_result()
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;713    {
;;;714     unsigned int i;
;;;715     unsigned int col;
;;;716     float pass_limit,pass_max;
;;;717     pass_limit =  PASS_LIMIT(pars.ve);
000004  4830              LDR      r0,|L10.200|
000006  6800              LDR      r0,[r0,#0]  ; pars
000008  f7fffffe          BL       __aeabi_f2d
00000c  4604              MOV      r4,r0
00000e  460d              MOV      r5,r1
000010  f04f3266          MOV      r2,#0x66666666
000014  4b2d              LDR      r3,|L10.204|
000016  f7fffffe          BL       __aeabi_dmul
00001a  4606              MOV      r6,r0
00001c  460f              MOV      r7,r1
00001e  f7fffffe          BL       __aeabi_d2f
000022  4681              MOV      r9,r0
000024  4622              MOV      r2,r4
000026  462b              MOV      r3,r5
;;;718     pass_max =   PASS_MAX(pars.ve);
000028  2000              MOVS     r0,#0
00002a  4929              LDR      r1,|L10.208|
00002c  f7fffffe          BL       __aeabi_ddiv
000030  4632              MOV      r2,r6
000032  463b              MOV      r3,r7
000034  f7fffffe          BL       __aeabi_dadd
000038  f7fffffe          BL       __aeabi_d2f
;;;719    
;;;720     col = GUI_LIGHTRED;
;;;721    
;;;722     if(record.v2[record.test_times]!= 0)
00003c  4d26              LDR      r5,|L10.216|
00003e  4680              MOV      r8,r0                 ;718
000040  f8dfa090          LDR      r10,|L10.212|
000044  7828              LDRB     r0,[r5,#0]  ; record
000046  f04f0600          MOV      r6,#0                 ;718
00004a  eb050080          ADD      r0,r5,r0,LSL #2
;;;723     {
;;;724     	if(record.v1[record.test_times] >= pass_limit && record.v1[record.test_times] <= pass_max||
;;;725     	record.v2[record.test_times] >= pass_limit && record.v2[record.test_times] <= pass_max)
;;;726     	{
;;;727    	record.result[record.test_times] = 1;
00004e  f04f0701          MOV      r7,#1
000052  f8d010cc          LDR      r1,[r0,#0xcc]         ;722
000056  6ac0              LDR      r0,[r0,#0x2c]         ;724
000058  f0114fff          TST      r1,#0x7f800000        ;722
00005c  f50574b6          ADD      r4,r5,#0x16c          ;722
;;;728        }else{
;;;729    	record.result[record.test_times] = 0;
;;;730    	
;;;731    	list_view_color(0, 0,col); 
;;;732        }
;;;733    
;;;734     }else{
;;;735    
;;;736     	if(record.v1[record.test_times] >= pass_limit && record.v1[record.test_times] <= pass_max)
000060  4649              MOV      r1,r9
000062  d01d              BEQ      |L10.160|
000064  f7fffffe          BL       __aeabi_cfrcmple
000068  d807              BHI      |L10.122|
00006a  7828              LDRB     r0,[r5,#0]            ;724  ; record
00006c  4641              MOV      r1,r8                 ;724
00006e  eb050080          ADD      r0,r5,r0,LSL #2       ;724
000072  6ac0              LDR      r0,[r0,#0x2c]         ;724
000074  f7fffffe          BL       __aeabi_cfcmple
000078  d90e              BLS      |L10.152|
                  |L10.122|
00007a  7828              LDRB     r0,[r5,#0]            ;725  ; record
00007c  4649              MOV      r1,r9                 ;725
00007e  eb050080          ADD      r0,r5,r0,LSL #2       ;725
000082  f8d000cc          LDR      r0,[r0,#0xcc]         ;725
000086  f7fffffe          BL       __aeabi_cfrcmple
00008a  d814              BHI      |L10.182|
00008c  7828              LDRB     r0,[r5,#0]            ;725  ; record
00008e  eb050080          ADD      r0,r5,r0,LSL #2       ;725
000092  f8d000cc          LDR      r0,[r0,#0xcc]         ;725
000096  e00a              B        |L10.174|
                  |L10.152|
000098  7828              LDRB     r0,[r5,#0]            ;727  ; record
00009a  5507              STRB     r7,[r0,r4]            ;727
;;;737     	{
;;;738    	record.result[record.test_times] = 1;
;;;739        }else{
;;;740    	record.result[record.test_times] = 0;
;;;741    	list_view_color(0, 0,col); 
;;;742        }
;;;743     }
;;;744    }
00009c  e8bd87f0          POP      {r4-r10,pc}
                  |L10.160|
0000a0  f7fffffe          BL       __aeabi_cfrcmple
0000a4  d807              BHI      |L10.182|
0000a6  7828              LDRB     r0,[r5,#0]            ;736  ; record
0000a8  eb050080          ADD      r0,r5,r0,LSL #2       ;736
0000ac  6ac0              LDR      r0,[r0,#0x2c]         ;736
                  |L10.174|
0000ae  4641              MOV      r1,r8                 ;736
0000b0  f7fffffe          BL       __aeabi_cfcmple
0000b4  d9f0              BLS      |L10.152|
                  |L10.182|
0000b6  7828              LDRB     r0,[r5,#0]            ;740  ; record
0000b8  4652              MOV      r2,r10                ;741
0000ba  2100              MOVS     r1,#0                 ;741
0000bc  5506              STRB     r6,[r0,r4]            ;740
0000be  e8bd47f0          POP      {r4-r10,lr}           ;741
0000c2  4608              MOV      r0,r1                 ;741
0000c4  f7ffbffe          B.W      list_view_color
;;;745    
                          ENDP

                  |L10.200|
                          DCD      pars
                  |L10.204|
                          DCD      0x3ff26666
                  |L10.208|
                          DCD      0x3fd00000
                  |L10.212|
                          DCD      0x008080ff
                  |L10.216|
                          DCD      record

                          AREA ||i.mot_t_get_speed_line||, CODE, READONLY, ALIGN=2

                  mot_t_get_speed_line PROC
;;;863    
;;;864    void mot_t_get_speed_line(TMot_t_Cal*  mot_t_cal)
000000  b570              PUSH     {r4-r6,lr}
;;;865    {
000002  4605              MOV      r5,r0
;;;866    	unsigned int start_ma, first_ma, second_ma,size;
;;;867    	float get_speed_x0_ma, get_speed_x1_ma,k;
;;;868    
;;;869    start_test_init();
000004  f7fffffe          BL       start_test_init
;;;870    
;;;871    	for(start_ma=1;start_ma<10;start_ma++)
;;;872    	{
;;;873    #ifndef WIN_SIM
;;;874       	 set_data(start_ma);// 
;;;875    
;;;876    	 OSTimeDlyHMSM(0,0,2,0);
;;;877    #endif
;;;878    	 if(get_data.speed !=0)
000008  4e1a              LDR      r6,|L11.116|
00000a  2401              MOVS     r4,#1                 ;871
                  |L11.12|
00000c  4620              MOV      r0,r4                 ;874
00000e  f7fffffe          BL       __aeabi_ui2f
000012  f7fffffe          BL       set_data
000016  2300              MOVS     r3,#0                 ;876
000018  2202              MOVS     r2,#2                 ;876
00001a  4619              MOV      r1,r3                 ;876
00001c  4618              MOV      r0,r3                 ;876
00001e  f7fffffe          BL       OSTimeDlyHMSM
000022  6930              LDR      r0,[r6,#0x10]  ; get_data
000024  f0104fff          TST      r0,#0x7f800000
000028  d102              BNE      |L11.48|
00002a  1c64              ADDS     r4,r4,#1              ;871
00002c  2c0a              CMP      r4,#0xa               ;871
00002e  d3ed              BCC      |L11.12|
                  |L11.48|
;;;879    	 {
;;;880    	 break;
;;;881    	 }
;;;882    	}
;;;883    	first_ma = start_ma;
;;;884    	get_speed_x0_ma = get_data.speed;
;;;885    
;;;886    	second_ma = first_ma + 2;
;;;887    #ifndef WIN_SIM
;;;888        OSTimeDlyHMSM(0,0,2,0);
000030  2300              MOVS     r3,#0
000032  2202              MOVS     r2,#2
000034  4619              MOV      r1,r3
000036  4618              MOV      r0,r3
000038  6934              LDR      r4,[r6,#0x10]  ; get_data
00003a  f7fffffe          BL       OSTimeDlyHMSM
;;;889    #endif
;;;890    
;;;891    	get_speed_x1_ma = get_data.speed;
;;;892    
;;;893    	mot_t_cal->k = 2000/(get_speed_x1_ma - get_speed_x0_ma);// 2ma 乘以1000 倍  电流/速度
00003e  4621              MOV      r1,r4
000040  6930              LDR      r0,[r6,#0x10]  ; get_data
000042  f7fffffe          BL       __aeabi_fsub
000046  4604              MOV      r4,r0
000048  4601              MOV      r1,r0
00004a  480b              LDR      r0,|L11.120|
00004c  f7fffffe          BL       __aeabi_fdiv
000050  4606              MOV      r6,r0
;;;894    
;;;895    	mot_t_cal->cal_flag = 1;
000052  60a8              STR      r0,[r5,#8]
000054  2001              MOVS     r0,#1
000056  7028              STRB     r0,[r5,#0]
;;;896    
;;;897    	mot_t_cal->max_speed_m_per_s = (get_speed_x1_ma - get_speed_x0_ma)*10;// 20ma 对应的速度
000058  4908              LDR      r1,|L11.124|
00005a  4620              MOV      r0,r4
00005c  f7fffffe          BL       __aeabi_fmul
;;;898    	
;;;899    	
;;;900    	mot_t_cal->k_R_r =  mot_t_cal->k*mot_t_cal->R_r;
000060  6068              STR      r0,[r5,#4]
000062  4630              MOV      r0,r6
000064  68e9              LDR      r1,[r5,#0xc]
000066  f7fffffe          BL       __aeabi_fmul
;;;901    
;;;902    	test_stop();
00006a  6128              STR      r0,[r5,#0x10]
00006c  e8bd4070          POP      {r4-r6,lr}
000070  f7ffbffe          B.W      test_stop
;;;903    }
;;;904    
                          ENDP

                  |L11.116|
                          DCD      get_data
                  |L11.120|
                          DCD      0x44fa0000
                  |L11.124|
                          DCD      0x41200000

                          AREA ||i.motor_dir||, CODE, READONLY, ALIGN=2

                  motor_dir PROC
;;;363    // 2 - rc
;;;364    void motor_dir(int dir)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
;;;366    #ifndef WIN_SIM
;;;367    
;;;368    	if(dir == 0)
;;;369    	{
;;;370    	 GPIO_ResetBits(GPIOE, GPIO_Pin_0);
000002  4a15              LDR      r2,|L12.88|
;;;371    	 GPIO_ResetBits(GPIOA, GPIO_Pin_15);
000004  4d15              LDR      r5,|L12.92|
000006  f44f4400          MOV      r4,#0x8000
00000a  b168              CBZ      r0,|L12.40|
;;;372    	 motor_speed(0);
;;;373    	}else if(dir == 1){
00000c  2801              CMP      r0,#1
00000e  d018              BEQ      |L12.66|
;;;374    	 GPIO_SetBits(GPIOE, GPIO_Pin_0);
;;;375    	 GPIO_ResetBits(GPIOA, GPIO_Pin_15);	
;;;376    	}else if(dir == 2){
000010  2802              CMP      r0,#2
000012  d120              BNE      |L12.86|
;;;377    	 GPIO_ResetBits(GPIOE, GPIO_Pin_0);
000014  2101              MOVS     r1,#1
000016  4610              MOV      r0,r2
000018  f7fffffe          BL       GPIO_ResetBits
;;;378    	 GPIO_SetBits(GPIOA, GPIO_Pin_15);	
00001c  4621              MOV      r1,r4
00001e  4628              MOV      r0,r5
000020  e8bd4070          POP      {r4-r6,lr}
000024  f7ffbffe          B.W      GPIO_SetBits
                  |L12.40|
000028  2101              MOVS     r1,#1                 ;370
00002a  4610              MOV      r0,r2                 ;370
00002c  f7fffffe          BL       GPIO_ResetBits
000030  4621              MOV      r1,r4                 ;371
000032  4628              MOV      r0,r5                 ;371
000034  f7fffffe          BL       GPIO_ResetBits
000038  e8bd4070          POP      {r4-r6,lr}            ;372
00003c  2000              MOVS     r0,#0                 ;372
00003e  f7ffbffe          B.W      motor_speed
                  |L12.66|
000042  2101              MOVS     r1,#1                 ;374
000044  4610              MOV      r0,r2                 ;374
000046  f7fffffe          BL       GPIO_SetBits
00004a  4621              MOV      r1,r4                 ;375
00004c  4628              MOV      r0,r5                 ;375
00004e  e8bd4070          POP      {r4-r6,lr}            ;375
000052  f7ffbffe          B.W      GPIO_ResetBits
                  |L12.86|
;;;379    	}
;;;380    #endif
;;;381    }
000056  bd70              POP      {r4-r6,pc}
;;;382    
                          ENDP

                  |L12.88|
                          DCD      0x40011800
                  |L12.92|
                          DCD      0x40010800

                          AREA ||i.motor_int||, CODE, READONLY, ALIGN=2

                  motor_int PROC
;;;132    
;;;133    void motor_int(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;134    {
;;;135    #ifndef WIN_SIM
;;;136    
;;;137        NVIC_InitTypeDef NVIC_InitStructure;
;;;138    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;139      	TIM_OCInitTypeDef  TIM_OCInitStructure;	
;;;140        ADC_InitTypeDef ADC_InitStructure;
;;;141    	GPIO_InitTypeDef GPIO_InitStructure;
;;;142    	TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;143    	EXTI_InitTypeDef  EXTI_InitStructure;
;;;144    
;;;145    	DMA_InitTypeDef DMA_InitStructure;
;;;146    	
;;;147    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);//配置ADC时钟= PCLK2/4
000004  f44f4400          MOV      r4,#0x8000
000008  b08c              SUB      sp,sp,#0x30           ;134
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       RCC_ADCCLKConfig
;;;148    	RCC_APB1PeriphClockCmd( RCC_APB1Periph_TIM3|RCC_APB1Periph_TIM2|RCC_APB1Periph_TIM4|RCC_APB1Periph_TIM5|RCC_APB1Periph_TIM7,ENABLE);
000010  2101              MOVS     r1,#1
000012  202f              MOVS     r0,#0x2f
000014  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;149    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000018  2101              MOVS     r1,#1
00001a  4608              MOV      r0,r1
00001c  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;150    	RCC_APB2PeriphClockCmd( RCC_APB2Periph_ADC1|RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOE|RCC_APB2Periph_GPIOD|RCC_APB2Periph_GPIOC| RCC_APB2Periph_AFIO,ENABLE);
000020  2101              MOVS     r1,#1
000022  f2402075          MOV      r0,#0x275
000026  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;151    	 /* GPIOA and GPIOB clock enable */
;;;152    	RCC_ADCCLKConfig(RCC_PCLK2_Div6);     
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       RCC_ADCCLKConfig
;;;153    
;;;154    	GPIO_PinRemapConfig(GPIO_FullRemap_TIM3, ENABLE);
000030  2101              MOVS     r1,#1
000032  4891              LDR      r0,|L13.632|
000034  f7fffffe          BL       GPIO_PinRemapConfig
;;;155    
;;;156    	GPIO_PinRemapConfig(GPIO_Remap_TIM4, ENABLE);
000038  2101              MOVS     r1,#1
00003a  030d              LSLS     r5,r1,#12
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       GPIO_PinRemapConfig
;;;157    	
;;;158    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;		 //
000042  f8ad500c          STRH     r5,[sp,#0xc]
;;;159      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000046  2602              MOVS     r6,#2
000048  f88d600e          STRB     r6,[sp,#0xe]
;;;160      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; 	 
00004c  2018              MOVS     r0,#0x18
00004e  f88d000f          STRB     r0,[sp,#0xf]
;;;161      	GPIO_Init(GPIOD, &GPIO_InitStructure);	 
000052  a903              ADD      r1,sp,#0xc
000054  4889              LDR      r0,|L13.636|
000056  f7fffffe          BL       GPIO_Init
;;;162    	
;;;163    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15;		 //SW3_IN SW1_IN SW2_IN
00005a  f8ad400c          STRH     r4,[sp,#0xc]
;;;164      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;165      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 	 
;;;166      	GPIO_Init(GPIOA, &GPIO_InitStructure);
00005e  4c88              LDR      r4,|L13.640|
000060  f88d600e          STRB     r6,[sp,#0xe]          ;164
000064  f04f0810          MOV      r8,#0x10              ;165
000068  f88d800f          STRB     r8,[sp,#0xf]          ;165
00006c  a903              ADD      r1,sp,#0xc
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       GPIO_Init
;;;167    
;;;168    //  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;		 //TIM3_CH1
;;;169    //  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
;;;170    //  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
;;;171    //  GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;172    
;;;173    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		 //TIM2_CH1
000074  2501              MOVS     r5,#1
000076  f8ad500c          STRH     r5,[sp,#0xc]
;;;174        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
00007a  f88d600e          STRB     r6,[sp,#0xe]
;;;175        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
00007e  2704              MOVS     r7,#4
000080  f88d700f          STRB     r7,[sp,#0xf]
;;;176        GPIO_Init(GPIOA, &GPIO_InitStructure);
000084  a903              ADD      r1,sp,#0xc
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       GPIO_Init
;;;177    
;;;178    //    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;		 //
;;;179    //  	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;180    //  	GPIO_InitStructure.GPIO_Mode =  GPIO_Mode_AF_PP;	 
;;;181    //  	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;182    	
;;;183    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		 //ADC_IN0_MOTO
00008c  f8ad500c          STRH     r5,[sp,#0xc]
;;;184      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000090  f88d600e          STRB     r6,[sp,#0xe]
;;;185      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;	 
000094  2400              MOVS     r4,#0
000096  f88d400f          STRB     r4,[sp,#0xf]
;;;186      	GPIO_Init(GPIOC, &GPIO_InitStructure);		
00009a  a903              ADD      r1,sp,#0xc
00009c  4879              LDR      r0,|L13.644|
00009e  f7fffffe          BL       GPIO_Init
;;;187    		
;;;188    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5 |GPIO_Pin_6;		 //SW3_IN SW1_IN SW2_IN
0000a2  2070              MOVS     r0,#0x70
0000a4  f8ad000c          STRH     r0,[sp,#0xc]
;;;189      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000a8  f04f0a03          MOV      r10,#3
;;;190      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
;;;191      	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000ac  f8df91d8          LDR      r9,|L13.648|
0000b0  f88da00e          STRB     r10,[sp,#0xe]         ;189
0000b4  f88d700f          STRB     r7,[sp,#0xf]          ;190
0000b8  a903              ADD      r1,sp,#0xc
0000ba  4648              MOV      r0,r9
0000bc  f7fffffe          BL       GPIO_Init
;;;192    
;;;193    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;		 
0000c0  f8ad500c          STRH     r5,[sp,#0xc]
;;;194      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
0000c4  f88d600e          STRB     r6,[sp,#0xe]
;;;195      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 	 
0000c8  f88d800f          STRB     r8,[sp,#0xf]
;;;196      	GPIO_Init(GPIOE, &GPIO_InitStructure);
0000cc  a903              ADD      r1,sp,#0xc
0000ce  4648              MOV      r0,r9
0000d0  f7fffffe          BL       GPIO_Init
;;;197    
;;;198    	GPIO_EXTILineConfig(GPIO_PortSourceGPIOE,GPIO_PinSource5|GPIO_PinSource6);// 修改
0000d4  2107              MOVS     r1,#7
0000d6  2004              MOVS     r0,#4
0000d8  f7fffffe          BL       GPIO_EXTILineConfig
;;;199      	EXTI_InitStructure_A.EXTI_Line = EXTI_Line5|EXTI_Line6; 
0000dc  486b              LDR      r0,|L13.652|
0000de  f04f0960          MOV      r9,#0x60
;;;200      	EXTI_InitStructure_A.EXTI_Mode = EXTI_Mode_Interrupt;
0000e2  f8c09000          STR      r9,[r0,#0]  ; EXTI_InitStructure_A
0000e6  7104              STRB     r4,[r0,#4]
;;;201      	EXTI_InitStructure_A.EXTI_Trigger = EXTI_Trigger_Rising_Falling;
0000e8  f8808005          STRB     r8,[r0,#5]
;;;202      	EXTI_InitStructure_A.EXTI_LineCmd = DISABLE;
0000ec  7184              STRB     r4,[r0,#6]
;;;203      	EXTI_Init(&EXTI_InitStructure_A);
0000ee  f7fffffe          BL       EXTI_Init
;;;204    
;;;205    // PWM set
;;;206    //  	
;;;207    //	TIM_TimeBaseStructure.TIM_Period = 9999;//1999 72k,3999 36k, 5999 18k, 7999 9K	9999 4.5K 11999 2.25k	   
;;;208    //  TIM_TimeBaseStructure.TIM_Prescaler = 14238;//1M
;;;209    	
;;;210    	TIM_TimeBaseStructure.TIM_Period = 7999;//1999 72k,3999 36k, 5999 18k, 7999 9K	9999 4.5K 11999 2.25k	   
0000f2  f641703f          MOV      r0,#0x1f3f
0000f6  f8ad0004          STRH     r0,[sp,#4]
;;;211        TIM_TimeBaseStructure.TIM_Prescaler = 0;//  		 
;;;212        TIM_TimeBaseStructure.TIM_ClockDivision = 0;	  
;;;213        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;214        TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);               //
0000fa  f8df8194          LDR      r8,|L13.656|
0000fe  f8ad4000          STRH     r4,[sp,#0]            ;211
000102  f8ad4006          STRH     r4,[sp,#6]            ;212
000106  f8ad4002          STRH     r4,[sp,#2]            ;213
00010a  4669              MOV      r1,sp
00010c  4640              MOV      r0,r8
00010e  f7fffffe          BL       TIM_TimeBaseInit
;;;215    	
;;;216      	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;//exp ----
000112  f8ad9014          STRH     r9,[sp,#0x14]
;;;217      	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;
000116  f8ad5016          STRH     r5,[sp,#0x16]
;;;218      	TIM_OCInitStructure.TIM_OutputNState = TIM_OutputNState_Enable;
00011a  f8ad7018          STRH     r7,[sp,#0x18]
;;;219    	TIM_CtrlPWMOutputs(TIM4, ENABLE);
00011e  2101              MOVS     r1,#1
000120  4640              MOV      r0,r8
000122  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;220    
;;;221      	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;
;;;222      	TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCNPolarity_High;
;;;223      	TIM_OCInitStructure.TIM_OCIdleState = TIM_OCIdleState_Set;
000126  0228              LSLS     r0,r5,#8
000128  f8ad0020          STRH     r0,[sp,#0x20]
00012c  f8ad601c          STRH     r6,[sp,#0x1c]         ;221
000130  f8ad401e          STRH     r4,[sp,#0x1e]         ;222
;;;224      	TIM_OCInitStructure.TIM_OCNIdleState = TIM_OCIdleState_Reset;
000134  f8ad4022          STRH     r4,[sp,#0x22]
;;;225    
;;;226    	TIM_OC1Init(TIM4,&TIM_OCInitStructure);  // 修改
000138  a905              ADD      r1,sp,#0x14
00013a  4640              MOV      r0,r8
00013c  f7fffffe          BL       TIM_OC1Init
;;;227      	TIM_Cmd(TIM4, DISABLE);
000140  2100              MOVS     r1,#0
000142  4640              MOV      r0,r8
000144  f7fffffe          BL       TIM_Cmd
;;;228      	
;;;229    //Input capture  没有外部脉冲情况是否也进入中断--- 可以进入中断 因为
;;;230    //要不断的计数
;;;231    	TIM_TimeBaseStructure.TIM_Period = 0xFFFF;//1999 36k,3999 18k, 5999 9k, 7999 4.5K	9999 2.25K	   
000148  f64f70ff          MOV      r0,#0xffff
00014c  f8ad0004          STRH     r0,[sp,#4]
;;;232        TIM_TimeBaseStructure.TIM_Prescaler = TIME_CLK_DIV;//TIMxCLK / (Prescaler +1)		 
000150  2023              MOVS     r0,#0x23
000152  f8ad0000          STRH     r0,[sp,#0]
;;;233        TIM_TimeBaseStructure.TIM_ClockDivision = 0;	  
;;;234        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;235        TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
000156  f04f4880          MOV      r8,#0x40000000
00015a  f8ad4006          STRH     r4,[sp,#6]            ;233
00015e  f8ad4002          STRH     r4,[sp,#2]            ;234
000162  4669              MOV      r1,sp
000164  4640              MOV      r0,r8
000166  f7fffffe          BL       TIM_TimeBaseInit
;;;236    
;;;237        TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;
00016a  f8ad4024          STRH     r4,[sp,#0x24]
;;;238        TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;
;;;239        TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
00016e  f8ad5028          STRH     r5,[sp,#0x28]
000172  f8ad6026          STRH     r6,[sp,#0x26]         ;238
;;;240        TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;
000176  f8ad402a          STRH     r4,[sp,#0x2a]
;;;241        TIM_ICInitStructure.TIM_ICFilter = 0x0;
00017a  f8ad402c          STRH     r4,[sp,#0x2c]
;;;242    
;;;243        TIM_ICInit(TIM2, &TIM_ICInitStructure);
00017e  a909              ADD      r1,sp,#0x24
000180  4640              MOV      r0,r8
000182  f7fffffe          BL       TIM_ICInit
;;;244      	TIM_Cmd(TIM2, ENABLE);
000186  2101              MOVS     r1,#1
000188  4640              MOV      r0,r8
00018a  f7fffffe          BL       TIM_Cmd
;;;245    
;;;246        /* Enable the CC1 Interrupt Request */
;;;247        TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);
00018e  2201              MOVS     r2,#1
000190  2102              MOVS     r1,#2
000192  4640              MOV      r0,r8
000194  f7fffffe          BL       TIM_ITConfig
;;;248    
;;;249    	#ifdef TEST_MODE_1
;;;250        TIM_ITConfig(TIM2, TIM_IT_Update, ENABLE);
000198  2201              MOVS     r2,#1
00019a  4611              MOV      r1,r2
00019c  4640              MOV      r0,r8
00019e  f7fffffe          BL       TIM_ITConfig
;;;251    	#endif 
;;;252    
;;;253    #if 0	
;;;254      	DMA_DeInit(DMA1_Channel1);
;;;255      	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;
;;;256      	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&ADCConvertedValue;
;;;257      	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;
;;;258      	DMA_InitStructure.DMA_BufferSize = 1;
;;;259      	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
;;;260      	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Disable;
;;;261      	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;
;;;262      	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;
;;;263      	DMA_InitStructure.DMA_Mode = DMA_Mode_Circular;
;;;264      	DMA_InitStructure.DMA_Priority = DMA_Priority_High;
;;;265      	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;
;;;266      	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
;;;267    
;;;268      /* Enable DMA1 channel1 */
;;;269      	DMA_Cmd(DMA1_Channel1, ENABLE);
;;;270      
;;;271      /* ADC1 configuration ------------------------------------------------------*/
;;;272      	ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
;;;273      	ADC_InitStructure.ADC_ScanConvMode = ENABLE;
;;;274      	ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;
;;;275      	ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;
;;;276      	ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;
;;;277      	ADC_InitStructure.ADC_NbrOfChannel = 1;
;;;278      	ADC_Init(ADC1, &ADC_InitStructure);
;;;279    
;;;280      /* ADC1 regular channel14 configuration */ 
;;;281        ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_55Cycles5);
;;;282    
;;;283      /* Enable ADC1 DMA */
;;;284        ADC_DMACmd(ADC1, ENABLE);
;;;285      
;;;286      /* Enable ADC1 */
;;;287        ADC_Cmd(ADC1, ENABLE);
;;;288    
;;;289      /* Enable ADC1 reset calibration register */   
;;;290        ADC_ResetCalibration(ADC1);
;;;291      /* Check the end of ADC1 reset calibration register */
;;;292        while(ADC_GetResetCalibrationStatus(ADC1));
;;;293    
;;;294      /* Start ADC1 calibration */
;;;295        ADC_StartCalibration(ADC1);
;;;296      /* Check the end of ADC1 calibration */
;;;297        while(ADC_GetCalibrationStatus(ADC1));
;;;298         
;;;299      /* Start ADC1 Software Conversion */ 
;;;300        ADC_SoftwareStartConvCmd(ADC1, ENABLE);
;;;301    #endif
;;;302    
;;;303    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
0001a2  02a8              LSLS     r0,r5,#10
0001a4  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;304      /* Enable the TIM3 global Interrupt */
;;;305      	NVIC_InitStructure.NVIC_IRQChannel = TIM2_IRQn;
0001a8  201c              MOVS     r0,#0x1c
0001aa  f88d0010          STRB     r0,[sp,#0x10]
;;;306      	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0001ae  f88d4011          STRB     r4,[sp,#0x11]
;;;307      	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;
0001b2  f88da012          STRB     r10,[sp,#0x12]
;;;308      	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0001b6  f88d5013          STRB     r5,[sp,#0x13]
;;;309      	NVIC_Init(&NVIC_InitStructure);
0001ba  a804              ADD      r0,sp,#0x10
0001bc  f7fffffe          BL       NVIC_Init
;;;310    
;;;311      	NVIC_InitStructure.NVIC_IRQChannel = EXTI9_5_IRQn;
0001c0  2017              MOVS     r0,#0x17
0001c2  f88d0010          STRB     r0,[sp,#0x10]
;;;312      	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0001c6  f88d4011          STRB     r4,[sp,#0x11]
;;;313      	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 2;
0001ca  f88d6012          STRB     r6,[sp,#0x12]
;;;314      	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0001ce  f88d5013          STRB     r5,[sp,#0x13]
;;;315      	NVIC_Init(&NVIC_InitStructure);
0001d2  a804              ADD      r0,sp,#0x10
0001d4  f7fffffe          BL       NVIC_Init
;;;316    
;;;317    	NVIC_InitStructure.NVIC_IRQChannel = TIM7_IRQn;
0001d8  2037              MOVS     r0,#0x37
0001da  f88d0010          STRB     r0,[sp,#0x10]
;;;318      	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0001de  f88d4011          STRB     r4,[sp,#0x11]
;;;319      	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 5;
0001e2  2005              MOVS     r0,#5
0001e4  f88d0012          STRB     r0,[sp,#0x12]
;;;320      	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
0001e8  f88d5013          STRB     r5,[sp,#0x13]
;;;321      	NVIC_Init(&NVIC_InitStructure);
0001ec  a804              ADD      r0,sp,#0x10
0001ee  f7fffffe          BL       NVIC_Init
;;;322    
;;;323    	NVIC_InitStructure.NVIC_IRQChannel = TIM5_IRQn;
0001f2  2032              MOVS     r0,#0x32
0001f4  f88d0010          STRB     r0,[sp,#0x10]
;;;324      	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
0001f8  f88d4011          STRB     r4,[sp,#0x11]
;;;325      	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 4;
0001fc  f88d7012          STRB     r7,[sp,#0x12]
;;;326      	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
000200  f88d5013          STRB     r5,[sp,#0x13]
;;;327      	NVIC_Init(&NVIC_InitStructure);
000204  a804              ADD      r0,sp,#0x10
000206  f7fffffe          BL       NVIC_Init
;;;328    	
;;;329      //base timers 
;;;330      //1999 72k,3999 36k, 5999 18k, 7999 9K	9999 4.5K 	
;;;331      //1k - 1ms -  
;;;332        TIM_TimeBaseStructure.TIM_Period = 9999;// 222us 222000us 222.0ms
00020a  f242700f          MOV      r0,#0x270f
00020e  f8ad0004          STRH     r0,[sp,#4]
;;;333        TIM_TimeBaseStructure.TIM_Prescaler = 999;
000212  f24030e7          MOV      r0,#0x3e7
000216  f8ad0000          STRH     r0,[sp,#0]
;;;334        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;335        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;336        TIM_TimeBaseInit(TIM7, &TIM_TimeBaseStructure);
00021a  4d1e              LDR      r5,|L13.660|
00021c  f8ad4006          STRH     r4,[sp,#6]            ;334
000220  f8ad4002          STRH     r4,[sp,#2]            ;335
000224  4669              MOV      r1,sp
000226  4628              MOV      r0,r5
000228  f7fffffe          BL       TIM_TimeBaseInit
;;;337    	TIM_ITConfig(TIM7, TIM_IT_Update, ENABLE);
00022c  2201              MOVS     r2,#1
00022e  4611              MOV      r1,r2
000230  4628              MOV      r0,r5
000232  f7fffffe          BL       TIM_ITConfig
;;;338    	TIM_Cmd(TIM7, DISABLE);
000236  2100              MOVS     r1,#0
000238  4628              MOV      r0,r5
00023a  f7fffffe          BL       TIM_Cmd
;;;339    
;;;340    	//TIM1 counter clock = TIMxCLK / (Prescaler +1) 
;;;341    	//                   = 72M/144 = 500K
;;;342    	//TIMx ARR Register = 10000 => TIMx Frequency = TIMxcounter clock/(9999 + 1)= 500K/10000 = 50HZ 
;;;343    	//2k hz 1M - 1us 1k - 1ms 2k - 0.5ms
;;;344    
;;;345    
;;;346    	// 与 DIV_TIM  DIV_TIMS_MS
;;;347    	// 1k -- 1ms   2k -- 0.5ms
;;;348    	// 
;;;349        TIM_TimeBaseStructure.TIM_Period = 199;// 2K
00023e  20c7              MOVS     r0,#0xc7
000240  f8ad0004          STRH     r0,[sp,#4]
;;;350        TIM_TimeBaseStructure.TIM_Prescaler = 359; //TIMxCLK / (Prescaler +1)  72/360 = 0.2M = 200K
000244  f2401067          MOV      r0,#0x167
000248  f8ad0000          STRH     r0,[sp,#0]
;;;351        TIM_TimeBaseStructure.TIM_ClockDivision = 0;
00024c  f8ad4006          STRH     r4,[sp,#6]
;;;352        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
000250  f8ad4002          STRH     r4,[sp,#2]
;;;353        TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
000254  4c10              LDR      r4,|L13.664|
000256  4669              MOV      r1,sp
000258  4620              MOV      r0,r4
00025a  f7fffffe          BL       TIM_TimeBaseInit
;;;354    	TIM_ITConfig(TIM5, TIM_IT_Update, ENABLE);
00025e  2201              MOVS     r2,#1
000260  4611              MOV      r1,r2
000262  4620              MOV      r0,r4
000264  f7fffffe          BL       TIM_ITConfig
;;;355    	TIM_Cmd(TIM5, DISABLE);
000268  2100              MOVS     r1,#0
00026a  4620              MOV      r0,r4
00026c  f7fffffe          BL       TIM_Cmd
;;;356    
;;;357    #endif		
;;;358    }
000270  b00c              ADD      sp,sp,#0x30
000272  e8bd87f0          POP      {r4-r10,pc}
;;;359    
                          ENDP

000276  0000              DCW      0x0000
                  |L13.632|
                          DCD      0x001a0c00
                  |L13.636|
                          DCD      0x40011400
                  |L13.640|
                          DCD      0x40010800
                  |L13.644|
                          DCD      0x40011000
                  |L13.648|
                          DCD      0x40011800
                  |L13.652|
                          DCD      ||.data||+0x28
                  |L13.656|
                          DCD      0x40000800
                  |L13.660|
                          DCD      0x40001400
                  |L13.664|
                          DCD      0x40000c00

                          AREA ||i.motor_speed||, CODE, READONLY, ALIGN=2

                  motor_speed PROC
;;;386    // 0 -- ?
;;;387    void motor_speed(int pwm_speed)
000000  4240              RSBS     r0,r0,#0
;;;388    {
;;;389    #ifndef WIN_SIM
;;;390    	TIM4->CCR1 = 8000 - pwm_speed*8;
000002  f44f51fa          MOV      r1,#0x1f40
000006  eb0100c0          ADD      r0,r1,r0,LSL #3
00000a  4901              LDR      r1,|L14.16|
00000c  8008              STRH     r0,[r1,#0]
;;;391    #endif
;;;392    
;;;393      //TIM3->CCR2 = 10000 - pwm_speed*100;
;;;394    }
00000e  4770              BX       lr
;;;395    
                          ENDP

                  |L14.16|
                          DCD      0x40000834

                          AREA ||i.one_stop||, CODE, READONLY, ALIGN=2

                  one_stop PROC
;;;677    
;;;678    int one_stop()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;679    {
;;;680    	int max;
;;;681    #ifndef WIN_SIM	
;;;682    	  motor_dir(0);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       motor_dir
;;;683    	  get_data.sw2_speed = get_data.speed;
00000a  4d20              LDR      r5,|L15.140|
;;;684    	  record.e_work_state[record.test_times] = ONE_STOP;
00000c  4c20              LDR      r4,|L15.144|
;;;685    	  get_data.e_work_state = ONE_STOP;
;;;686    	  record.v1[record.test_times]= get_data.sw1_speed;
;;;687    
;;;688    	  if(SW1!=init_sw1_state && SW2!= init_sw2_state)
00000e  4f21              LDR      r7,|L15.148|
000010  6928              LDR      r0,[r5,#0x10]         ;683  ; get_data
000012  61a8              STR      r0,[r5,#0x18]         ;684  ; get_data
000014  7822              LDRB     r2,[r4,#0]            ;684  ; record
000016  1ca1              ADDS     r1,r4,#2              ;684
000018  2003              MOVS     r0,#3                 ;684
00001a  5450              STRB     r0,[r2,r1]            ;684
00001c  7028              STRB     r0,[r5,#0]            ;685
00001e  7821              LDRB     r1,[r4,#0]            ;686  ; record
000020  6968              LDR      r0,[r5,#0x14]         ;686  ; get_data
000022  eb040181          ADD      r1,r4,r1,LSL #2       ;686
000026  62c8              STR      r0,[r1,#0x2c]
000028  2120              MOVS     r1,#0x20
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  4e19              LDR      r6,|L15.152|
000032  78f1              LDRB     r1,[r6,#3]  ; init_sw1_state
000034  4288              CMP      r0,r1
000036  d00d              BEQ      |L15.84|
000038  2140              MOVS     r1,#0x40
00003a  4638              MOV      r0,r7
00003c  f7fffffe          BL       GPIO_ReadInputDataBit
000040  7931              LDRB     r1,[r6,#4]  ; init_sw2_state
000042  4288              CMP      r0,r1
000044  d006              BEQ      |L15.84|
;;;689    	  	{
;;;690    	  record.v2[record.test_times]= get_data.sw2_speed;
000046  7821              LDRB     r1,[r4,#0]  ; record
000048  69a8              LDR      r0,[r5,#0x18]  ; get_data
00004a  eb040181          ADD      r1,r4,r1,LSL #2
00004e  f8c100cc          STR      r0,[r1,#0xcc]
000052  e006              B        |L15.98|
                  |L15.84|
;;;691    	  	}else {
;;;692    	  record.v2[record.test_times]= 0;
000054  7821              LDRB     r1,[r4,#0]  ; record
000056  2000              MOVS     r0,#0
000058  eb040181          ADD      r1,r4,r1,LSL #2
;;;693    	  get_data.speed = 0;
00005c  f8c100cc          STR      r0,[r1,#0xcc]
000060  6128              STR      r0,[r5,#0x10]  ; get_data
                  |L15.98|
;;;694    		}
;;;695    
;;;696    	  record.dir[record.test_times]= pars.dir;
000062  480e              LDR      r0,|L15.156|
000064  7822              LDRB     r2,[r4,#0]  ; record
000066  f8901038          LDRB     r1,[r0,#0x38]  ; pars
00006a  480d              LDR      r0,|L15.160|
00006c  5411              STRB     r1,[r2,r0]
;;;697    	  test_stop();
00006e  f7fffffe          BL       test_stop
;;;698    	  judge_result();
000072  f7fffffe          BL       judge_result
;;;699    
;;;700    
;;;701    	if(current_interface == PORTABLE_LIMIT_SPEED_T)
000076  480b              LDR      r0,|L15.164|
;;;702       {
;;;703    	max = GUI_ID_BUTTON_TMAIN;
000078  f640010a          MOV      r1,#0x80a
00007c  6800              LDR      r0,[r0,#0]            ;701  ; current_interface
;;;704       }else{
;;;705        max = GUI_ID_BUTTON_DELET;
;;;706       }
;;;707    	all_button(1,max);
00007e  2001              MOVS     r0,#1
000080  f7fffffe          BL       all_button
;;;708    #endif
;;;709    	  return ONE_STOP;
000084  2003              MOVS     r0,#3
;;;710    }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;711    
                          ENDP

00008a  0000              DCW      0x0000
                  |L15.140|
                          DCD      get_data
                  |L15.144|
                          DCD      record
                  |L15.148|
                          DCD      0x40011800
                  |L15.152|
                          DCD      ||.data||
                  |L15.156|
                          DCD      pars
                  |L15.160|
                          DCD      record+0x194
                  |L15.164|
                          DCD      current_interface

                          AREA ||i.set_speed||, CODE, READONLY, ALIGN=2

                  set_speed PROC
;;;527    //启动时给个初速度，启动无负载默认 PWM 脉宽和速度成正比
;;;528    void set_speed(float speed)
000000  490a              LDR      r1,|L16.44|
;;;529    {
000002  b510              PUSH     {r4,lr}
;;;530      float  set_current;
;;;531       //motor_speed(speed*PWM_PER_SPEED(pars.R_mm));
;;;532      if(current_interface == PORTABLE_LIMIT_SPEED_T)
000004  6809              LDR      r1,[r1,#0]  ; current_interface
000006  296a              CMP      r1,#0x6a
000008  d005              BEQ      |L16.22|
;;;533      {
;;;534       set_current = speed*mot_t_cal.k_R_r/1000;
;;;535    #ifndef WIN_SIM
;;;536       set_data(set_current);
;;;537    #endif
;;;538      }else{
;;;539    
;;;540       motor_speed(speed);
00000a  f7fffffe          BL       __aeabi_f2iz
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      motor_speed
                  |L16.22|
000016  4906              LDR      r1,|L16.48|
000018  6909              LDR      r1,[r1,#0x10]         ;534  ; mot_t_cal
00001a  f7fffffe          BL       __aeabi_fmul
00001e  4905              LDR      r1,|L16.52|
000020  f7fffffe          BL       __aeabi_fdiv
000024  e8bd4010          POP      {r4,lr}               ;536
000028  f7ffbffe          B.W      set_data
;;;541       }
;;;542    }
;;;543    
                          ENDP

                  |L16.44|
                          DCD      current_interface
                  |L16.48|
                          DCD      ||.bss||+0x80c
                  |L16.52|
                          DCD      0x447a0000

                          AREA ||i.sin_1_4||, CODE, READONLY, ALIGN=2

                  sin_1_4 PROC
;;;925    
;;;926    float* sin_1_4(int size)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;927    {
000004  4680              MOV      r8,r0
;;;928    	float* sin_stand_buf;
;;;929    	int i,end_size;
;;;930    	sin_stand_buf = (float *)malloc(sizeof(float)*size);
000006  0080              LSLS     r0,r0,#2
000008  f7fffffe          BL       malloc
00000c  4607              MOV      r7,r0
;;;931    
;;;932    	for(i=0;i<size;i++)
00000e  2400              MOVS     r4,#0
000010  e019              B        |L17.70|
                  |L17.18|
;;;933    	{
;;;934    	  sin_stand_buf[i] = mot_t_cal.k_sin*sin((2*3.14159)/i);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_i2d
000018  4602              MOV      r2,r0
00001a  460b              MOV      r3,r1
00001c  480c              LDR      r0,|L17.80|
00001e  490d              LDR      r1,|L17.84|
000020  f7fffffe          BL       __aeabi_ddiv
000024  f7fffffe          BL       ||sin||
000028  4605              MOV      r5,r0
00002a  480b              LDR      r0,|L17.88|
00002c  460e              MOV      r6,r1
00002e  6a40              LDR      r0,[r0,#0x24]  ; mot_t_cal
000030  f7fffffe          BL       __aeabi_f2d
000034  462a              MOV      r2,r5
000036  4633              MOV      r3,r6
000038  f7fffffe          BL       __aeabi_dmul
00003c  f7fffffe          BL       __aeabi_d2f
000040  f8470024          STR      r0,[r7,r4,LSL #2]
000044  1c64              ADDS     r4,r4,#1              ;932
                  |L17.70|
000046  4544              CMP      r4,r8                 ;932
000048  dbe3              BLT      |L17.18|
;;;935    	}
;;;936    	return sin_stand_buf;
00004a  4638              MOV      r0,r7
;;;937    }
00004c  e8bd81f0          POP      {r4-r8,pc}
;;;938    
                          ENDP

                  |L17.80|
                          DCD      0xf01b866e
                  |L17.84|
                          DCD      0x401921f9
                  |L17.88|
                          DCD      ||.bss||+0x80c

                          AREA ||i.start_test_init||, CODE, READONLY, ALIGN=2

                  start_test_init PROC
;;;58     
;;;59     void start_test_init()
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;60     {
;;;61     
;;;62     #ifndef WIN_SIM
;;;63     	TIM_Cmd(TIM2, ENABLE);
000004  2101              MOVS     r1,#1
000006  0788              LSLS     r0,r1,#30
000008  f7fffffe          BL       TIM_Cmd
;;;64     	TIM_Cmd(TIM4, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  482f              LDR      r0,|L18.204|
000010  f7fffffe          BL       TIM_Cmd
;;;65      // TIM_Cmd(TIM4, ENABLE);
;;;66     #endif
;;;67     
;;;68     	last_get_time =0;
000014  4a2e              LDR      r2,|L18.208|
000016  2000              MOVS     r0,#0
;;;69     	last_cap_value = 0;
;;;70         time_up =0;
;;;71     
;;;72     	get_data.acce =0;
000018  492e              LDR      r1,|L18.212|
00001a  6210              STR      r0,[r2,#0x20]         ;69  ; last_get_time
00001c  6090              STR      r0,[r2,#8]            ;70  ; last_cap_value
00001e  61d0              STR      r0,[r2,#0x1c]  ; time_up
;;;73     	get_data.current =0;
000020  60c8              STR      r0,[r1,#0xc]  ; get_data
;;;74     	get_data.frequence=0;
000022  6048              STR      r0,[r1,#4]  ; get_data
;;;75     	get_data.speed =0;
000024  6088              STR      r0,[r1,#8]  ; get_data
;;;76     	get_data.sw1_speed=0;
000026  6108              STR      r0,[r1,#0x10]  ; get_data
;;;77     	get_data.sw2_speed=0;
000028  6148              STR      r0,[r1,#0x14]  ; get_data
;;;78     
;;;79     	get_data.times = 0;
00002a  6188              STR      r0,[r1,#0x18]  ; get_data
;;;80     	
;;;81     	sw1_already_oper = 0;
00002c  61c8              STR      r0,[r1,#0x1c]  ; get_data
00002e  7050              STRB     r0,[r2,#1]
;;;82     	sw2_already_oper = 0;
000030  7090              STRB     r0,[r2,#2]
;;;83     
;;;84     	enable_sin = 0;
000032  7010              STRB     r0,[r2,#0]
;;;85     
;;;86     	get_data.e_work_state = START_TEST;
000034  2701              MOVS     r7,#1
000036  700f              STRB     r7,[r1,#0]
;;;87     
;;;88     	tspeed_buf.in_loc = 0;
000038  4927              LDR      r1,|L18.216|
;;;89     	tspeed_buf.out_loc = 0;
00003a  6008              STR      r0,[r1,#0]  ; tspeed_buf
;;;90     	tspeed_buf.in_data_size = 0;
00003c  6048              STR      r0,[r1,#4]  ; tspeed_buf
;;;91     
;;;92     	if(!intit_sw_state())
00003e  6088              STR      r0,[r1,#8]  ; tspeed_buf
000040  f7fffffe          BL       intit_sw_state
000044  b920              CBNZ     r0,|L18.80|
;;;93     	{
;;;94     
;;;95     	list_view_color(3,0,GUI_LIGHTCYAN);
000046  4a25              LDR      r2,|L18.220|
000048  2100              MOVS     r1,#0
00004a  2003              MOVS     r0,#3
00004c  f7fffffe          BL       list_view_color
                  |L18.80|
;;;96     
;;;97     	}
;;;98      
;;;99     	if((!mot_t_cal.cal_flag)&&(current_interface == PORTABLE_LIMIT_SPEED_T))
;;;100    	{
;;;101    
;;;102    	//mot_t_get_speed_line(mot_t_cal);
;;;103    
;;;104    	}
;;;105    	
;;;106    	if(current_interface == PORTABLE_LIMIT_SPEED_T)
000050  4823              LDR      r0,|L18.224|
000052  6800              LDR      r0,[r0,#0]  ; current_interface
000054  286a              CMP      r0,#0x6a
000056  d02b              BEQ      |L18.176|
;;;107    	{
;;;108    
;;;109    	set_speed(ttpars.start_speed);
;;;110    	if(etest_mode == TEST_MODE_SIN)
;;;111    	{
;;;112    #ifndef WIN_SIM
;;;113    	  TIM_Cmd(TIM5, ENABLE);
;;;114    #endif
;;;115    
;;;116    	}	
;;;117    	
;;;118    	}else{
;;;119    
;;;120    	pars.pwm_acc = pars.start_speed*PWM_PER_SPEED(pars.R_mm);
000058  4c22              LDR      r4,|L18.228|
00005a  6860              LDR      r0,[r4,#4]  ; pars
00005c  f7fffffe          BL       __aeabi_f2d
000060  4a21              LDR      r2,|L18.232|
000062  4b22              LDR      r3,|L18.236|
000064  f7fffffe          BL       __aeabi_dmul
000068  2200              MOVS     r2,#0
00006a  4b21              LDR      r3,|L18.240|
00006c  f7fffffe          BL       __aeabi_dmul
000070  4d20              LDR      r5,|L18.244|
000072  2200              MOVS     r2,#0
000074  462b              MOV      r3,r5
000076  f7fffffe          BL       __aeabi_ddiv
00007a  4602              MOV      r2,r0
00007c  460b              MOV      r3,r1
00007e  2000              MOVS     r0,#0
000080  4629              MOV      r1,r5
000082  f7fffffe          BL       __aeabi_ddiv
000086  4605              MOV      r5,r0
000088  460e              MOV      r6,r1
00008a  68e0              LDR      r0,[r4,#0xc]  ; pars
00008c  f7fffffe          BL       __aeabi_f2d
000090  462a              MOV      r2,r5
000092  4633              MOV      r3,r6
000094  f7fffffe          BL       __aeabi_dmul
000098  f7fffffe          BL       __aeabi_d2f
;;;121    	set_speed(pars.pwm_acc);
00009c  60a0              STR      r0,[r4,#8]  ; pars
00009e  f7fffffe          BL       set_speed
                  |L18.162|
;;;122    
;;;123    	}
;;;124    
;;;125    #ifndef WIN_SIM
;;;126      	EXTI_InitStructure_A.EXTI_LineCmd = ENABLE;
0000a2  480b              LDR      r0,|L18.208|
0000a4  3028              ADDS     r0,r0,#0x28
0000a6  7187              STRB     r7,[r0,#6]
;;;127      	EXTI_Init(&EXTI_InitStructure_A);
0000a8  e8bd41f0          POP      {r4-r8,lr}
0000ac  f7ffbffe          B.W      EXTI_Init
                  |L18.176|
0000b0  4811              LDR      r0,|L18.248|
0000b2  6940              LDR      r0,[r0,#0x14]         ;109  ; ttpars
0000b4  f7fffffe          BL       set_speed
0000b8  4810              LDR      r0,|L18.252|
0000ba  7800              LDRB     r0,[r0,#0]            ;110  ; etest_mode
0000bc  2803              CMP      r0,#3                 ;110
0000be  d1f0              BNE      |L18.162|
0000c0  2101              MOVS     r1,#1                 ;113
0000c2  480f              LDR      r0,|L18.256|
0000c4  f7fffffe          BL       TIM_Cmd
0000c8  e7eb              B        |L18.162|
;;;128    #endif
;;;129    
;;;130    }
;;;131    
                          ENDP

0000ca  0000              DCW      0x0000
                  |L18.204|
                          DCD      0x40000800
                  |L18.208|
                          DCD      ||.data||
                  |L18.212|
                          DCD      get_data
                  |L18.216|
                          DCD      ||.bss||
                  |L18.220|
                          DCD      0x00ffff80
                  |L18.224|
                          DCD      current_interface
                  |L18.228|
                          DCD      pars
                  |L18.232|
                          DCD      0xfc8b007a
                  |L18.236|
                          DCD      0x401921fa
                  |L18.240|
                          DCD      0x40140000
                  |L18.244|
                          DCD      0x408f4000
                  |L18.248|
                          DCD      ttpars
                  |L18.252|
                          DCD      etest_mode
                  |L18.256|
                          DCD      0x40000c00

                          AREA ||i.test_stop||, CODE, READONLY, ALIGN=2

                  test_stop PROC
;;;650    
;;;651    void test_stop()
000000  4812              LDR      r0,|L19.76|
;;;652    {
000002  b510              PUSH     {r4,lr}
;;;653    	int max;
;;;654    #ifndef WIN_SIM
;;;655       EXTI_InitStructure_A.EXTI_LineCmd = DISABLE;
000004  2100              MOVS     r1,#0
000006  7181              STRB     r1,[r0,#6]
;;;656       EXTI_Init(&EXTI_InitStructure_A);
000008  f7fffffe          BL       EXTI_Init
;;;657    
;;;658       TIM_Cmd(TIM2, DISABLE);
00000c  2100              MOVS     r1,#0
00000e  f04f4080          MOV      r0,#0x40000000
000012  f7fffffe          BL       TIM_Cmd
;;;659       TIM_Cmd(TIM4, DISABLE);
000016  2100              MOVS     r1,#0
000018  480d              LDR      r0,|L19.80|
00001a  f7fffffe          BL       TIM_Cmd
;;;660       TIM_Cmd(TIM5, DISABLE);
00001e  2100              MOVS     r1,#0
000020  480c              LDR      r0,|L19.84|
000022  f7fffffe          BL       TIM_Cmd
;;;661       TIM_Cmd(TIM7, DISABLE);
000026  2100              MOVS     r1,#0
000028  480b              LDR      r0,|L19.88|
00002a  f7fffffe          BL       TIM_Cmd
;;;662    
;;;663       set_speed(0);
00002e  2000              MOVS     r0,#0
000030  f7fffffe          BL       set_speed
;;;664       motor_dir(0);
000034  2000              MOVS     r0,#0
000036  f7fffffe          BL       motor_dir
;;;665    
;;;666       	if(current_interface == PORTABLE_LIMIT_SPEED_T)
00003a  4808              LDR      r0,|L19.92|
;;;667       {
;;;668    	max = GUI_ID_BUTTON_TMAIN;
00003c  f640010a          MOV      r1,#0x80a
000040  6800              LDR      r0,[r0,#0]            ;666  ; current_interface
;;;669       }else{
;;;670        max = GUI_ID_BUTTON_DELET;
;;;671       }
;;;672    	all_button(1,max);
000042  e8bd4010          POP      {r4,lr}
000046  2001              MOVS     r0,#1
000048  f7ffbffe          B.W      all_button
;;;673    
;;;674    #endif
;;;675    }
;;;676    
                          ENDP

                  |L19.76|
                          DCD      ||.data||+0x28
                  |L19.80|
                          DCD      0x40000800
                  |L19.84|
                          DCD      0x40000c00
                  |L19.88|
                          DCD      0x40001400
                  |L19.92|
                          DCD      current_interface

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  tspeed_buf
                          %        2060
                  mot_t_cal
                          %        40

                          AREA ||.data||, DATA, ALIGN=2

                  enable_sin
000000  00                DCB      0x00
                  sw1_already_oper
000001  00                DCB      0x00
                  sw2_already_oper
000002  00                DCB      0x00
                  init_sw1_state
000003  00                DCB      0x00
                  init_sw2_state
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  last_cap_value
                          DCD      0x00000000
                  last_speed
                          DCD      0x00000000
                  bt_data
                          DCD      0x00000000
                  current_frequence
                          DCD      0x00000000
                  current_cap_value
                          DCD      0x00000000
                  time_up
                          DCD      0x00000000
                  last_get_time
                          DCD      0x00000000
                  sin_buf
                          DCD      0x00000000
                  EXTI_InitStructure_A
                          %        8

                          AREA ||area_number.24||, DATA, ALIGN=2

                          EXPORTAS ||area_number.24||, ||.data||
                  get_freq
                          DCD      0x00000000

                          AREA ||area_number.25||, DATA, ALIGN=1

                          EXPORTAS ||area_number.25||, ||.data||
                  ADCConvertedValue
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.26||, DATA, ALIGN=0

                          EXPORTAS ||area_number.26||, ||.data||
                  judge_res
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "Source\\Mot\\mot.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_mot_c_0bc5b57d____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_mot_c_0bc5b57d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_mot_c_0bc5b57d____REVSH|
#line 128
|__asm___5_mot_c_0bc5b57d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
