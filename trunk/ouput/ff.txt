; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\ff.o --depend=.\ouput\ff.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\ff.crf Source\SDHC\fatfs\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;1981   static
;;;1982   BYTE check_fs (	/* 0:FAT-VBR, 1:Valid BR but not FAT, 2:Not a BR, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;1983   	FATFS *fs,	/* File system object */
;;;1984   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;1985   )
;;;1986   {
000002  4604              MOV      r4,r0
;;;1987   	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
000004  460a              MOV      r2,r1
000006  7840              LDRB     r0,[r0,#1]
000008  2301              MOVS     r3,#1
00000a  f1040130          ADD      r1,r4,#0x30
00000e  f7fffffe          BL       disk_read
000012  b108              CBZ      r0,|L1.24|
;;;1988   		return 3;
000014  2003              MOVS     r0,#3
;;;1989   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
;;;1990   		return 2;
;;;1991   
;;;1992   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;1993   		return 0;
;;;1994   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
;;;1995   		return 0;
;;;1996   
;;;1997   	return 1;
;;;1998   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f8b4122e          LDRH     r1,[r4,#0x22e]        ;1989
00001c  f5a1402a          SUB      r0,r1,#0xaa00         ;1989
000020  3855              SUBS     r0,r0,#0x55           ;1989
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;1990
000026  bd10              POP      {r4,pc}
                  |L1.40|
000028  f8940066          LDRB     r0,[r4,#0x66]         ;1992
00002c  f8d41067          LDR      r1,[r4,#0x67]         ;1992
000030  ea402101          ORR      r1,r0,r1,LSL #8       ;1992
000034  4808              LDR      r0,|L1.88|
000036  ebb02f01          CMP      r0,r1,LSL #8          ;1992
00003a  d008              BEQ      |L1.78|
00003c  f8941082          LDRB     r1,[r4,#0x82]         ;1994
000040  f8d42083          LDR      r2,[r4,#0x83]         ;1994
000044  ea412102          ORR      r1,r1,r2,LSL #8       ;1994
000048  ebb02f01          CMP      r0,r1,LSL #8          ;1994
00004c  d101              BNE      |L1.82|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;1995
000050  bd10              POP      {r4,pc}
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;1997
000054  bd10              POP      {r4,pc}
;;;1999   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x54414600

                          AREA ||i.chk_mounted||, CODE, READONLY, ALIGN=2

                  chk_mounted PROC
;;;2007   static
;;;2008   FRESULT chk_mounted (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2009   	const TCHAR **path,	/* Pointer to pointer to the path name (drive number) */
;;;2010   	FATFS **rfs,		/* Pointer to pointer to the found file system object */
;;;2011   	BYTE chk_wp			/* !=0: Check media write protection for write access */
;;;2012   )
;;;2013   {
000004  460e              MOV      r6,r1
;;;2014   	BYTE fmt, b, pi, *tbl;
;;;2015   	UINT vol;
;;;2016   	DSTATUS stat;
;;;2017   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;;;2018   	WORD nrsv;
;;;2019   	const TCHAR *p = *path;
;;;2020   	FATFS *fs;
;;;2021   
;;;2022   	/* Get logical drive number from the path name */
;;;2023   	vol = p[0] - '0';					/* Is there a drive number? */
000006  6801              LDR      r1,[r0,#0]
000008  4615              MOV      r5,r2                 ;2013
00000a  780b              LDRB     r3,[r1,#0]
00000c  3b30              SUBS     r3,r3,#0x30
;;;2024   	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
00000e  2b09              CMP      r3,#9
000010  d808              BHI      |L2.36|
000012  784a              LDRB     r2,[r1,#1]
000014  2a3a              CMP      r2,#0x3a
000016  d105              BNE      |L2.36|
;;;2025   		p += 2; *path = p;				/* Return pointer to the path name */
000018  1c89              ADDS     r1,r1,#2
;;;2026   	} else {							/* No drive number is given */
;;;2027   #if _FS_RPATH
;;;2028   		vol = CurrVol;					/* Use current drive */
;;;2029   #else
;;;2030   		vol = 0;						/* Use drive 0 */
;;;2031   #endif
;;;2032   	}
;;;2033   
;;;2034   	/* Check if the file system object is valid or not */
;;;2035   	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
00001a  6001              STR      r1,[r0,#0]
00001c  b113              CBZ      r3,|L2.36|
;;;2036   		return FR_INVALID_DRIVE;
00001e  200b              MOVS     r0,#0xb
                  |L2.32|
;;;2037   	*rfs = fs = FatFs[vol];				/* Return pointer to the corresponding file system object */
;;;2038   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2039   
;;;2040   	ENTER_FF(fs);						/* Lock file system */
;;;2041   
;;;2042   	if (fs->fs_type) {					/* If the logical drive has been mounted */
;;;2043   		stat = disk_status(fs->drv);
;;;2044   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
;;;2045   			if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2046   				return FR_WRITE_PROTECTED;
;;;2047   			return FR_OK;				/* The file system object is valid */
;;;2048   		}
;;;2049   	}
;;;2050   
;;;2051   	/* The file system object is not valid. */
;;;2052   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2053   
;;;2054   	fs->fs_type = 0;					/* Clear the file system object */
;;;2055   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2056   	stat = disk_initialize(fs->drv);	/* Initialize low level disk I/O layer */
;;;2057   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2058   		return FR_NOT_READY;			/* Failed to initialize due to no media or hard error */
;;;2059   	if (!_FS_READONLY && chk_wp && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2060   		return FR_WRITE_PROTECTED;
;;;2061   #if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
;;;2062   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
;;;2063   		return FR_DISK_ERR;
;;;2064   #endif
;;;2065   	/* Search FAT partition on the drive. Supports only generic partitionings, FDISK and SFD. */
;;;2066   	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
;;;2067   	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
;;;2068   	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
;;;2069   		/* Check the partition listed in the partition table */
;;;2070   		pi = LD2PT(vol);
;;;2071   		if (pi) pi--;
;;;2072   		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
;;;2073   		if (tbl[4]) {						/* Is the partition existing? */
;;;2074   			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
;;;2075   			fmt = check_fs(fs, bsect);		/* Check the partition */
;;;2076   		}
;;;2077   	}
;;;2078   	if (fmt == 3) return FR_DISK_ERR;
;;;2079   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2080   
;;;2081   	/* An FAT volume is found. Following code initializes the file system object */
;;;2082   
;;;2083   	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2084   		return FR_NO_FILESYSTEM;
;;;2085   
;;;2086   	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;2087   	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;;;2088   	fs->fsize = fasize;
;;;2089   
;;;2090   	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
;;;2091   	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
;;;2092   	fasize *= b;										/* Number of sectors for FAT area */
;;;2093   
;;;2094   	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
;;;2095   	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
;;;2096   
;;;2097   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;;;2098   	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
;;;2099   
;;;2100   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;;;2101   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;2102   
;;;2103   	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;;;2104   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
;;;2105   
;;;2106   	/* Determine the FAT sub type */
;;;2107   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;;;2108   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2109   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2110   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2111   	fmt = FS_FAT12;
;;;2112   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2113   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2114   
;;;2115   	/* Boundaries and Limits */
;;;2116   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2117   	fs->database = bsect + sysect;						/* Data start sector */
;;;2118   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2119   	if (fmt == FS_FAT32) {
;;;2120   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2121   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;2122   		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
;;;2123   	} else {
;;;2124   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2125   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2126   		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
;;;2127   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2128   	}
;;;2129   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
;;;2130   		return FR_NO_FILESYSTEM;
;;;2131   
;;;2132   #if !_FS_READONLY
;;;2133   	/* Initialize cluster allocation information */
;;;2134   	fs->free_clust = 0xFFFFFFFF;
;;;2135   	fs->last_clust = 0;
;;;2136   
;;;2137   	/* Get fsinfo if available */
;;;2138   	if (fmt == FS_FAT32) {
;;;2139   	 	fs->fsi_flag = 0;
;;;2140   		fs->fsi_sector = bsect + LD_WORD(fs->win+BPB_FSInfo);
;;;2141   		if (disk_read(fs->drv, fs->win, fs->fsi_sector, 1) == RES_OK &&
;;;2142   			LD_WORD(fs->win+BS_55AA) == 0xAA55 &&
;;;2143   			LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252 &&
;;;2144   			LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272) {
;;;2145   				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;2146   				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;2147   		}
;;;2148   	}
;;;2149   #endif
;;;2150   	fs->fs_type = fmt;		/* FAT sub-type */
;;;2151   	fs->id = ++Fsid;		/* File system mount ID */
;;;2152   	fs->winsect = 0;		/* Invalidate sector cache */
;;;2153   	fs->wflag = 0;
;;;2154   #if _FS_RPATH
;;;2155   	fs->cdir = 0;			/* Current directory (root dir) */
;;;2156   #endif
;;;2157   #if _FS_SHARE				/* Clear file lock semaphores */
;;;2158   	clear_lock(fs);
;;;2159   #endif
;;;2160   
;;;2161   	return FR_OK;
;;;2162   }
000020  e8bd87f0          POP      {r4-r10,pc}
                  |L2.36|
000024  4878              LDR      r0,|L2.520|
000026  6804              LDR      r4,[r0,#0]            ;2037
000028  6034              STR      r4,[r6,#0]            ;2038
00002a  b19c              CBZ      r4,|L2.84|
00002c  7820              LDRB     r0,[r4,#0]            ;2042
00002e  b120              CBZ      r0,|L2.58|
000030  7860              LDRB     r0,[r4,#1]            ;2043
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;2044
000038  d00e              BEQ      |L2.88|
                  |L2.58|
00003a  f04f0900          MOV      r9,#0                 ;2054
00003e  f8849000          STRB     r9,[r4,#0]            ;2054
000042  4648              MOV      r0,r9                 ;2054
000044  f8849001          STRB     r9,[r4,#1]            ;2055
000048  f7fffffe          BL       disk_initialize
00004c  07c1              LSLS     r1,r0,#31             ;2057
00004e  d008              BEQ      |L2.98|
000050  2003              MOVS     r0,#3                 ;2058
000052  e7e5              B        |L2.32|
                  |L2.84|
000054  200c              MOVS     r0,#0xc               ;2038
000056  e7e3              B        |L2.32|
                  |L2.88|
000058  b10d              CBZ      r5,|L2.94|
00005a  0740              LSLS     r0,r0,#29             ;2045
00005c  d404              BMI      |L2.104|
                  |L2.94|
00005e  2000              MOVS     r0,#0                 ;2047
000060  e7de              B        |L2.32|
                  |L2.98|
000062  b11d              CBZ      r5,|L2.108|
000064  0740              LSLS     r0,r0,#29             ;2059
000066  d501              BPL      |L2.108|
                  |L2.104|
000068  200a              MOVS     r0,#0xa               ;2060
00006a  e7d9              B        |L2.32|
                  |L2.108|
00006c  2600              MOVS     r6,#0                 ;2066
00006e  4631              MOV      r1,r6                 ;2066
000070  4620              MOV      r0,r4                 ;2066
000072  f7fffffe          BL       check_fs
000076  2801              CMP      r0,#1                 ;2068
000078  d10c              BNE      |L2.148|
00007a  f50470f7          ADD      r0,r4,#0x1ee          ;2072
00007e  7901              LDRB     r1,[r0,#4]            ;2073
000080  b3e9              CBZ      r1,|L2.254|
000082  7a01              LDRB     r1,[r0,#8]            ;2074
000084  f8d00009          LDR      r0,[r0,#9]            ;2074
000088  ea412600          ORR      r6,r1,r0,LSL #8       ;2074
00008c  4631              MOV      r1,r6                 ;2075
00008e  4620              MOV      r0,r4                 ;2075
000090  f7fffffe          BL       check_fs
                  |L2.148|
000094  2803              CMP      r0,#3                 ;2078
000096  d001              BEQ      |L2.156|
000098  bb88              CBNZ     r0,|L2.254|
00009a  e001              B        |L2.160|
                  |L2.156|
00009c  2001              MOVS     r0,#1                 ;2078
00009e  e7bf              B        |L2.32|
                  |L2.160|
0000a0  f8b4003b          LDRH     r0,[r4,#0x3b]         ;2083
0000a4  f5b07f00          CMP      r0,#0x200             ;2083
0000a8  d15c              BNE      |L2.356|
0000aa  f8b48046          LDRH     r8,[r4,#0x46]         ;2086
0000ae  f1b80f00          CMP      r8,#0                 ;2087
0000b2  d105              BNE      |L2.192|
0000b4  f8940054          LDRB     r0,[r4,#0x54]         ;2087
0000b8  f8d41055          LDR      r1,[r4,#0x55]         ;2087
0000bc  ea402801          ORR      r8,r0,r1,LSL #8       ;2087
                  |L2.192|
0000c0  f8c4801c          STR      r8,[r4,#0x1c]         ;2090
0000c4  f8940040          LDRB     r0,[r4,#0x40]         ;2090
0000c8  70e0              STRB     r0,[r4,#3]            ;2090
0000ca  2801              CMP      r0,#1                 ;2091
0000cc  d001              BEQ      |L2.210|
0000ce  2802              CMP      r0,#2                 ;2091
0000d0  d148              BNE      |L2.356|
                  |L2.210|
0000d2  f894503d          LDRB     r5,[r4,#0x3d]         ;2094
0000d6  fb08fc00          MUL      r12,r8,r0             ;2092
0000da  70a5              STRB     r5,[r4,#2]            ;2094
0000dc  b17d              CBZ      r5,|L2.254|
0000de  1e69              SUBS     r1,r5,#1              ;2095
0000e0  420d              TST      r5,r1                 ;2095
0000e2  d13f              BNE      |L2.356|
0000e4  f8b41041          LDRH     r1,[r4,#0x41]         ;2097
0000e8  8121              STRH     r1,[r4,#8]            ;2097
0000ea  0708              LSLS     r0,r1,#28             ;2098
0000ec  d13a              BNE      |L2.356|
0000ee  f8b40043          LDRH     r0,[r4,#0x43]         ;2100
0000f2  b938              CBNZ     r0,|L2.260|
0000f4  f8940050          LDRB     r0,[r4,#0x50]         ;2101
0000f8  f8d42051          LDR      r2,[r4,#0x51]         ;2101
0000fc  e000              B        |L2.256|
                  |L2.254|
0000fe  e031              B        |L2.356|
                  |L2.256|
000100  ea402002          ORR      r0,r0,r2,LSL #8       ;2101
                  |L2.260|
000104  8fe3              LDRH     r3,[r4,#0x3e]         ;2103
000106  b36b              CBZ      r3,|L2.356|
000108  eb03020c          ADD      r2,r3,r12             ;2107
00010c  eb021211          ADD      r2,r2,r1,LSR #4       ;2107
000110  4290              CMP      r0,r2                 ;2108
000112  d327              BCC      |L2.356|
000114  1a80              SUBS     r0,r0,r2              ;2109
000116  fbb0f0f5          UDIV     r0,r0,r5              ;2109
00011a  b318              CBZ      r0,|L2.356|
00011c  2501              MOVS     r5,#1                 ;2111
00011e  f64077f6          MOV      r7,#0xff6             ;2112
000122  42b8              CMP      r0,r7                 ;2112
000124  d300              BCC      |L2.296|
000126  2502              MOVS     r5,#2                 ;2112
                  |L2.296|
000128  f64f77f6          MOV      r7,#0xfff6            ;2113
00012c  42b8              CMP      r0,r7                 ;2113
00012e  d300              BCC      |L2.306|
000130  2503              MOVS     r5,#3                 ;2113
                  |L2.306|
000132  4432              ADD      r2,r2,r6              ;2117
000134  62a2              STR      r2,[r4,#0x28]         ;2118
000136  1c80              ADDS     r0,r0,#2              ;2116
000138  18f2              ADDS     r2,r6,r3              ;2118
00013a  61a0              STR      r0,[r4,#0x18]         ;2118
00013c  6222              STR      r2,[r4,#0x20]         ;2119
00013e  2d03              CMP      r5,#3                 ;2119
000140  d012              BEQ      |L2.360|
000142  b179              CBZ      r1,|L2.356|
000144  eb02010c          ADD      r1,r2,r12             ;2125
000148  6261              STR      r1,[r4,#0x24]         ;2126
00014a  2d02              CMP      r5,#2                 ;2126
00014c  d017              BEQ      |L2.382|
00014e  f0000101          AND      r1,r0,#1              ;2127
000152  eb000040          ADD      r0,r0,r0,LSL #1       ;2127
000156  eb010050          ADD      r0,r1,r0,LSR #1       ;2127
                  |L2.346|
00015a  f20010ff          ADD      r0,r0,#0x1ff          ;2129
00015e  ebb82f50          CMP      r8,r0,LSR #9          ;2129
000162  d20e              BCS      |L2.386|
                  |L2.356|
000164  200d              MOVS     r0,#0xd               ;2130
000166  e75b              B        |L2.32|
                  |L2.360|
000168  2900              CMP      r1,#0                 ;2120
00016a  d1fb              BNE      |L2.356|
00016c  f894105c          LDRB     r1,[r4,#0x5c]         ;2121
000170  f8d4205d          LDR      r2,[r4,#0x5d]         ;2121
000174  0080              LSLS     r0,r0,#2              ;2122
000176  ea412102          ORR      r1,r1,r2,LSL #8       ;2121
00017a  6261              STR      r1,[r4,#0x24]         ;2122
00017c  e7ed              B        |L2.346|
                  |L2.382|
00017e  0040              LSLS     r0,r0,#1              ;2127
000180  e7eb              B        |L2.346|
                  |L2.386|
000182  f04f30ff          MOV      r0,#0xffffffff        ;2134
000186  e9c49003          STRD     r9,r0,[r4,#0xc]       ;2138
00018a  464f              MOV      r7,r9                 ;2135
00018c  2d03              CMP      r5,#3                 ;2138
00018e  d131              BNE      |L2.500|
000190  7167              STRB     r7,[r4,#5]            ;2139
000192  f8b40060          LDRH     r0,[r4,#0x60]         ;2140
000196  2301              MOVS     r3,#1                 ;2141
000198  1982              ADDS     r2,r0,r6              ;2140
00019a  6162              STR      r2,[r4,#0x14]         ;2141
00019c  7860              LDRB     r0,[r4,#1]            ;2141
00019e  f1040130          ADD      r1,r4,#0x30           ;2141
0001a2  f7fffffe          BL       disk_read
0001a6  bb28              CBNZ     r0,|L2.500|
0001a8  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2142
0001ac  f5a0412a          SUB      r1,r0,#0xaa00         ;2142
0001b0  3955              SUBS     r1,r1,#0x55           ;2142
0001b2  d11f              BNE      |L2.500|
0001b4  f8940030          LDRB     r0,[r4,#0x30]         ;2143
0001b8  f8d41031          LDR      r1,[r4,#0x31]         ;2143
0001bc  ea402001          ORR      r0,r0,r1,LSL #8       ;2143
0001c0  4912              LDR      r1,|L2.524|
0001c2  4288              CMP      r0,r1                 ;2143
0001c4  d116              BNE      |L2.500|
0001c6  f8940214          LDRB     r0,[r4,#0x214]        ;2144
0001ca  f8d41215          LDR      r1,[r4,#0x215]        ;2144
0001ce  ea402001          ORR      r0,r0,r1,LSL #8       ;2144
0001d2  490f              LDR      r1,|L2.528|
0001d4  4288              CMP      r0,r1                 ;2144
0001d6  d10d              BNE      |L2.500|
0001d8  f894021c          LDRB     r0,[r4,#0x21c]        ;2145
0001dc  f8d4121d          LDR      r1,[r4,#0x21d]        ;2145
0001e0  ea402001          ORR      r0,r0,r1,LSL #8       ;2145
0001e4  60e0              STR      r0,[r4,#0xc]          ;2146
0001e6  f8940218          LDRB     r0,[r4,#0x218]        ;2146
0001ea  f8d41219          LDR      r1,[r4,#0x219]        ;2146
0001ee  ea402001          ORR      r0,r0,r1,LSL #8       ;2146
0001f2  6120              STR      r0,[r4,#0x10]         ;2146
                  |L2.500|
0001f4  4904              LDR      r1,|L2.520|
0001f6  7025              STRB     r5,[r4,#0]            ;2150
0001f8  1f09              SUBS     r1,r1,#4              ;2151
0001fa  8808              LDRH     r0,[r1,#0]            ;2151  ; Fsid
0001fc  1c40              ADDS     r0,r0,#1              ;2151
0001fe  8008              STRH     r0,[r1,#0]            ;2151
000200  80e0              STRH     r0,[r4,#6]            ;2151
000202  62e7              STR      r7,[r4,#0x2c]         ;2153
000204  7127              STRB     r7,[r4,#4]            ;2153
000206  e72a              B        |L2.94|
;;;2163   
                          ENDP

                  |L2.520|
                          DCD      ||.data||+0x4
                  |L2.524|
                          DCD      0x41615252
                  |L2.528|
                          DCD      0x61417272

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;800    
;;;801    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  6982              LDR      r2,[r0,#0x18]
;;;802    	FATFS *fs,		/* File system object */
;;;803    	DWORD clst		/* Cluster# to be converted */
;;;804    )
;;;805    {
;;;806    	clst -= 2;
000002  1e89              SUBS     r1,r1,#2
;;;807    	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L3.14|
00000a  2000              MOVS     r0,#0
;;;808    	return clst * fs->csize + fs->database;
;;;809    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;808
000010  7880              LDRB     r0,[r0,#2]            ;808
000012  fb012000          MLA      r0,r1,r0,r2           ;808
000016  4770              BX       lr
;;;810    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;977    static
;;;978    DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;979    	FATFS *fs,			/* File system object */
;;;980    	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;981    )
;;;982    {
000004  4606              MOV      r6,r0
000006  000f              MOVS     r7,r1
;;;983    	DWORD cs, ncl, scl;
;;;984    	FRESULT res;
;;;985    
;;;986    
;;;987    	if (clst == 0) {		/* Create a new chain */
000008  d006              BEQ      |L4.24|
;;;988    		scl = fs->last_clust;			/* Get suggested start point */
;;;989    		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;990    	}
;;;991    	else {					/* Stretch the current chain */
;;;992    		cs = get_fat(fs, clst);			/* Check the cluster status */
00000a  f7fffffe          BL       get_fat
;;;993    		if (cs < 2) return 1;			/* It is an invalid cluster */
00000e  2802              CMP      r0,#2
000010  d209              BCS      |L4.38|
000012  2001              MOVS     r0,#1
                  |L4.20|
;;;994    		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;995    		scl = clst;
;;;996    	}
;;;997    
;;;998    	ncl = scl;				/* Start cluster */
;;;999    	for (;;) {
;;;1000   		ncl++;							/* Next cluster */
;;;1001   		if (ncl >= fs->n_fatent) {		/* Wrap around */
;;;1002   			ncl = 2;
;;;1003   			if (ncl > scl) return 0;	/* No free cluster */
;;;1004   		}
;;;1005   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1006   		if (cs == 0) break;				/* Found a free cluster */
;;;1007   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1008   			return cs;
;;;1009   		if (ncl == scl) return 0;		/* No free cluster */
;;;1010   	}
;;;1011   
;;;1012   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1013   	if (res == FR_OK && clst != 0) {
;;;1014   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1015   	}
;;;1016   	if (res == FR_OK) {
;;;1017   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1018   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1019   			fs->free_clust--;
;;;1020   			fs->fsi_flag = 1;
;;;1021   		}
;;;1022   	} else {
;;;1023   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1024   	}
;;;1025   
;;;1026   	return ncl;		/* Return new cluster number or error code */
;;;1027   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L4.24|
000018  68f5              LDR      r5,[r6,#0xc]          ;989
00001a  b115              CBZ      r5,|L4.34|
00001c  69b0              LDR      r0,[r6,#0x18]         ;989
00001e  42a8              CMP      r0,r5                 ;989
000020  d805              BHI      |L4.46|
                  |L4.34|
000022  2501              MOVS     r5,#1                 ;989
000024  e003              B        |L4.46|
                  |L4.38|
000026  69b1              LDR      r1,[r6,#0x18]         ;994
000028  4281              CMP      r1,r0                 ;994
00002a  d8f3              BHI      |L4.20|
00002c  463d              MOV      r5,r7                 ;995
                  |L4.46|
00002e  462c              MOV      r4,r5                 ;998
                  |L4.48|
000030  69b0              LDR      r0,[r6,#0x18]         ;1001
000032  1c64              ADDS     r4,r4,#1              ;1000
000034  42a0              CMP      r0,r4                 ;1001
000036  d802              BHI      |L4.62|
000038  2402              MOVS     r4,#2                 ;1002
00003a  2d02              CMP      r5,#2                 ;1003
00003c  d30a              BCC      |L4.84|
                  |L4.62|
00003e  4621              MOV      r1,r4                 ;1005
000040  4630              MOV      r0,r6                 ;1005
000042  f7fffffe          BL       get_fat
000046  b138              CBZ      r0,|L4.88|
000048  1c41              ADDS     r1,r0,#1              ;1007
00004a  d0e3              BEQ      |L4.20|
00004c  2801              CMP      r0,#1                 ;1007
00004e  d0e1              BEQ      |L4.20|
000050  42ac              CMP      r4,r5                 ;1009
000052  d1ed              BNE      |L4.48|
                  |L4.84|
000054  2000              MOVS     r0,#0                 ;1009
000056  e7dd              B        |L4.20|
                  |L4.88|
000058  f06f4270          MVN      r2,#0xf0000000        ;1012
00005c  4621              MOV      r1,r4                 ;1012
00005e  4630              MOV      r0,r6                 ;1012
000060  f7fffffe          BL       put_fat
000064  b930              CBNZ     r0,|L4.116|
000066  b167              CBZ      r7,|L4.130|
000068  4622              MOV      r2,r4                 ;1014
00006a  4639              MOV      r1,r7                 ;1014
00006c  4630              MOV      r0,r6                 ;1014
00006e  f7fffffe          BL       put_fat
000072  b130              CBZ      r0,|L4.130|
                  |L4.116|
000074  f04f34ff          MOV      r4,#0xffffffff        ;1023
000078  2801              CMP      r0,#1                 ;1023
00007a  d000              BEQ      |L4.126|
00007c  2401              MOVS     r4,#1                 ;1023
                  |L4.126|
00007e  4620              MOV      r0,r4                 ;1026
000080  e7c8              B        |L4.20|
                  |L4.130|
000082  60f4              STR      r4,[r6,#0xc]          ;1018
000084  6930              LDR      r0,[r6,#0x10]         ;1018
000086  1c41              ADDS     r1,r0,#1              ;1018
000088  d0f9              BEQ      |L4.126|
00008a  1e40              SUBS     r0,r0,#1              ;1019
00008c  6130              STR      r0,[r6,#0x10]         ;1020
00008e  2001              MOVS     r0,#1                 ;1020
000090  7170              STRB     r0,[r6,#5]            ;1020
000092  e7f4              B        |L4.126|
;;;1028   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1622   static
;;;1623   FRESULT create_name (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1624   	DIR *dj,			/* Pointer to the directory object */
;;;1625   	const TCHAR **path	/* Pointer to pointer to the segment in the path string */
;;;1626   )
;;;1627   {
000004  4689              MOV      r9,r1
;;;1628   #ifdef _EXCVT
;;;1629   	static const BYTE excvt[] = _EXCVT;	/* Upper conversion table for extended chars */
;;;1630   #endif
;;;1631   
;;;1632   #if _USE_LFN	/* LFN configuration */
;;;1633   	BYTE b, cf;
;;;1634   	WCHAR w, *lfn;
;;;1635   	UINT i, ni, si, di;
;;;1636   	const TCHAR *p;
;;;1637   
;;;1638   	/* Create LFN in Unicode */
;;;1639   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1640   	lfn = dj->lfn;
;;;1641   	si = di = 0;
;;;1642   	for (;;) {
;;;1643   		w = p[si++];					/* Get a character */
;;;1644   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
;;;1645   		if (di >= _MAX_LFN)				/* Reject too long name */
;;;1646   			return FR_INVALID_NAME;
;;;1647   #if !_LFN_UNICODE
;;;1648   		w &= 0xFF;
;;;1649   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1650   			b = (BYTE)p[si++];			/* Get 2nd byte */
;;;1651   			if (!IsDBCS2(b))
;;;1652   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1653   			w = (w << 8) + b;			/* Create a DBC */
;;;1654   		}
;;;1655   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
;;;1656   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
;;;1657   #endif
;;;1658   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal chars for LFN */
;;;1659   			return FR_INVALID_NAME;
;;;1660   		lfn[di++] = w;					/* Store the Unicode char */
;;;1661   	}
;;;1662   	*path = &p[si];						/* Return pointer to the next segment */
;;;1663   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1664   #if _FS_RPATH
;;;1665   	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
;;;1666   		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
;;;1667   		lfn[di] = 0;
;;;1668   		for (i = 0; i < 11; i++)
;;;1669   			dj->fn[i] = (i < di) ? '.' : ' ';
;;;1670   		dj->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1671   		return FR_OK;
;;;1672   	}
;;;1673   #endif
;;;1674   	while (di) {						/* Strip trailing spaces and dots */
;;;1675   		w = lfn[di-1];
;;;1676   		if (w != ' ' && w != '.') break;
;;;1677   		di--;
;;;1678   	}
;;;1679   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
;;;1680   
;;;1681   	lfn[di] = 0;						/* LFN is created */
;;;1682   
;;;1683   	/* Create SFN in directory form */
;;;1684   	mem_set(dj->fn, ' ', 11);
;;;1685   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
;;;1686   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1687   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1688   
;;;1689   	b = i = 0; ni = 8;
;;;1690   	for (;;) {
;;;1691   		w = lfn[si++];					/* Get an LFN char */
;;;1692   		if (!w) break;					/* Break on end of the LFN */
;;;1693   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1694   			cf |= NS_LOSS | NS_LFN; continue;
;;;1695   		}
;;;1696   
;;;1697   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1698   			if (ni == 11) {				/* Long extension */
;;;1699   				cf |= NS_LOSS | NS_LFN; break;
;;;1700   			}
;;;1701   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1702   			if (si > di) break;			/* No extension */
;;;1703   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1704   			b <<= 2; continue;
;;;1705   		}
;;;1706   
;;;1707   		if (w >= 0x80) {				/* Non ASCII char */
;;;1708   #ifdef _EXCVT
;;;1709   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1710   			if (w) w = excvt[w - 0x80];	/* Convert extended char to upper (SBCS) */
;;;1711   #else
;;;1712   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1713   #endif
;;;1714   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1715   		}
;;;1716   
;;;1717   		if (_DF1S && w >= 0x100) {		/* Double byte char (always false on SBCS cfg) */
;;;1718   			if (i >= ni - 1) {
;;;1719   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1720   			}
;;;1721   			dj->fn[i++] = (BYTE)(w >> 8);
;;;1722   		} else {						/* Single byte char */
;;;1723   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal chars for SFN */
;;;1724   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1725   			} else {
;;;1726   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1727   					b |= 2;
;;;1728   				} else {
;;;1729   					if (IsLower(w)) {	/* ASCII small capital */
;;;1730   						b |= 1; w -= 0x20;
;;;1731   					}
;;;1732   				}
;;;1733   			}
;;;1734   		}
;;;1735   		dj->fn[i++] = (BYTE)w;
;;;1736   	}
;;;1737   
;;;1738   	if (dj->fn[0] == DDE) dj->fn[0] = NDDE;	/* If the first char collides with deleted mark, replace it with 0x05 */
;;;1739   
;;;1740   	if (ni == 8) b <<= 2;
;;;1741   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1742   		cf |= NS_LFN;
;;;1743   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended char, NT flags are created */
;;;1744   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1745   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1746   	}
;;;1747   
;;;1748   	dj->fn[NS] = cf;	/* SFN is created */
;;;1749   
;;;1750   	return FR_OK;
;;;1751   
;;;1752   
;;;1753   #else	/* Non-LFN configuration */
;;;1754   	BYTE b, c, d, *sfn;
;;;1755   	UINT ni, si, i;
;;;1756   	const char *p;
;;;1757   
;;;1758   	/* Create file name in directory form */
;;;1759   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
000006  680c              LDR      r4,[r1,#0]
000008  e000              B        |L5.12|
                  |L5.10|
00000a  1c64              ADDS     r4,r4,#1
                  |L5.12|
00000c  7821              LDRB     r1,[r4,#0]
00000e  292f              CMP      r1,#0x2f
000010  d0fb              BEQ      |L5.10|
000012  295c              CMP      r1,#0x5c
000014  d0f9              BEQ      |L5.10|
;;;1760   	sfn = dj->fn;
000016  6980              LDR      r0,[r0,#0x18]
;;;1761   	mem_set(sfn, ' ', 11);
000018  220b              MOVS     r2,#0xb
00001a  4680              MOV      r8,r0                 ;1760
00001c  2120              MOVS     r1,#0x20
00001e  f7fffffe          BL       mem_set
;;;1762   	si = i = b = 0; ni = 8;
000022  2100              MOVS     r1,#0
000024  460a              MOV      r2,r1
000026  460e              MOV      r6,r1
000028  2708              MOVS     r7,#8
                  |L5.42|
;;;1763   #if _FS_RPATH
;;;1764   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1765   		for (;;) {
;;;1766   			c = (BYTE)p[si++];
;;;1767   			if (c != '.' || si >= 3) break;
;;;1768   			sfn[i++] = c;
;;;1769   		}
;;;1770   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1771   		*path = &p[si];									/* Return pointer to the next segment */
;;;1772   		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1773   		return FR_OK;
;;;1774   	}
;;;1775   #endif
;;;1776   	for (;;) {
;;;1777   		c = (BYTE)p[si++];
00002a  5da0              LDRB     r0,[r4,r6]
00002c  1c76              ADDS     r6,r6,#1
;;;1778   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
00002e  2820              CMP      r0,#0x20
000030  d92d              BLS      |L5.142|
000032  282f              CMP      r0,#0x2f
000034  d02b              BEQ      |L5.142|
000036  285c              CMP      r0,#0x5c
000038  d029              BEQ      |L5.142|
;;;1779   		if (c == '.' || i >= ni) {
00003a  282e              CMP      r0,#0x2e
00003c  d001              BEQ      |L5.66|
00003e  42ba              CMP      r2,r7
000040  d308              BCC      |L5.84|
                  |L5.66|
;;;1780   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
000042  2f08              CMP      r7,#8
000044  d130              BNE      |L5.168|
000046  282e              CMP      r0,#0x2e
000048  d12e              BNE      |L5.168|
;;;1781   			i = 8; ni = 11;
00004a  2208              MOVS     r2,#8
00004c  270b              MOVS     r7,#0xb
;;;1782   			b <<= 2; continue;
00004e  0688              LSLS     r0,r1,#26
000050  0e01              LSRS     r1,r0,#24
000052  e7ea              B        |L5.42|
                  |L5.84|
;;;1783   		}
;;;1784   		if (c >= 0x80) {				/* Extended char? */
000054  2880              CMP      r0,#0x80
000056  d227              BCS      |L5.168|
;;;1785   			b |= 3;						/* Eliminate NT flag */
;;;1786   #ifdef _EXCVT
;;;1787   			c = excvt[c-0x80];			/* Upper conversion (SBCS) */
;;;1788   #else
;;;1789   #if !_DF1S	/* ASCII only cfg */
;;;1790   			return FR_INVALID_NAME;
;;;1791   #endif
;;;1792   #endif
;;;1793   		}
;;;1794   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1795   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;1796   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;1797   				return FR_INVALID_NAME;
;;;1798   			sfn[i++] = c;
;;;1799   			sfn[i++] = d;
;;;1800   		} else {						/* Single byte code */
;;;1801   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
000058  a320              ADR      r3,|L5.220|
00005a  e000              B        |L5.94|
                  |L5.92|
00005c  1c5b              ADDS     r3,r3,#1
                  |L5.94|
00005e  781d              LDRB     r5,[r3,#0]
000060  b115              CBZ      r5,|L5.104|
000062  4285              CMP      r5,r0
000064  d1fa              BNE      |L5.92|
000066  e01f              B        |L5.168|
                  |L5.104|
;;;1802   				return FR_INVALID_NAME;
;;;1803   			if (IsUpper(c)) {			/* ASCII large capital? */
000068  f1a00341          SUB      r3,r0,#0x41
00006c  2b19              CMP      r3,#0x19
00006e  d802              BHI      |L5.118|
;;;1804   				b |= 2;
000070  f0410102          ORR      r1,r1,#2
000074  e007              B        |L5.134|
                  |L5.118|
;;;1805   			} else {
;;;1806   				if (IsLower(c)) {		/* ASCII small capital? */
000076  f1a00361          SUB      r3,r0,#0x61
00007a  2b19              CMP      r3,#0x19
00007c  d803              BHI      |L5.134|
;;;1807   					b |= 1; c -= 0x20;
00007e  3820              SUBS     r0,r0,#0x20
000080  f0410101          ORR      r1,r1,#1
000084  b2c0              UXTB     r0,r0
                  |L5.134|
;;;1808   				}
;;;1809   			}
;;;1810   			sfn[i++] = c;
000086  f8080002          STRB     r0,[r8,r2]
00008a  1c52              ADDS     r2,r2,#1
00008c  e7cd              B        |L5.42|
                  |L5.142|
;;;1811   		}
;;;1812   	}
;;;1813   	*path = &p[si];						/* Return pointer to the next segment */
00008e  4434              ADD      r4,r4,r6
;;;1814   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
000090  2304              MOVS     r3,#4
000092  f8c94000          STR      r4,[r9,#0]
000096  2820              CMP      r0,#0x20
000098  d900              BLS      |L5.156|
00009a  2300              MOVS     r3,#0
                  |L5.156|
;;;1815   
;;;1816   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
00009c  b122              CBZ      r2,|L5.168|
;;;1817   	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
00009e  f8980000          LDRB     r0,[r8,#0]
0000a2  28e5              CMP      r0,#0xe5
0000a4  d003              BEQ      |L5.174|
0000a6  e005              B        |L5.180|
                  |L5.168|
0000a8  2006              MOVS     r0,#6                 ;1816
                  |L5.170|
;;;1818   
;;;1819   	if (ni == 8) b <<= 2;
;;;1820   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;1821   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;1822   
;;;1823   	sfn[NS] = c;		/* Store NT flag, File name is created */
;;;1824   
;;;1825   	return FR_OK;
;;;1826   #endif
;;;1827   }
0000aa  e8bd87f0          POP      {r4-r10,pc}
                  |L5.174|
0000ae  2205              MOVS     r2,#5                 ;1817
0000b0  f8882000          STRB     r2,[r8,#0]            ;1817
                  |L5.180|
0000b4  2f08              CMP      r7,#8                 ;1819
0000b6  d101              BNE      |L5.188|
0000b8  0688              LSLS     r0,r1,#26             ;1819
0000ba  0e01              LSRS     r1,r0,#24             ;1819
                  |L5.188|
0000bc  f0010003          AND      r0,r1,#3              ;1820
0000c0  2801              CMP      r0,#1                 ;1820
0000c2  d101              BNE      |L5.200|
0000c4  f0430310          ORR      r3,r3,#0x10           ;1820
                  |L5.200|
0000c8  f3c10081          UBFX     r0,r1,#2,#2           ;1821
0000cc  2801              CMP      r0,#1                 ;1821
0000ce  d101              BNE      |L5.212|
0000d0  f0430308          ORR      r3,r3,#8              ;1821
                  |L5.212|
0000d4  f888300b          STRB     r3,[r8,#0xb]          ;1823
0000d8  2000              MOVS     r0,#0                 ;1825
0000da  e7e6              B        |L5.170|
;;;1828   
                          ENDP

                  |L5.220|
0000dc  222a2b2c          DCB      """*+,:;<=>?[]|",127,0
0000e0  3a3b3c3d
0000e4  3e3f5b5d
0000e8  7c7f00  
0000eb  00                DCB      0

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1112   static
;;;1113   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:EOT and could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1114   	DIR *dj,		/* Pointer to directory object */
;;;1115   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1116   )
;;;1117   {
000004  4604              MOV      r4,r0
;;;1118   	DWORD clst;
;;;1119   	WORD i;
;;;1120   
;;;1121   
;;;1122   	stretch = stretch;		/* To suppress warning on read-only cfg. */
;;;1123   	i = dj->index + 1;
000006  88c0              LDRH     r0,[r0,#6]
000008  460e              MOV      r6,r1                 ;1117
00000a  1c40              ADDS     r0,r0,#1
00000c  0407              LSLS     r7,r0,#16
00000e  0c3f              LSRS     r7,r7,#16
;;;1124   	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
000010  d02d              BEQ      |L6.110|
000012  6920              LDR      r0,[r4,#0x10]
000014  b358              CBZ      r0,|L6.110|
;;;1125   		return FR_NO_FILE;
;;;1126   
;;;1127   	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
000016  0739              LSLS     r1,r7,#28
000018  d15d              BNE      |L6.214|
;;;1128   		dj->sect++;					/* Next sector */
00001a  1c40              ADDS     r0,r0,#1
;;;1129   
;;;1130   		if (dj->clust == 0) {	/* Static table */
00001c  6120              STR      r0,[r4,#0x10]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6820              LDR      r0,[r4,#0]
000022  b129              CBZ      r1,|L6.48|
;;;1131   			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
;;;1132   				return FR_NO_FILE;
;;;1133   		}
;;;1134   		else {					/* Dynamic table */
;;;1135   			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
000024  7882              LDRB     r2,[r0,#2]
000026  1e52              SUBS     r2,r2,#1
000028  ea121f17          TST      r2,r7,LSR #4
00002c  d004              BEQ      |L6.56|
00002e  e052              B        |L6.214|
                  |L6.48|
000030  8900              LDRH     r0,[r0,#8]            ;1131
000032  42b8              CMP      r0,r7                 ;1131
000034  d91b              BLS      |L6.110|
000036  e04e              B        |L6.214|
                  |L6.56|
;;;1136   				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4605              MOV      r5,r0
;;;1137   				if (clst <= 1) return FR_INT_ERR;
00003e  2801              CMP      r0,#1
000040  d91a              BLS      |L6.120|
;;;1138   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000042  1c68              ADDS     r0,r5,#1
000044  d032              BEQ      |L6.172|
;;;1139   				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
000046  6820              LDR      r0,[r4,#0]
000048  6981              LDR      r1,[r0,#0x18]
00004a  42a9              CMP      r1,r5
00004c  d83d              BHI      |L6.202|
;;;1140   #if !_FS_READONLY
;;;1141   					BYTE c;
;;;1142   					if (!stretch) return FR_NO_FILE;			/* When do not stretch, report EOT */
00004e  b176              CBZ      r6,|L6.110|
;;;1143   					clst = create_chain(dj->fs, dj->clust);		/* Stretch cluster chain */
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       create_chain
000056  0005              MOVS     r5,r0
;;;1144   					if (clst == 0) return FR_DENIED;			/* No free cluster */
000058  d00c              BEQ      |L6.116|
;;;1145   					if (clst == 1) return FR_INT_ERR;
00005a  2d01              CMP      r5,#1
00005c  d00c              BEQ      |L6.120|
;;;1146   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00005e  1c68              ADDS     r0,r5,#1
000060  d024              BEQ      |L6.172|
;;;1147   					/* Clean-up stretched table */
;;;1148   					if (move_window(dj->fs, 0)) return FR_DISK_ERR;	/* Flush active window */
000062  2100              MOVS     r1,#0
000064  6820              LDR      r0,[r4,#0]
000066  f7fffffe          BL       move_window
00006a  b9f8              CBNZ     r0,|L6.172|
00006c  e006              B        |L6.124|
                  |L6.110|
00006e  2004              MOVS     r0,#4                 ;1142
                  |L6.112|
;;;1149   					mem_set(dj->fs->win, 0, SS(dj->fs));			/* Clear window buffer */
;;;1150   					dj->fs->winsect = clust2sect(dj->fs, clst);	/* Cluster start sector */
;;;1151   					for (c = 0; c < dj->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1152   						dj->fs->wflag = 1;
;;;1153   						if (move_window(dj->fs, 0)) return FR_DISK_ERR;
;;;1154   						dj->fs->winsect++;
;;;1155   					}
;;;1156   					dj->fs->winsect -= c;						/* Rewind window address */
;;;1157   #else
;;;1158   					return FR_NO_FILE;			/* Report EOT */
;;;1159   #endif
;;;1160   				}
;;;1161   				dj->clust = clst;				/* Initialize data for new cluster */
;;;1162   				dj->sect = clust2sect(dj->fs, clst);
;;;1163   			}
;;;1164   		}
;;;1165   	}
;;;1166   
;;;1167   	dj->index = i;
;;;1168   	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
;;;1169   
;;;1170   	return FR_OK;
;;;1171   }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L6.116|
000074  2007              MOVS     r0,#7                 ;1144
000076  e7fb              B        |L6.112|
                  |L6.120|
000078  2002              MOVS     r0,#2                 ;1145
00007a  e7f9              B        |L6.112|
                  |L6.124|
00007c  6820              LDR      r0,[r4,#0]            ;1149
00007e  f44f7200          MOV      r2,#0x200             ;1149
000082  3030              ADDS     r0,r0,#0x30           ;1149
000084  2100              MOVS     r1,#0                 ;1149
000086  f7fffffe          BL       mem_set
00008a  4629              MOV      r1,r5                 ;1150
00008c  6820              LDR      r0,[r4,#0]            ;1150
00008e  f7fffffe          BL       clust2sect
000092  6821              LDR      r1,[r4,#0]            ;1150
000094  2600              MOVS     r6,#0                 ;1151
000096  f04f0801          MOV      r8,#1                 ;1138
00009a  62c8              STR      r0,[r1,#0x2c]         ;1151
00009c  e00e              B        |L6.188|
                  |L6.158|
00009e  f8808004          STRB     r8,[r0,#4]            ;1152
0000a2  2100              MOVS     r1,#0                 ;1153
0000a4  6820              LDR      r0,[r4,#0]            ;1153
0000a6  f7fffffe          BL       move_window
0000aa  b108              CBZ      r0,|L6.176|
                  |L6.172|
0000ac  2001              MOVS     r0,#1                 ;1153
0000ae  e7df              B        |L6.112|
                  |L6.176|
0000b0  6820              LDR      r0,[r4,#0]            ;1154
0000b2  6ac1              LDR      r1,[r0,#0x2c]         ;1154
0000b4  1c49              ADDS     r1,r1,#1              ;1154
0000b6  1c76              ADDS     r6,r6,#1              ;1151
0000b8  b2f6              UXTB     r6,r6                 ;1151
0000ba  62c1              STR      r1,[r0,#0x2c]         ;1151
                  |L6.188|
0000bc  6820              LDR      r0,[r4,#0]            ;1151
0000be  7881              LDRB     r1,[r0,#2]            ;1151
0000c0  42b1              CMP      r1,r6                 ;1151
0000c2  d8ec              BHI      |L6.158|
0000c4  6ac1              LDR      r1,[r0,#0x2c]         ;1156
0000c6  1b89              SUBS     r1,r1,r6              ;1156
0000c8  62c1              STR      r1,[r0,#0x2c]         ;1156
                  |L6.202|
0000ca  60e5              STR      r5,[r4,#0xc]          ;1162
0000cc  4629              MOV      r1,r5                 ;1162
0000ce  6820              LDR      r0,[r4,#0]            ;1162
0000d0  f7fffffe          BL       clust2sect
0000d4  6120              STR      r0,[r4,#0x10]         ;1162
                  |L6.214|
0000d6  80e7              STRH     r7,[r4,#6]            ;1167
0000d8  f007010f          AND      r1,r7,#0xf            ;1168
0000dc  2230              MOVS     r2,#0x30              ;1168
0000de  6820              LDR      r0,[r4,#0]            ;1168
0000e0  eb021141          ADD      r1,r2,r1,LSL #5       ;1168
0000e4  4408              ADD      r0,r0,r1              ;1168
0000e6  6160              STR      r0,[r4,#0x14]         ;1170
0000e8  2000              MOVS     r0,#0                 ;1170
0000ea  e7c1              B        |L6.112|
;;;1172   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=1

                  dir_read PROC
;;;1413   static
;;;1414   FRESULT dir_read (
000000  b510              PUSH     {r4,lr}
;;;1415   	DIR *dj			/* Pointer to the directory object that pointing the entry to be read */
;;;1416   )
;;;1417   {
000002  4604              MOV      r4,r0
;;;1418   	FRESULT res;
;;;1419   	BYTE c, *dir;
;;;1420   #if _USE_LFN
;;;1421   	BYTE a, ord = 0xFF, sum = 0xFF;
;;;1422   #endif
;;;1423   
;;;1424   	res = FR_NO_FILE;
000004  2004              MOVS     r0,#4
;;;1425   	while (dj->sect) {
000006  e015              B        |L7.52|
                  |L7.8|
;;;1426   		res = move_window(dj->fs, dj->sect);
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       move_window
;;;1427   		if (res != FR_OK) break;
00000e  b9b0              CBNZ     r0,|L7.62|
;;;1428   		dir = dj->dir;					/* Ptr to the directory entry of current index */
;;;1429   		c = dir[DIR_Name];
000010  6962              LDR      r2,[r4,#0x14]
000012  7811              LDRB     r1,[r2,#0]
;;;1430   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000014  b161              CBZ      r1,|L7.48|
;;;1431   #if _USE_LFN	/* LFN configuration */
;;;1432   		a = dir[DIR_Attr] & AM_MASK;
;;;1433   		if (c == DDE || (!_FS_RPATH && c == '.') || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
;;;1434   			ord = 0xFF;
;;;1435   		} else {
;;;1436   			if (a == AM_LFN) {			/* An LFN entry is found */
;;;1437   				if (c & LLE) {			/* Is it start of LFN sequence? */
;;;1438   					sum = dir[LDIR_Chksum];
;;;1439   					c &= ~LLE; ord = c;
;;;1440   					dj->lfn_idx = dj->index;
;;;1441   				}
;;;1442   				/* Check LFN validity and capture it */
;;;1443   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dj->lfn, dir)) ? ord - 1 : 0xFF;
;;;1444   			} else {					/* An SFN entry is found */
;;;1445   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
;;;1446   					dj->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1447   				break;
;;;1448   			}
;;;1449   		}
;;;1450   #else		/* Non LFN configuration */
;;;1451   		if (c != DDE && (_FS_RPATH || c != '.') && !(dir[DIR_Attr] & AM_VOL))	/* Is it a valid entry? */
000016  29e5              CMP      r1,#0xe5
000018  d004              BEQ      |L7.36|
00001a  292e              CMP      r1,#0x2e
00001c  d002              BEQ      |L7.36|
00001e  7ad1              LDRB     r1,[r2,#0xb]
000020  0709              LSLS     r1,r1,#28
000022  d50e              BPL      |L7.66|
                  |L7.36|
;;;1452   			break;
;;;1453   #endif
;;;1454   		res = dir_next(dj, 0);				/* Next entry */
000024  2100              MOVS     r1,#0
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       dir_next
;;;1455   		if (res != FR_OK) break;
00002c  b110              CBZ      r0,|L7.52|
00002e  e006              B        |L7.62|
                  |L7.48|
000030  2004              MOVS     r0,#4                 ;1430
000032  e004              B        |L7.62|
                  |L7.52|
000034  6921              LDR      r1,[r4,#0x10]         ;1425
000036  2900              CMP      r1,#0                 ;1425
000038  d1e6              BNE      |L7.8|
;;;1456   	}
;;;1457   
;;;1458   	if (res != FR_OK) dj->sect = 0;
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L7.66|
                  |L7.62|
00003e  2100              MOVS     r1,#0
000040  6121              STR      r1,[r4,#0x10]
                  |L7.66|
;;;1459   
;;;1460   	return res;
;;;1461   }
000042  bd10              POP      {r4,pc}
;;;1462   #endif
                          ENDP


                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=1

                  dir_register PROC
;;;1470   static
;;;1471   FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  b570              PUSH     {r4-r6,lr}
;;;1472   	DIR *dj				/* Target directory with object name to be created */
;;;1473   )
;;;1474   {
000002  4605              MOV      r5,r0
;;;1475   	FRESULT res;
;;;1476   	BYTE c, *dir;
;;;1477   #if _USE_LFN	/* LFN configuration */
;;;1478   	WORD n, ne, is;
;;;1479   	BYTE sn[12], *fn, sum;
;;;1480   	WCHAR *lfn;
;;;1481   
;;;1482   
;;;1483   	fn = dj->fn; lfn = dj->lfn;
;;;1484   	mem_cpy(sn, fn, 12);
;;;1485   
;;;1486   	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
;;;1487   		return FR_INVALID_NAME;
;;;1488   
;;;1489   	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
;;;1490   		fn[NS] = 0; dj->lfn = 0;			/* Find only SFN */
;;;1491   		for (n = 1; n < 100; n++) {
;;;1492   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
;;;1493   			res = dir_find(dj);				/* Check if the name collides with existing SFN */
;;;1494   			if (res != FR_OK) break;
;;;1495   		}
;;;1496   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
;;;1497   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
;;;1498   		fn[NS] = sn[NS]; dj->lfn = lfn;
;;;1499   	}
;;;1500   
;;;1501   	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, reserve an SFN + LFN entries. */
;;;1502   		for (ne = 0; lfn[ne]; ne++) ;
;;;1503   		ne = (ne + 25) / 13;
;;;1504   	} else {						/* Otherwise reserve only an SFN entry. */
;;;1505   		ne = 1;
;;;1506   	}
;;;1507   
;;;1508   	/* Reserve contiguous entries */
;;;1509   	res = dir_sdi(dj, 0);
;;;1510   	if (res != FR_OK) return res;
;;;1511   	n = is = 0;
;;;1512   	do {
;;;1513   		res = move_window(dj->fs, dj->sect);
;;;1514   		if (res != FR_OK) break;
;;;1515   		c = *dj->dir;				/* Check the entry status */
;;;1516   		if (c == DDE || c == 0) {	/* Is it a blank entry? */
;;;1517   			if (n == 0) is = dj->index;	/* First index of the contiguous entry */
;;;1518   			if (++n == ne) break;	/* A contiguous entry that required count is found */
;;;1519   		} else {
;;;1520   			n = 0;					/* Not a blank entry. Restart to search */
;;;1521   		}
;;;1522   		res = dir_next(dj, 1);		/* Next entry with table stretch */
;;;1523   	} while (res == FR_OK);
;;;1524   
;;;1525   	if (res == FR_OK && ne > 1) {	/* Initialize LFN entry if needed */
;;;1526   		res = dir_sdi(dj, is);
;;;1527   		if (res == FR_OK) {
;;;1528   			sum = sum_sfn(dj->fn);	/* Sum of the SFN tied to the LFN */
;;;1529   			ne--;
;;;1530   			do {					/* Store LFN entries in bottom first */
;;;1531   				res = move_window(dj->fs, dj->sect);
;;;1532   				if (res != FR_OK) break;
;;;1533   				fit_lfn(dj->lfn, dj->dir, (BYTE)ne, sum);
;;;1534   				dj->fs->wflag = 1;
;;;1535   				res = dir_next(dj, 0);	/* Next entry */
;;;1536   			} while (res == FR_OK && --ne);
;;;1537   		}
;;;1538   	}
;;;1539   
;;;1540   #else	/* Non LFN configuration */
;;;1541   	res = dir_sdi(dj, 0);
000004  2100              MOVS     r1,#0
000006  f7fffffe          BL       dir_sdi
;;;1542   	if (res == FR_OK) {
00000a  e00e              B        |L8.42|
                  |L8.12|
;;;1543   		do {	/* Find a blank entry for the SFN */
;;;1544   			res = move_window(dj->fs, dj->sect);
00000c  6929              LDR      r1,[r5,#0x10]
00000e  6828              LDR      r0,[r5,#0]
000010  f7fffffe          BL       move_window
000014  0004              MOVS     r4,r0
;;;1545   			if (res != FR_OK) break;
000016  d11f              BNE      |L8.88|
;;;1546   			c = *dj->dir;
000018  6968              LDR      r0,[r5,#0x14]
00001a  7800              LDRB     r0,[r0,#0]
;;;1547   			if (c == DDE || c == 0) break;	/* Is it a blank entry? */
00001c  28e5              CMP      r0,#0xe5
00001e  d007              BEQ      |L8.48|
000020  b130              CBZ      r0,|L8.48|
;;;1548   			res = dir_next(dj, 1);			/* Next entry with table stretch */
000022  2101              MOVS     r1,#1
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       dir_next
                  |L8.42|
00002a  0004              MOVS     r4,r0                 ;1541
00002c  d0ee              BEQ      |L8.12|
00002e  e013              B        |L8.88|
                  |L8.48|
;;;1549   		} while (res == FR_OK);
;;;1550   	}
;;;1551   #endif
;;;1552   
;;;1553   	if (res == FR_OK) {		/* Initialize the SFN entry */
;;;1554   		res = move_window(dj->fs, dj->sect);
000030  6929              LDR      r1,[r5,#0x10]
000032  6828              LDR      r0,[r5,#0]
000034  f7fffffe          BL       move_window
000038  0004              MOVS     r4,r0
;;;1555   		if (res == FR_OK) {
00003a  d10d              BNE      |L8.88|
;;;1556   			dir = dj->dir;
;;;1557   			mem_set(dir, 0, SZ_DIR);	/* Clean the entry */
00003c  696e              LDR      r6,[r5,#0x14]
00003e  2220              MOVS     r2,#0x20
000040  2100              MOVS     r1,#0
000042  4630              MOV      r0,r6
000044  f7fffffe          BL       mem_set
;;;1558   			mem_cpy(dir, dj->fn, 11);	/* Put SFN */
000048  220b              MOVS     r2,#0xb
00004a  4630              MOV      r0,r6
00004c  69a9              LDR      r1,[r5,#0x18]
00004e  f7fffffe          BL       mem_cpy
;;;1559   #if _USE_LFN
;;;1560   			dir[DIR_NTres] = *(dj->fn+NS) & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1561   #endif
;;;1562   			dj->fs->wflag = 1;
000052  6829              LDR      r1,[r5,#0]
000054  2001              MOVS     r0,#1
000056  7108              STRB     r0,[r1,#4]
                  |L8.88|
;;;1563   		}
;;;1564   	}
;;;1565   
;;;1566   	return res;
000058  4620              MOV      r0,r4
;;;1567   }
00005a  bd70              POP      {r4-r6,pc}
;;;1568   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1577   static
;;;1578   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  b510              PUSH     {r4,lr}
;;;1579   	DIR *dj				/* Directory object pointing the entry to be removed */
;;;1580   )
;;;1581   {
000002  4604              MOV      r4,r0
;;;1582   	FRESULT res;
;;;1583   #if _USE_LFN	/* LFN configuration */
;;;1584   	WORD i;
;;;1585   
;;;1586   	i = dj->index;	/* SFN index */
;;;1587   	res = dir_sdi(dj, (WORD)((dj->lfn_idx == 0xFFFF) ? i : dj->lfn_idx));	/* Goto the SFN or top of the LFN entries */
;;;1588   	if (res == FR_OK) {
;;;1589   		do {
;;;1590   			res = move_window(dj->fs, dj->sect);
;;;1591   			if (res != FR_OK) break;
;;;1592   			*dj->dir = DDE;			/* Mark the entry "deleted" */
;;;1593   			dj->fs->wflag = 1;
;;;1594   			if (dj->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
;;;1595   			res = dir_next(dj, 0);		/* Next entry */
;;;1596   		} while (res == FR_OK);
;;;1597   		if (res == FR_NO_FILE) res = FR_INT_ERR;
;;;1598   	}
;;;1599   
;;;1600   #else			/* Non LFN configuration */
;;;1601   	res = dir_sdi(dj, dj->index);
000004  88c1              LDRH     r1,[r0,#6]
000006  f7fffffe          BL       dir_sdi
;;;1602   	if (res == FR_OK) {
00000a  2800              CMP      r0,#0
00000c  d10b              BNE      |L9.38|
;;;1603   		res = move_window(dj->fs, dj->sect);
00000e  6921              LDR      r1,[r4,#0x10]
000010  6820              LDR      r0,[r4,#0]
000012  f7fffffe          BL       move_window
;;;1604   		if (res == FR_OK) {
000016  2800              CMP      r0,#0
000018  d105              BNE      |L9.38|
;;;1605   			*dj->dir = DDE;			/* Mark the entry "deleted" */
00001a  6962              LDR      r2,[r4,#0x14]
00001c  21e5              MOVS     r1,#0xe5
00001e  7011              STRB     r1,[r2,#0]
;;;1606   			dj->fs->wflag = 1;
000020  6822              LDR      r2,[r4,#0]
000022  2101              MOVS     r1,#1
000024  7111              STRB     r1,[r2,#4]
                  |L9.38|
;;;1607   		}
;;;1608   	}
;;;1609   #endif
;;;1610   
;;;1611   	return res;
;;;1612   }
000026  bd10              POP      {r4,pc}
;;;1613   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=1

                  dir_sdi PROC
;;;1064   static
;;;1065   FRESULT dir_sdi (
000000  b570              PUSH     {r4-r6,lr}
;;;1066   	DIR *dj,		/* Pointer to directory object */
;;;1067   	WORD idx		/* Directory index number */
;;;1068   )
;;;1069   {
000002  460d              MOV      r5,r1
;;;1070   	DWORD clst;
;;;1071   	WORD ic;
;;;1072   
;;;1073   
;;;1074   	dj->index = idx;
000004  80c1              STRH     r1,[r0,#6]
;;;1075   	clst = dj->sclust;
;;;1076   	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
000006  6881              LDR      r1,[r0,#8]
000008  4604              MOV      r4,r0                 ;1069
00000a  2901              CMP      r1,#1
00000c  d01e              BEQ      |L10.76|
00000e  6820              LDR      r0,[r4,#0]
000010  6982              LDR      r2,[r0,#0x18]
000012  428a              CMP      r2,r1
000014  d91a              BLS      |L10.76|
;;;1077   		return FR_INT_ERR;
;;;1078   	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b921              CBNZ     r1,|L10.34|
000018  7802              LDRB     r2,[r0,#0]
00001a  2a03              CMP      r2,#3
00001c  d104              BNE      |L10.40|
;;;1079   		clst = dj->fs->dirbase;
;;;1080   
;;;1081   	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
00001e  6a41              LDR      r1,[r0,#0x24]
000020  b111              CBZ      r1,|L10.40|
                  |L10.34|
;;;1082   		dj->clust = clst;
;;;1083   		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
;;;1084   			return FR_INT_ERR;
;;;1085   		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1086   	}
;;;1087   	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
;;;1088   		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
000022  7880              LDRB     r0,[r0,#2]
000024  0106              LSLS     r6,r0,#4
;;;1089   		while (idx >= ic) {	/* Follow cluster chain */
000026  e017              B        |L10.88|
                  |L10.40|
000028  60e1              STR      r1,[r4,#0xc]          ;1083
00002a  8901              LDRH     r1,[r0,#8]            ;1083
00002c  42a9              CMP      r1,r5                 ;1083
00002e  d90d              BLS      |L10.76|
000030  6a40              LDR      r0,[r0,#0x24]         ;1085
000032  e017              B        |L10.100|
                  |L10.52|
;;;1090   			clst = get_fat(dj->fs, clst);				/* Get next cluster */
000034  6820              LDR      r0,[r4,#0]
000036  f7fffffe          BL       get_fat
00003a  4601              MOV      r1,r0
;;;1091   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003c  1c40              ADDS     r0,r0,#1
00003e  d007              BEQ      |L10.80|
;;;1092   			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
000040  2902              CMP      r1,#2
000042  d303              BCC      |L10.76|
000044  6820              LDR      r0,[r4,#0]
000046  6980              LDR      r0,[r0,#0x18]
000048  4288              CMP      r0,r1
00004a  d803              BHI      |L10.84|
                  |L10.76|
;;;1093   				return FR_INT_ERR;
00004c  2002              MOVS     r0,#2
;;;1094   			idx -= ic;
;;;1095   		}
;;;1096   		dj->clust = clst;
;;;1097   		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
;;;1098   	}
;;;1099   
;;;1100   	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
;;;1101   
;;;1102   	return FR_OK;	/* Seek succeeded */
;;;1103   }
00004e  bd70              POP      {r4-r6,pc}
                  |L10.80|
000050  2001              MOVS     r0,#1                 ;1091
000052  bd70              POP      {r4-r6,pc}
                  |L10.84|
000054  1ba8              SUBS     r0,r5,r6              ;1094
000056  b285              UXTH     r5,r0                 ;1094
                  |L10.88|
000058  42b5              CMP      r5,r6                 ;1089
00005a  d2eb              BCS      |L10.52|
00005c  60e1              STR      r1,[r4,#0xc]          ;1097
00005e  6820              LDR      r0,[r4,#0]            ;1097
000060  f7fffffe          BL       clust2sect
                  |L10.100|
000064  eb001015          ADD      r0,r0,r5,LSR #4       ;1097
000068  6120              STR      r0,[r4,#0x10]         ;1100
00006a  f005010f          AND      r1,r5,#0xf            ;1100
00006e  2230              MOVS     r2,#0x30              ;1100
000070  6820              LDR      r0,[r4,#0]            ;1100
000072  eb021141          ADD      r1,r2,r1,LSL #5       ;1100
000076  4408              ADD      r0,r0,r1              ;1100
000078  6160              STR      r0,[r4,#0x14]         ;1102
00007a  2000              MOVS     r0,#0                 ;1102
00007c  bd70              POP      {r4-r6,pc}
;;;1104   
                          ENDP


                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3330   
;;;3331   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3332   	const TCHAR *path,	/* Pointer to the file path */
;;;3333   	BYTE value,			/* Attribute bits */
;;;3334   	BYTE mask			/* Attribute mask to change */
;;;3335   )
;;;3336   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;3337   	FRESULT res;
;;;3338   	DIR dj;
;;;3339   	BYTE *dir;
;;;3340   	DEF_NAMEBUF;
;;;3341   
;;;3342   
;;;3343   	res = chk_mounted(&path, &dj.fs, 1);
000008  2201              MOVS     r2,#1
00000a  4669              MOV      r1,sp
00000c  a80a              ADD      r0,sp,#0x28
00000e  f7fffffe          BL       chk_mounted
;;;3344   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d116              BNE      |L11.68|
;;;3345   		INIT_BUF(dj);
000016  a807              ADD      r0,sp,#0x1c
;;;3346   		res = follow_path(&dj, path);		/* Follow the file path */
000018  9006              STR      r0,[sp,#0x18]
00001a  4668              MOV      r0,sp
00001c  990a              LDR      r1,[sp,#0x28]
00001e  f7fffffe          BL       follow_path
;;;3347   		FREE_BUF();
;;;3348   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3349   			res = FR_INVALID_NAME;
;;;3350   		if (res == FR_OK) {
000022  2800              CMP      r0,#0
000024  d10e              BNE      |L11.68|
;;;3351   			dir = dj.dir;
;;;3352   			if (!dir) {						/* Is it a root directory? */
000026  9805              LDR      r0,[sp,#0x14]
000028  b170              CBZ      r0,|L11.72|
;;;3353   				res = FR_INVALID_NAME;
;;;3354   			} else {						/* File or sub directory */
;;;3355   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
00002a  f0050227          AND      r2,r5,#0x27
;;;3356   				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
00002e  7ac1              LDRB     r1,[r0,#0xb]
000030  4014              ANDS     r4,r4,r2
000032  4391              BICS     r1,r1,r2
000034  430c              ORRS     r4,r4,r1
000036  72c4              STRB     r4,[r0,#0xb]
;;;3357   				dj.fs->wflag = 1;
000038  9900              LDR      r1,[sp,#0]
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
;;;3358   				res = sync(dj.fs);
00003e  9800              LDR      r0,[sp,#0]
000040  f7fffffe          BL       sync
                  |L11.68|
;;;3359   			}
;;;3360   		}
;;;3361   	}
;;;3362   
;;;3363   	LEAVE_FF(dj.fs, res);
;;;3364   }
000044  b00d              ADD      sp,sp,#0x34
000046  bd30              POP      {r4,r5,pc}
                  |L11.72|
000048  2006              MOVS     r0,#6                 ;3353
00004a  e7fb              B        |L11.68|
;;;3365   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2639   
;;;2640   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2641   	FIL *fp		/* Pointer to the file object to be closed */
;;;2642   )
;;;2643   {
000002  4604              MOV      r4,r0
;;;2644   	FRESULT res;
;;;2645   
;;;2646   #if _FS_READONLY
;;;2647   	FATFS *fs = fp->fs;
;;;2648   	res = validate(fs, fp->id);
;;;2649   	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
;;;2650   	LEAVE_FF(fs, res);
;;;2651   
;;;2652   #else
;;;2653   	res = f_sync(fp);		/* Flush cached data */
000004  f7fffffe          BL       f_sync
;;;2654   #if _FS_SHARE
;;;2655   	if (res == FR_OK) {		/* Decrement open counter */
;;;2656   #if _FS_REENTRANT
;;;2657   		res = validate(fp->fs, fp->id);
;;;2658   		if (res == FR_OK) {
;;;2659   			res = dec_lock(fp->lockid);	
;;;2660   			unlock_fs(fp->fs, FR_OK);
;;;2661   		}
;;;2662   #else
;;;2663   		res = dec_lock(fp->lockid);
;;;2664   #endif
;;;2665   	}
;;;2666   #endif
;;;2667   	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
000008  2800              CMP      r0,#0
00000a  d101              BNE      |L12.16|
00000c  2100              MOVS     r1,#0
00000e  6021              STR      r1,[r4,#0]
                  |L12.16|
;;;2668   	return res;
;;;2669   #endif
;;;2670   }
000010  bd10              POP      {r4,pc}
;;;2671   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3076   
;;;3077   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3078   	const TCHAR *path,	/* Pointer to the logical drive number (root dir) */
;;;3079   	DWORD *nclst,		/* Pointer to the variable to return number of free clusters */
;;;3080   	FATFS **fatfs		/* Pointer to pointer to corresponding file system object to return */
;;;3081   )
;;;3082   {
000004  4615              MOV      r5,r2
000006  468a              MOV      r10,r1
;;;3083   	FRESULT res;
;;;3084   	DWORD n, clst, sect, stat;
;;;3085   	UINT i;
;;;3086   	BYTE fat, *p;
;;;3087   
;;;3088   
;;;3089   	/* Get drive number */
;;;3090   	res = chk_mounted(&path, fatfs, 0);
000008  2200              MOVS     r2,#0
00000a  4629              MOV      r1,r5
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       chk_mounted
000012  ea5f0800          MOVS     r8,r0
;;;3091   	if (res == FR_OK) {
000016  d154              BNE      |L13.194|
;;;3092   		/* If free_clust is valid, return it without full cluster scan */
;;;3093   		if ((*fatfs)->free_clust <= (*fatfs)->n_fatent - 2) {
000018  6828              LDR      r0,[r5,#0]
00001a  6987              LDR      r7,[r0,#0x18]
00001c  6901              LDR      r1,[r0,#0x10]
00001e  1eba              SUBS     r2,r7,#2
000020  4291              CMP      r1,r2
000022  d802              BHI      |L13.42|
;;;3094   			*nclst = (*fatfs)->free_clust;
000024  f8ca1000          STR      r1,[r10,#0]
000028  e04b              B        |L13.194|
                  |L13.42|
;;;3095   		} else {
;;;3096   			/* Get number of free clusters */
;;;3097   			fat = (*fatfs)->fs_type;
00002a  f8909000          LDRB     r9,[r0,#0]
;;;3098   			n = 0;
00002e  2400              MOVS     r4,#0
;;;3099   			if (fat == FS_FAT12) {
000030  f1b90f01          CMP      r9,#1
000034  d001              BEQ      |L13.58|
;;;3100   				clst = 2;
;;;3101   				do {
;;;3102   					stat = get_fat(*fatfs, clst);
;;;3103   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3104   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3105   					if (stat == 0) n++;
;;;3106   				} while (++clst < (*fatfs)->n_fatent);
;;;3107   			} else {
;;;3108   				clst = (*fatfs)->n_fatent;
;;;3109   				sect = (*fatfs)->fatbase;
;;;3110   				i = 0; p = 0;
;;;3111   				do {
000036  6a06              LDR      r6,[r0,#0x20]
000038  e017              B        |L13.106|
                  |L13.58|
00003a  2602              MOVS     r6,#2                 ;3100
                  |L13.60|
00003c  4631              MOV      r1,r6                 ;3102
00003e  6828              LDR      r0,[r5,#0]            ;3102
000040  f7fffffe          BL       get_fat
000044  1c41              ADDS     r1,r0,#1              ;3103
000046  d003              BEQ      |L13.80|
000048  2801              CMP      r0,#1                 ;3104
00004a  d003              BEQ      |L13.84|
00004c  b128              CBZ      r0,|L13.90|
00004e  e005              B        |L13.92|
                  |L13.80|
000050  2001              MOVS     r0,#1                 ;3103
000052  e000              B        |L13.86|
                  |L13.84|
000054  2002              MOVS     r0,#2                 ;3104
                  |L13.86|
000056  4680              MOV      r8,r0                 ;3104
000058  e029              B        |L13.174|
                  |L13.90|
00005a  1c64              ADDS     r4,r4,#1              ;3105
                  |L13.92|
00005c  6828              LDR      r0,[r5,#0]            ;3106
00005e  1c76              ADDS     r6,r6,#1              ;3106
000060  6980              LDR      r0,[r0,#0x18]         ;3106
000062  4286              CMP      r6,r0                 ;3106
000064  d3ea              BCC      |L13.60|
000066  e022              B        |L13.174|
                  |L13.104|
;;;3112   					if (!i) {
000068  b959              CBNZ     r1,|L13.130|
                  |L13.106|
;;;3113   						res = move_window(*fatfs, sect++);
00006a  4631              MOV      r1,r6
00006c  1c76              ADDS     r6,r6,#1
00006e  6828              LDR      r0,[r5,#0]
000070  f7fffffe          BL       move_window
000074  ea5f0800          MOVS     r8,r0
;;;3114   						if (res != FR_OK) break;
000078  d119              BNE      |L13.174|
;;;3115   						p = (*fatfs)->win;
00007a  6828              LDR      r0,[r5,#0]
;;;3116   						i = SS(*fatfs);
00007c  f44f7100          MOV      r1,#0x200
000080  3030              ADDS     r0,r0,#0x30           ;3115
                  |L13.130|
;;;3117   					}
;;;3118   					if (fat == FS_FAT16) {
000082  f1b90f02          CMP      r9,#2
000086  d007              BEQ      |L13.152|
;;;3119   						if (LD_WORD(p) == 0) n++;
;;;3120   						p += 2; i -= 2;
;;;3121   					} else {
;;;3122   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
000088  7802              LDRB     r2,[r0,#0]
00008a  f8d03001          LDR      r3,[r0,#1]
00008e  ea422203          ORR      r2,r2,r3,LSL #8
000092  0112              LSLS     r2,r2,#4
000094  d006              BEQ      |L13.164|
000096  e006              B        |L13.166|
                  |L13.152|
000098  8802              LDRH     r2,[r0,#0]            ;3119
00009a  b902              CBNZ     r2,|L13.158|
00009c  1c64              ADDS     r4,r4,#1              ;3119
                  |L13.158|
00009e  1c80              ADDS     r0,r0,#2              ;3120
0000a0  1e89              SUBS     r1,r1,#2              ;3120
0000a2  e002              B        |L13.170|
                  |L13.164|
0000a4  1c64              ADDS     r4,r4,#1
                  |L13.166|
;;;3123   						p += 4; i -= 4;
0000a6  1d00              ADDS     r0,r0,#4
0000a8  1f09              SUBS     r1,r1,#4
                  |L13.170|
;;;3124   					}
;;;3125   				} while (--clst);
0000aa  1e7f              SUBS     r7,r7,#1
0000ac  d1dc              BNE      |L13.104|
                  |L13.174|
;;;3126   			}
;;;3127   			(*fatfs)->free_clust = n;
0000ae  6828              LDR      r0,[r5,#0]
;;;3128   			if (fat == FS_FAT32) (*fatfs)->fsi_flag = 1;
0000b0  f1b90f03          CMP      r9,#3
0000b4  6104              STR      r4,[r0,#0x10]
0000b6  d102              BNE      |L13.190|
0000b8  6829              LDR      r1,[r5,#0]
0000ba  2001              MOVS     r0,#1
0000bc  7148              STRB     r0,[r1,#5]
                  |L13.190|
;;;3129   			*nclst = n;
0000be  f8ca4000          STR      r4,[r10,#0]
                  |L13.194|
;;;3130   		}
;;;3131   	}
;;;3132   	LEAVE_FF(*fatfs, res);
0000c2  4640              MOV      r0,r8
;;;3133   }
0000c4  e8bd8ffe          POP      {r1-r11,pc}
;;;3134   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;2803   
;;;2804   FRESULT f_lseek (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;2805   	FIL *fp,		/* Pointer to the file object */
;;;2806   	DWORD ofs		/* File pointer from top of file */
;;;2807   )
;;;2808   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;2809   	FRESULT res;
;;;2810   
;;;2811   
;;;2812   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000008  8881              LDRH     r1,[r0,#4]
00000a  6800              LDR      r0,[r0,#0]
00000c  f7fffffe          BL       validate
000010  ea5f0800          MOVS     r8,r0
;;;2813   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  d103              BNE      |L14.30|
;;;2814   	if (fp->flag & FA__ERROR)			/* Check abort flag */
000016  79a1              LDRB     r1,[r4,#6]
000018  0608              LSLS     r0,r1,#24
00001a  d502              BPL      |L14.34|
                  |L14.28|
;;;2815   		LEAVE_FF(fp->fs, FR_INT_ERR);
00001c  2002              MOVS     r0,#2
                  |L14.30|
;;;2816   
;;;2817   #if _USE_FASTSEEK
;;;2818   	if (fp->cltbl) {	/* Fast seek */
;;;2819   		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;2820   
;;;2821   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;2822   			tbl = fp->cltbl;
;;;2823   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;2824   			cl = fp->sclust;			/* Top of the chain */
;;;2825   			if (cl) {
;;;2826   				do {
;;;2827   					/* Get a fragment */
;;;2828   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;2829   					do {
;;;2830   						pcl = cl; ncl++;
;;;2831   						cl = get_fat(fp->fs, cl);
;;;2832   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;2833   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2834   					} while (cl == pcl + 1);
;;;2835   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;2836   						*tbl++ = ncl; *tbl++ = tcl;
;;;2837   					}
;;;2838   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;2839   			}
;;;2840   			*fp->cltbl = ulen;	/* Number of items used */
;;;2841   			if (ulen <= tlen)
;;;2842   				*tbl = 0;		/* Terminate table */
;;;2843   			else
;;;2844   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;2845   
;;;2846   		} else {						/* Fast seek */
;;;2847   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;2848   				ofs = fp->fsize;
;;;2849   			fp->fptr = ofs;				/* Set file pointer */
;;;2850   			if (ofs) {
;;;2851   				fp->clust = clmt_clust(fp, ofs - 1);
;;;2852   				dsc = clust2sect(fp->fs, fp->clust);
;;;2853   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;2854   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;2855   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;2856   #if !_FS_TINY
;;;2857   #if !_FS_READONLY
;;;2858   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2859   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2860   							ABORT(fp->fs, FR_DISK_ERR);
;;;2861   						fp->flag &= ~FA__DIRTY;
;;;2862   					}
;;;2863   #endif
;;;2864   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1) != RES_OK)	/* Load current sector */
;;;2865   						ABORT(fp->fs, FR_DISK_ERR);
;;;2866   #endif
;;;2867   					fp->dsect = dsc;
;;;2868   				}
;;;2869   			}
;;;2870   		}
;;;2871   	} else
;;;2872   #endif
;;;2873   
;;;2874   	/* Normal Seek */
;;;2875   	{
;;;2876   		DWORD clst, bcs, nsect, ifptr;
;;;2877   
;;;2878   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
;;;2879   #if !_FS_READONLY
;;;2880   			 && !(fp->flag & FA_WRITE)
;;;2881   #endif
;;;2882   			) ofs = fp->fsize;
;;;2883   
;;;2884   		ifptr = fp->fptr;
;;;2885   		fp->fptr = nsect = 0;
;;;2886   		if (ofs) {
;;;2887   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
;;;2888   			if (ifptr > 0 &&
;;;2889   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;2890   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;2891   				ofs -= fp->fptr;
;;;2892   				clst = fp->clust;
;;;2893   			} else {									/* When seek to back cluster, */
;;;2894   				clst = fp->sclust;						/* start from the first cluster */
;;;2895   #if !_FS_READONLY
;;;2896   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;2897   					clst = create_chain(fp->fs, 0);
;;;2898   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2899   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2900   					fp->sclust = clst;
;;;2901   				}
;;;2902   #endif
;;;2903   				fp->clust = clst;
;;;2904   			}
;;;2905   			if (clst != 0) {
;;;2906   				while (ofs > bcs) {						/* Cluster following loop */
;;;2907   #if !_FS_READONLY
;;;2908   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
;;;2909   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
;;;2910   						if (clst == 0) {				/* When disk gets full, clip file size */
;;;2911   							ofs = bcs; break;
;;;2912   						}
;;;2913   					} else
;;;2914   #endif
;;;2915   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
;;;2916   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2917   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
;;;2918   					fp->clust = clst;
;;;2919   					fp->fptr += bcs;
;;;2920   					ofs -= bcs;
;;;2921   				}
;;;2922   				fp->fptr += ofs;
;;;2923   				if (ofs % SS(fp->fs)) {
;;;2924   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
;;;2925   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
;;;2926   					nsect += ofs / SS(fp->fs);
;;;2927   				}
;;;2928   			}
;;;2929   		}
;;;2930   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
;;;2931   #if !_FS_TINY
;;;2932   #if !_FS_READONLY
;;;2933   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
;;;2934   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2935   					ABORT(fp->fs, FR_DISK_ERR);
;;;2936   				fp->flag &= ~FA__DIRTY;
;;;2937   			}
;;;2938   #endif
;;;2939   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
;;;2940   				ABORT(fp->fs, FR_DISK_ERR);
;;;2941   #endif
;;;2942   			fp->dsect = nsect;
;;;2943   		}
;;;2944   #if !_FS_READONLY
;;;2945   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;2946   			fp->fsize = fp->fptr;
;;;2947   			fp->flag |= FA__WRITTEN;
;;;2948   		}
;;;2949   #endif
;;;2950   	}
;;;2951   
;;;2952   	LEAVE_FF(fp->fs, res);
;;;2953   }
00001e  e8bd81f0          POP      {r4-r8,pc}
                  |L14.34|
000022  68e0              LDR      r0,[r4,#0xc]          ;2878
000024  42a8              CMP      r0,r5                 ;2878
000026  d202              BCS      |L14.46|
000028  0789              LSLS     r1,r1,#30             ;2880
00002a  d400              BMI      |L14.46|
00002c  4605              MOV      r5,r0                 ;2882
                  |L14.46|
00002e  2700              MOVS     r7,#0                 ;2885
000030  68a0              LDR      r0,[r4,#8]            ;2885
000032  60a7              STR      r7,[r4,#8]            ;2886
000034  b1fd              CBZ      r5,|L14.118|
000036  6822              LDR      r2,[r4,#0]            ;2887
000038  7891              LDRB     r1,[r2,#2]            ;2887
00003a  024e              LSLS     r6,r1,#9              ;2887
00003c  b168              CBZ      r0,|L14.90|
00003e  1e69              SUBS     r1,r5,#1              ;2889
000040  1e40              SUBS     r0,r0,#1              ;2889
000042  fbb1f1f6          UDIV     r1,r1,r6              ;2889
000046  fbb0f3f6          UDIV     r3,r0,r6              ;2889
00004a  4299              CMP      r1,r3                 ;2889
00004c  d305              BCC      |L14.90|
00004e  1e71              SUBS     r1,r6,#1              ;2890
000050  4388              BICS     r0,r0,r1              ;2890
000052  60a0              STR      r0,[r4,#8]            ;2892
000054  1a2d              SUBS     r5,r5,r0              ;2891
000056  6961              LDR      r1,[r4,#0x14]         ;2892
000058  e00c              B        |L14.116|
                  |L14.90|
00005a  6921              LDR      r1,[r4,#0x10]         ;2896
00005c  b949              CBNZ     r1,|L14.114|
00005e  2100              MOVS     r1,#0                 ;2897
000060  4610              MOV      r0,r2                 ;2897
000062  f7fffffe          BL       create_chain
000066  4601              MOV      r1,r0                 ;2897
000068  2801              CMP      r0,#1                 ;2898
00006a  d03f              BEQ      |L14.236|
00006c  1c48              ADDS     r0,r1,#1              ;2899
00006e  d04e              BEQ      |L14.270|
000070  6121              STR      r1,[r4,#0x10]         ;2900
                  |L14.114|
000072  6161              STR      r1,[r4,#0x14]         ;2903
                  |L14.116|
000074  b9d1              CBNZ     r1,|L14.172|
                  |L14.118|
000076  e026              B        |L14.198|
                  |L14.120|
000078  79a0              LDRB     r0,[r4,#6]            ;2908
00007a  0780              LSLS     r0,r0,#30             ;2908
00007c  6820              LDR      r0,[r4,#0]            ;2908
00007e  d505              BPL      |L14.140|
000080  f7fffffe          BL       create_chain
000084  0001              MOVS     r1,r0                 ;2909
000086  d104              BNE      |L14.146|
000088  4635              MOV      r5,r6                 ;2911
00008a  e011              B        |L14.176|
                  |L14.140|
00008c  f7fffffe          BL       get_fat
000090  4601              MOV      r1,r0                 ;2915
                  |L14.146|
000092  1c48              ADDS     r0,r1,#1              ;2916
000094  d03b              BEQ      |L14.270|
000096  2901              CMP      r1,#1                 ;2917
000098  d928              BLS      |L14.236|
00009a  6820              LDR      r0,[r4,#0]            ;2917
00009c  6980              LDR      r0,[r0,#0x18]         ;2917
00009e  4288              CMP      r0,r1                 ;2917
0000a0  d924              BLS      |L14.236|
0000a2  6161              STR      r1,[r4,#0x14]         ;2919
0000a4  68a0              LDR      r0,[r4,#8]            ;2919
0000a6  1bad              SUBS     r5,r5,r6              ;2920
0000a8  4430              ADD      r0,r0,r6              ;2919
0000aa  60a0              STR      r0,[r4,#8]            ;2920
                  |L14.172|
0000ac  42b5              CMP      r5,r6                 ;2906
0000ae  d8e3              BHI      |L14.120|
                  |L14.176|
0000b0  68a0              LDR      r0,[r4,#8]            ;2922
0000b2  4428              ADD      r0,r0,r5              ;2922
0000b4  60a0              STR      r0,[r4,#8]            ;2923
0000b6  05e8              LSLS     r0,r5,#23             ;2923
0000b8  d005              BEQ      |L14.198|
0000ba  6820              LDR      r0,[r4,#0]            ;2924
0000bc  f7fffffe          BL       clust2sect
0000c0  b1a0              CBZ      r0,|L14.236|
0000c2  eb002755          ADD      r7,r0,r5,LSR #9       ;2926
                  |L14.198|
0000c6  68a0              LDR      r0,[r4,#8]            ;2930
0000c8  05c0              LSLS     r0,r0,#23             ;2930
0000ca  d027              BEQ      |L14.284|
0000cc  69a2              LDR      r2,[r4,#0x18]         ;2930
0000ce  42ba              CMP      r2,r7                 ;2930
0000d0  d024              BEQ      |L14.284|
0000d2  79a0              LDRB     r0,[r4,#6]            ;2933
0000d4  f1040524          ADD      r5,r4,#0x24           ;2934
0000d8  0640              LSLS     r0,r0,#25             ;2933
0000da  d510              BPL      |L14.254|
0000dc  6820              LDR      r0,[r4,#0]            ;2934
0000de  2301              MOVS     r3,#1                 ;2934
0000e0  4629              MOV      r1,r5                 ;2934
0000e2  7840              LDRB     r0,[r0,#1]            ;2934
0000e4  f7fffffe          BL       disk_write
0000e8  b988              CBNZ     r0,|L14.270|
0000ea  e004              B        |L14.246|
                  |L14.236|
0000ec  79a0              LDRB     r0,[r4,#6]            ;2925
0000ee  f0400080          ORR      r0,r0,#0x80           ;2925
0000f2  71a0              STRB     r0,[r4,#6]            ;2925
0000f4  e792              B        |L14.28|
                  |L14.246|
0000f6  79a0              LDRB     r0,[r4,#6]            ;2936
0000f8  f0200040          BIC      r0,r0,#0x40           ;2936
0000fc  71a0              STRB     r0,[r4,#6]            ;2936
                  |L14.254|
0000fe  6820              LDR      r0,[r4,#0]            ;2939
000100  2301              MOVS     r3,#1                 ;2939
000102  463a              MOV      r2,r7                 ;2939
000104  7840              LDRB     r0,[r0,#1]            ;2939
000106  4629              MOV      r1,r5                 ;2939
000108  f7fffffe          BL       disk_read
00010c  b128              CBZ      r0,|L14.282|
                  |L14.270|
00010e  79a0              LDRB     r0,[r4,#6]            ;2940
000110  f0400080          ORR      r0,r0,#0x80           ;2940
000114  71a0              STRB     r0,[r4,#6]            ;2940
000116  2001              MOVS     r0,#1                 ;2940
000118  e781              B        |L14.30|
                  |L14.282|
00011a  61a7              STR      r7,[r4,#0x18]         ;2942
                  |L14.284|
00011c  e9d40102          LDRD     r0,r1,[r4,#8]         ;2942
000120  4288              CMP      r0,r1                 ;2945
000122  d904              BLS      |L14.302|
000124  60e0              STR      r0,[r4,#0xc]          ;2947
000126  79a0              LDRB     r0,[r4,#6]            ;2947
000128  f0400020          ORR      r0,r0,#0x20           ;2947
00012c  71a0              STRB     r0,[r4,#6]            ;2947
                  |L14.302|
00012e  4640              MOV      r0,r8                 ;2952
000130  e775              B        |L14.30|
;;;2954   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3257   
;;;3258   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3259   	const TCHAR *path		/* Pointer to the directory path */
;;;3260   )
;;;3261   {
000004  b090              SUB      sp,sp,#0x40
;;;3262   	FRESULT res;
;;;3263   	DIR dj;
;;;3264   	BYTE *dir, n;
;;;3265   	DWORD dsc, dcl, pcl, tim = get_fattime();
000006  f7fffffe          BL       get_fattime
00000a  4607              MOV      r7,r0
;;;3266   	DEF_NAMEBUF;
;;;3267   
;;;3268   
;;;3269   	res = chk_mounted(&path, &dj.fs, 1);
00000c  2201              MOVS     r2,#1
00000e  4669              MOV      r1,sp
000010  a810              ADD      r0,sp,#0x40
000012  f7fffffe          BL       chk_mounted
000016  0004              MOVS     r4,r0
;;;3270   	if (res == FR_OK) {
000018  d109              BNE      |L15.46|
;;;3271   		INIT_BUF(dj);
00001a  a80d              ADD      r0,sp,#0x34
;;;3272   		res = follow_path(&dj, path);			/* Follow the file path */
00001c  9006              STR      r0,[sp,#0x18]
00001e  4668              MOV      r0,sp
000020  9910              LDR      r1,[sp,#0x40]
000022  f7fffffe          BL       follow_path
000026  0004              MOVS     r4,r0
;;;3273   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
000028  d002              BEQ      |L15.48|
;;;3274   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
;;;3275   			res = FR_INVALID_NAME;
;;;3276   		if (res == FR_NO_FILE) {				/* Can create a new directory */
00002a  2c04              CMP      r4,#4
00002c  d002              BEQ      |L15.52|
                  |L15.46|
00002e  e0b0              B        |L15.402|
                  |L15.48|
000030  2408              MOVS     r4,#8                 ;3273
000032  e0ae              B        |L15.402|
                  |L15.52|
;;;3277   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
000034  2100              MOVS     r1,#0
000036  9800              LDR      r0,[sp,#0]
000038  f7fffffe          BL       create_chain
00003c  0006              MOVS     r6,r0
;;;3278   			res = FR_OK;
00003e  f04f0400          MOV      r4,#0
;;;3279   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000042  d002              BEQ      |L15.74|
;;;3280   			if (dcl == 1) res = FR_INT_ERR;
000044  2e01              CMP      r6,#1
000046  d002              BEQ      |L15.78|
000048  e002              B        |L15.80|
                  |L15.74|
00004a  2407              MOVS     r4,#7                 ;3279
00004c  e000              B        |L15.80|
                  |L15.78|
00004e  2402              MOVS     r4,#2
                  |L15.80|
;;;3281   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
000050  1c70              ADDS     r0,r6,#1
000052  d001              BEQ      |L15.88|
;;;3282   			if (res == FR_OK)					/* Flush FAT */
000054  b114              CBZ      r4,|L15.92|
000056  e07d              B        |L15.340|
                  |L15.88|
000058  2401              MOVS     r4,#1                 ;3281
00005a  e07b              B        |L15.340|
                  |L15.92|
;;;3283   				res = move_window(dj.fs, 0);
00005c  2100              MOVS     r1,#0
00005e  9800              LDR      r0,[sp,#0]
000060  f7fffffe          BL       move_window
000064  0004              MOVS     r4,r0
;;;3284   			if (res == FR_OK) {					/* Initialize the new directory table */
000066  d175              BNE      |L15.340|
;;;3285   				dsc = clust2sect(dj.fs, dcl);
000068  4631              MOV      r1,r6
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       clust2sect
;;;3286   				dir = dj.fs->win;
000070  9d00              LDR      r5,[sp,#0]
000072  4680              MOV      r8,r0                 ;3285
000074  3530              ADDS     r5,r5,#0x30
;;;3287   				mem_set(dir, 0, SS(dj.fs));
000076  f44f7200          MOV      r2,#0x200
00007a  2100              MOVS     r1,#0
00007c  4628              MOV      r0,r5
00007e  f7fffffe          BL       mem_set
;;;3288   				mem_set(dir+DIR_Name, ' ', 8+3);	/* Create "." entry */
000082  220b              MOVS     r2,#0xb
000084  2120              MOVS     r1,#0x20
000086  4628              MOV      r0,r5
000088  f7fffffe          BL       mem_set
;;;3289   				dir[DIR_Name] = '.';
00008c  242e              MOVS     r4,#0x2e
00008e  702c              STRB     r4,[r5,#0]
;;;3290   				dir[DIR_Attr] = AM_DIR;
000090  2010              MOVS     r0,#0x10
000092  72e8              STRB     r0,[r5,#0xb]
;;;3291   				ST_DWORD(dir+DIR_WrtTime, tim);
000094  b2f8              UXTB     r0,r7
000096  9007              STR      r0,[sp,#0x1c]
000098  75a8              STRB     r0,[r5,#0x16]
00009a  f3c72007          UBFX     r0,r7,#8,#8
00009e  9008              STR      r0,[sp,#0x20]
0000a0  75e8              STRB     r0,[r5,#0x17]
0000a2  f3c74007          UBFX     r0,r7,#16,#8
0000a6  9009              STR      r0,[sp,#0x24]
0000a8  7628              STRB     r0,[r5,#0x18]
0000aa  0e38              LSRS     r0,r7,#24
0000ac  900a              STR      r0,[sp,#0x28]
0000ae  7668              STRB     r0,[r5,#0x19]
;;;3292   				ST_CLUST(dir, dcl);
0000b0  f0060aff          AND      r10,r6,#0xff
0000b4  f885a01a          STRB     r10,[r5,#0x1a]
0000b8  f3c62007          UBFX     r0,r6,#8,#8
0000bc  900b              STR      r0,[sp,#0x2c]
0000be  76e8              STRB     r0,[r5,#0x1b]
0000c0  f3c64007          UBFX     r0,r6,#16,#8
0000c4  900c              STR      r0,[sp,#0x30]
0000c6  7528              STRB     r0,[r5,#0x14]
0000c8  ea4f6b16          LSR      r11,r6,#24
0000cc  f885b015          STRB     r11,[r5,#0x15]
;;;3293   				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
0000d0  2220              MOVS     r2,#0x20
0000d2  4629              MOV      r1,r5
0000d4  f1050020          ADD      r0,r5,#0x20
0000d8  f7fffffe          BL       mem_cpy
;;;3294   				dir[33] = '.'; pcl = dj.sclust;
0000dc  f8854021          STRB     r4,[r5,#0x21]
;;;3295   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000e0  9900              LDR      r1,[sp,#0]
0000e2  9802              LDR      r0,[sp,#8]
0000e4  7809              LDRB     r1,[r1,#0]
0000e6  2903              CMP      r1,#3
0000e8  d104              BNE      |L15.244|
0000ea  9900              LDR      r1,[sp,#0]
0000ec  6a49              LDR      r1,[r1,#0x24]
0000ee  4281              CMP      r1,r0
0000f0  d100              BNE      |L15.244|
;;;3296   					pcl = 0;
0000f2  2000              MOVS     r0,#0
                  |L15.244|
0000f4  f1050534          ADD      r5,r5,#0x34
;;;3297   				ST_CLUST(dir+SZ_DIR, pcl);
0000f8  ea4f2110          LSR      r1,r0,#8
0000fc  71a8              STRB     r0,[r5,#6]
0000fe  71e9              STRB     r1,[r5,#7]
000100  ea4f4110          LSR      r1,r0,#16
000104  7029              STRB     r1,[r5,#0]
000106  ea4f6010          LSR      r0,r0,#24
00010a  7068              STRB     r0,[r5,#1]
;;;3298   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
00010c  9800              LDR      r0,[sp,#0]
00010e  f1a50534          SUB      r5,r5,#0x34           ;3297
000112  f04f0901          MOV      r9,#1                 ;3269
000116  7887              LDRB     r7,[r0,#2]
000118  e015              B        |L15.326|
                  |L15.282|
;;;3299   					dj.fs->winsect = dsc++;
00011a  9900              LDR      r1,[sp,#0]
00011c  f8c1802c          STR      r8,[r1,#0x2c]
;;;3300   					dj.fs->wflag = 1;
000120  9900              LDR      r1,[sp,#0]
000122  f1080801          ADD      r8,r8,#1              ;3299
000126  f8819004          STRB     r9,[r1,#4]
;;;3301   					res = move_window(dj.fs, 0);
00012a  2100              MOVS     r1,#0
00012c  9800              LDR      r0,[sp,#0]
00012e  f7fffffe          BL       move_window
000132  0004              MOVS     r4,r0
;;;3302   					if (res != FR_OK) break;
000134  d10e              BNE      |L15.340|
;;;3303   					mem_set(dir, 0, SS(dj.fs));
000136  f44f7200          MOV      r2,#0x200
00013a  2100              MOVS     r1,#0
00013c  4628              MOV      r0,r5
00013e  f7fffffe          BL       mem_set
000142  1e7f              SUBS     r7,r7,#1              ;3298
000144  b2ff              UXTB     r7,r7                 ;3298
                  |L15.326|
000146  2f00              CMP      r7,#0                 ;3298
000148  d1e7              BNE      |L15.282|
;;;3304   				}
;;;3305   			}
;;;3306   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
00014a  4668              MOV      r0,sp
00014c  f7fffffe          BL       dir_register
000150  0004              MOVS     r4,r0
;;;3307   			if (res != FR_OK) {
000152  d004              BEQ      |L15.350|
                  |L15.340|
;;;3308   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
000154  4631              MOV      r1,r6
000156  9800              LDR      r0,[sp,#0]
000158  f7fffffe          BL       remove_chain
00015c  e019              B        |L15.402|
                  |L15.350|
;;;3309   			} else {
;;;3310   				dir = dj.dir;
;;;3311   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
00015e  9805              LDR      r0,[sp,#0x14]
000160  2110              MOVS     r1,#0x10
000162  72c1              STRB     r1,[r0,#0xb]
;;;3312   				ST_DWORD(dir+DIR_WrtTime, tim);		/* Created time */
000164  9907              LDR      r1,[sp,#0x1c]
000166  7581              STRB     r1,[r0,#0x16]
000168  9908              LDR      r1,[sp,#0x20]
00016a  75c1              STRB     r1,[r0,#0x17]
00016c  9909              LDR      r1,[sp,#0x24]
00016e  7601              STRB     r1,[r0,#0x18]
000170  990a              LDR      r1,[sp,#0x28]
000172  7641              STRB     r1,[r0,#0x19]
;;;3313   				ST_CLUST(dir, dcl);					/* Table start cluster */
000174  f880a01a          STRB     r10,[r0,#0x1a]
000178  990b              LDR      r1,[sp,#0x2c]
00017a  76c1              STRB     r1,[r0,#0x1b]
00017c  990c              LDR      r1,[sp,#0x30]
00017e  7501              STRB     r1,[r0,#0x14]
000180  f880b015          STRB     r11,[r0,#0x15]
;;;3314   				dj.fs->wflag = 1;
000184  9900              LDR      r1,[sp,#0]
000186  f8819004          STRB     r9,[r1,#4]
;;;3315   				res = sync(dj.fs);
00018a  9800              LDR      r0,[sp,#0]
00018c  f7fffffe          BL       sync
000190  4604              MOV      r4,r0
                  |L15.402|
;;;3316   			}
;;;3317   		}
;;;3318   		FREE_BUF();
;;;3319   	}
;;;3320   
;;;3321   	LEAVE_FF(dj.fs, res);
;;;3322   }
000192  b011              ADD      sp,sp,#0x44
000194  4620              MOV      r0,r4                 ;3321
000196  e8bd8ff0          POP      {r4-r11,pc}
;;;3323   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2202   
;;;2203   FRESULT f_mount (
000000  b108              CBZ      r0,|L16.6|
;;;2204   	BYTE vol,		/* Logical drive number to be mounted/unmounted */
;;;2205   	FATFS *fs		/* Pointer to new file system object (NULL for unmount)*/
;;;2206   )
;;;2207   {
;;;2208   	FATFS *rfs;
;;;2209   
;;;2210   
;;;2211   	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
;;;2212   		return FR_INVALID_DRIVE;
000002  200b              MOVS     r0,#0xb
;;;2213   	rfs = FatFs[vol];			/* Get current fs object */
;;;2214   
;;;2215   	if (rfs) {
;;;2216   #if _FS_SHARE
;;;2217   		clear_lock(rfs);
;;;2218   #endif
;;;2219   #if _FS_REENTRANT				/* Discard sync object of the current volume */
;;;2220   		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
;;;2221   #endif
;;;2222   		rfs->fs_type = 0;		/* Clear old fs object */
;;;2223   	}
;;;2224   
;;;2225   	if (fs) {
;;;2226   		fs->fs_type = 0;		/* Clear new fs object */
;;;2227   #if _FS_REENTRANT				/* Create sync object for the new volume */
;;;2228   		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
;;;2229   #endif
;;;2230   	}
;;;2231   	FatFs[vol] = fs;			/* Register new fs object */
;;;2232   
;;;2233   	return FR_OK;
;;;2234   }
000004  4770              BX       lr
                  |L16.6|
000006  4b05              LDR      r3,|L16.28|
000008  2200              MOVS     r2,#0                 ;2207
00000a  6818              LDR      r0,[r3,#0]            ;2215
00000c  b100              CBZ      r0,|L16.16|
00000e  7002              STRB     r2,[r0,#0]            ;2222
                  |L16.16|
000010  b101              CBZ      r1,|L16.20|
000012  700a              STRB     r2,[r1,#0]            ;2226
                  |L16.20|
000014  2000              MOVS     r0,#0                 ;2233
000016  6019              STR      r1,[r3,#0]            ;2233
000018  4770              BX       lr
;;;2235   
                          ENDP

00001a  0000              DCW      0x0000
                  |L16.28|
                          DCD      ||.data||+0x4

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=1

                  f_open PROC
;;;2242   
;;;2243   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2244   	FIL *fp,			/* Pointer to the blank file object */
;;;2245   	const TCHAR *path,	/* Pointer to the file name */
;;;2246   	BYTE mode			/* Access mode and file open mode flags */
;;;2247   )
;;;2248   {
000004  b08b              SUB      sp,sp,#0x2c
;;;2249   	FRESULT res;
;;;2250   	DIR dj;
;;;2251   	BYTE *dir;
;;;2252   	DEF_NAMEBUF;
;;;2253   
;;;2254   
;;;2255   	fp->fs = 0;			/* Clear file object */
000006  f04f0900          MOV      r9,#0
00000a  4607              MOV      r7,r0                 ;2248
;;;2256   
;;;2257   #if !_FS_READONLY
;;;2258   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
00000c  f002061f          AND      r6,r2,#0x1f
;;;2259   	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
000010  f8c09000          STR      r9,[r0,#0]
000014  f0260201          BIC      r2,r6,#1
000018  4669              MOV      r1,sp
00001a  a80c              ADD      r0,sp,#0x30
00001c  f7fffffe          BL       chk_mounted
000020  0005              MOVS     r5,r0
;;;2260   #else
;;;2261   	mode &= FA_READ;
;;;2262   	res = chk_mounted(&path, &dj.fs, 0);
;;;2263   #endif
;;;2264   	INIT_BUF(dj);
000022  a807              ADD      r0,sp,#0x1c
;;;2265   	if (res == FR_OK)
000024  9006              STR      r0,[sp,#0x18]
000026  d104              BNE      |L17.50|
;;;2266   		res = follow_path(&dj, path);	/* Follow the file path */
000028  4668              MOV      r0,sp
00002a  990c              LDR      r1,[sp,#0x30]
00002c  f7fffffe          BL       follow_path
000030  4605              MOV      r5,r0
                  |L17.50|
;;;2267   	dir = dj.dir;
;;;2268   
;;;2269   #if !_FS_READONLY	/* R/W configuration */
;;;2270   	if (res == FR_OK) {
000032  9c05              LDR      r4,[sp,#0x14]
000034  b90d              CBNZ     r5,|L17.58|
;;;2271   		if (!dir)	/* Current dir itself */
000036  b904              CBNZ     r4,|L17.58|
;;;2272   			res = FR_INVALID_NAME;
000038  2506              MOVS     r5,#6
                  |L17.58|
;;;2273   #if _FS_SHARE
;;;2274   		else
;;;2275   			res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2276   #endif
;;;2277   	}
;;;2278   	/* Create or Open a file */
;;;2279   	if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
00003a  f0160f1c          TST      r6,#0x1c
00003e  d04d              BEQ      |L17.220|
;;;2280   		DWORD dw, cl;
;;;2281   
;;;2282   		if (res != FR_OK) {					/* No file, create new */
000040  b155              CBZ      r5,|L17.88|
;;;2283   			if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
000042  2d04              CMP      r5,#4
000044  d103              BNE      |L17.78|
;;;2284   #if _FS_SHARE
;;;2285   				res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2286   #else
;;;2287   				res = dir_register(&dj);
000046  4668              MOV      r0,sp
000048  f7fffffe          BL       dir_register
00004c  4605              MOV      r5,r0
                  |L17.78|
;;;2288   #endif
;;;2289   			mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2290   			dir = dj.dir;					/* New entry */
;;;2291   		}
;;;2292   		else {								/* Any object is already existing */
;;;2293   			if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2294   				res = FR_DENIED;
;;;2295   			} else {
;;;2296   				if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2297   					res = FR_EXIST;
;;;2298   			}
;;;2299   		}
;;;2300   		if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
00004e  9c05              LDR      r4,[sp,#0x14]
000050  f0460608          ORR      r6,r6,#8              ;2289
000054  b145              CBZ      r5,|L17.104|
000056  e069              B        |L17.300|
                  |L17.88|
000058  7ae0              LDRB     r0,[r4,#0xb]          ;2293
00005a  f0100f11          TST      r0,#0x11              ;2293
00005e  d147              BNE      |L17.240|
000060  0770              LSLS     r0,r6,#29             ;2296
000062  d501              BPL      |L17.104|
000064  2508              MOVS     r5,#8                 ;2297
000066  e061              B        |L17.300|
                  |L17.104|
000068  0730              LSLS     r0,r6,#28
00006a  d547              BPL      |L17.252|
;;;2301   			dw = get_fattime();					/* Created time */
00006c  f7fffffe          BL       get_fattime
;;;2302   			ST_DWORD(dir+DIR_CrtTime, dw);
000070  73a0              STRB     r0,[r4,#0xe]
000072  0a01              LSRS     r1,r0,#8
000074  73e1              STRB     r1,[r4,#0xf]
000076  0c01              LSRS     r1,r0,#16
000078  7421              STRB     r1,[r4,#0x10]
00007a  0e00              LSRS     r0,r0,#24
00007c  7460              STRB     r0,[r4,#0x11]
;;;2303   			dir[DIR_Attr] = 0;					/* Reset attribute */
00007e  f884900b          STRB     r9,[r4,#0xb]
;;;2304   			ST_DWORD(dir+DIR_FileSize, 0);		/* size = 0 */
000082  f884901c          STRB     r9,[r4,#0x1c]
000086  f884901d          STRB     r9,[r4,#0x1d]
00008a  f884901e          STRB     r9,[r4,#0x1e]
00008e  f884901f          STRB     r9,[r4,#0x1f]
;;;2305   			cl = LD_CLUST(dir);					/* Get start cluster */
000092  8aa2              LDRH     r2,[r4,#0x14]
000094  8b61              LDRH     r1,[r4,#0x1a]
;;;2306   			ST_CLUST(dir, 0);					/* cluster = 0 */
000096  f884901a          STRB     r9,[r4,#0x1a]
00009a  f884901b          STRB     r9,[r4,#0x1b]
00009e  f362411f          BFI      r1,r2,#16,#16         ;2305
0000a2  f8849014          STRB     r9,[r4,#0x14]
0000a6  4688              MOV      r8,r1                 ;2305
0000a8  f8849015          STRB     r9,[r4,#0x15]
;;;2307   			dj.fs->wflag = 1;
0000ac  9900              LDR      r1,[sp,#0]
0000ae  2001              MOVS     r0,#1
0000b0  7108              STRB     r0,[r1,#4]
;;;2308   			if (cl) {							/* Remove the cluster chain if exist */
0000b2  ea5f0108          MOVS     r1,r8
0000b6  d01f              BEQ      |L17.248|
;;;2309   				dw = dj.fs->winsect;
0000b8  9800              LDR      r0,[sp,#0]
;;;2310   				res = remove_chain(dj.fs, cl);
0000ba  f8d0a02c          LDR      r10,[r0,#0x2c]
0000be  f7fffffe          BL       remove_chain
0000c2  0005              MOVS     r5,r0
;;;2311   				if (res == FR_OK) {
0000c4  d132              BNE      |L17.300|
;;;2312   					dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
0000c6  9900              LDR      r1,[sp,#0]
0000c8  f1a80001          SUB      r0,r8,#1
;;;2313   					res = move_window(dj.fs, dw);
0000cc  60c8              STR      r0,[r1,#0xc]
0000ce  4651              MOV      r1,r10
0000d0  9800              LDR      r0,[sp,#0]
0000d2  f7fffffe          BL       move_window
0000d6  0005              MOVS     r5,r0
;;;2314   				}
;;;2315   			}
;;;2316   		}
;;;2317   	}
;;;2318   	else {	/* Open an existing file */
;;;2319   		if (res == FR_OK) {						/* Follow succeeded */
;;;2320   			if (dir[DIR_Attr] & AM_DIR) {		/* It is a directory */
;;;2321   				res = FR_NO_FILE;
;;;2322   			} else {
;;;2323   				if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2324   					res = FR_DENIED;
;;;2325   			}
;;;2326   		}
;;;2327   	}
;;;2328   	if (res == FR_OK) {
0000d8  d00c              BEQ      |L17.244|
0000da  e027              B        |L17.300|
                  |L17.220|
0000dc  bb35              CBNZ     r5,|L17.300|
0000de  7ae0              LDRB     r0,[r4,#0xb]          ;2320
0000e0  06c1              LSLS     r1,r0,#27             ;2320
0000e2  d501              BPL      |L17.232|
0000e4  2504              MOVS     r5,#4                 ;2321
0000e6  e021              B        |L17.300|
                  |L17.232|
0000e8  07b1              LSLS     r1,r6,#30             ;2323
0000ea  d503              BPL      |L17.244|
0000ec  07c0              LSLS     r0,r0,#31             ;2323
0000ee  d001              BEQ      |L17.244|
                  |L17.240|
0000f0  2507              MOVS     r5,#7                 ;2324
0000f2  e01b              B        |L17.300|
                  |L17.244|
;;;2329   		if (mode & FA_CREATE_ALWAYS)			/* Set file change flag if created or overwritten */
0000f4  0730              LSLS     r0,r6,#28
0000f6  d501              BPL      |L17.252|
                  |L17.248|
;;;2330   			mode |= FA__WRITTEN;
0000f8  f0460620          ORR      r6,r6,#0x20
                  |L17.252|
;;;2331   		fp->dir_sect = dj.fs->winsect;			/* Pointer to the directory entry */
0000fc  9800              LDR      r0,[sp,#0]
0000fe  6ac0              LDR      r0,[r0,#0x2c]
000100  e9c70407          STRD     r0,r4,[r7,#0x1c]
;;;2332   		fp->dir_ptr = dir;
;;;2333   #if _FS_SHARE
;;;2334   		fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2335   		if (!fp->lockid) res = FR_INT_ERR;
;;;2336   #endif
;;;2337   	}
;;;2338   
;;;2339   #else				/* R/O configuration */
;;;2340   	if (res == FR_OK) {					/* Follow succeeded */
;;;2341   		if (!dir) {						/* Current dir itself */
;;;2342   			res = FR_INVALID_NAME;
;;;2343   		} else {
;;;2344   			if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2345   				res = FR_NO_FILE;
;;;2346   		}
;;;2347   	}
;;;2348   #endif
;;;2349   	FREE_BUF();
;;;2350   
;;;2351   	if (res == FR_OK) {
;;;2352   		fp->flag = mode;					/* File access mode */
000104  71be              STRB     r6,[r7,#6]
;;;2353   		fp->sclust = LD_CLUST(dir);			/* File start cluster */
000106  8aa1              LDRH     r1,[r4,#0x14]
000108  8b60              LDRH     r0,[r4,#0x1a]
00010a  f361401f          BFI      r0,r1,#16,#16
;;;2354   		fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
00010e  6138              STR      r0,[r7,#0x10]
000110  7f20              LDRB     r0,[r4,#0x1c]
000112  f8d4101d          LDR      r1,[r4,#0x1d]
000116  ea402001          ORR      r0,r0,r1,LSL #8
;;;2355   		fp->fptr = 0;						/* File pointer */
;;;2356   		fp->dsect = 0;
00011a  e9c79002          STRD     r9,r0,[r7,#8]
;;;2357   #if _USE_FASTSEEK
;;;2358   		fp->cltbl = 0;						/* Normal seek mode */
;;;2359   #endif
;;;2360   		fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
00011e  f8c79018          STR      r9,[r7,#0x18]
000122  9800              LDR      r0,[sp,#0]
000124  6038              STR      r0,[r7,#0]
000126  9800              LDR      r0,[sp,#0]
000128  88c0              LDRH     r0,[r0,#6]
00012a  80b8              STRH     r0,[r7,#4]
                  |L17.300|
;;;2361   	}
;;;2362   
;;;2363   	LEAVE_FF(dj.fs, res);
;;;2364   }
00012c  b00e              ADD      sp,sp,#0x38
00012e  4628              MOV      r0,r5                 ;2363
000130  e8bd87f0          POP      {r4-r10,pc}
;;;2365   
                          ENDP


                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;2961   
;;;2962   FRESULT f_opendir (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;2963   	DIR *dj,			/* Pointer to directory object to create */
;;;2964   	const TCHAR *path	/* Pointer to the directory path */
;;;2965   )
;;;2966   {
000002  b084              SUB      sp,sp,#0x10
000004  4604              MOV      r4,r0
;;;2967   	FRESULT res;
;;;2968   	DEF_NAMEBUF;
;;;2969   
;;;2970   
;;;2971   	res = chk_mounted(&path, &dj->fs, 0);
000006  4601              MOV      r1,r0
000008  2200              MOVS     r2,#0
00000a  a805              ADD      r0,sp,#0x14
00000c  f7fffffe          BL       chk_mounted
;;;2972   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d11a              BNE      |L18.74|
;;;2973   		INIT_BUF(*dj);
000014  f8c4d018          STR      sp,[r4,#0x18]
;;;2974   		res = follow_path(dj, path);			/* Follow the path to the directory */
000018  4620              MOV      r0,r4
00001a  9905              LDR      r1,[sp,#0x14]
00001c  f7fffffe          BL       follow_path
;;;2975   		FREE_BUF();
;;;2976   		if (res == FR_OK) {						/* Follow completed */
000020  b980              CBNZ     r0,|L18.68|
;;;2977   			if (dj->dir) {						/* It is not the root dir */
000022  6960              LDR      r0,[r4,#0x14]
000024  b138              CBZ      r0,|L18.54|
;;;2978   				if (dj->dir[DIR_Attr] & AM_DIR) {	/* The object is a directory */
000026  7ac1              LDRB     r1,[r0,#0xb]
000028  06c9              LSLS     r1,r1,#27
00002a  d50d              BPL      |L18.72|
;;;2979   					dj->sclust = LD_CLUST(dj->dir);
00002c  8a81              LDRH     r1,[r0,#0x14]
00002e  8b40              LDRH     r0,[r0,#0x1a]
000030  f361401f          BFI      r0,r1,#16,#16
000034  60a0              STR      r0,[r4,#8]
                  |L18.54|
;;;2980   				} else {						/* The object is not a directory */
;;;2981   					res = FR_NO_PATH;
;;;2982   				}
;;;2983   			}
;;;2984   			if (res == FR_OK) {
;;;2985   				dj->id = dj->fs->id;
000036  6820              LDR      r0,[r4,#0]
;;;2986   				res = dir_sdi(dj, 0);			/* Rewind dir */
000038  2100              MOVS     r1,#0
00003a  88c0              LDRH     r0,[r0,#6]            ;2985
00003c  80a0              STRH     r0,[r4,#4]            ;2985
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       dir_sdi
                  |L18.68|
;;;2987   			}
;;;2988   		}
;;;2989   		if (res == FR_NO_FILE) res = FR_NO_PATH;
000044  2804              CMP      r0,#4
000046  d100              BNE      |L18.74|
                  |L18.72|
000048  2005              MOVS     r0,#5
                  |L18.74|
;;;2990   	}
;;;2991   
;;;2992   	LEAVE_FF(dj->fs, res);
;;;2993   }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd10              POP      {r4,pc}
;;;2994   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2372   
;;;2373   FRESULT f_read (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2374   	FIL *fp, 		/* Pointer to the file object */
;;;2375   	void *buff,		/* Pointer to data buffer */
;;;2376   	UINT btr,		/* Number of bytes to read */
;;;2377   	UINT *br		/* Pointer to number of bytes read */
;;;2378   )
;;;2379   {
;;;2380   	FRESULT res;
;;;2381   	DWORD clst, sect, remain;
;;;2382   	UINT rcnt, cc;
;;;2383   	BYTE csect, *rbuff = buff;
000004  4689              MOV      r9,r1
;;;2384   
;;;2385   
;;;2386   	*br = 0;	/* Initialize byte counter */
000006  2100              MOVS     r1,#0
;;;2387   
;;;2388   	res = validate(fp->fs, fp->id);				/* Check validity */
000008  6019              STR      r1,[r3,#0]
00000a  4604              MOV      r4,r0                 ;2379
00000c  8881              LDRH     r1,[r0,#4]
00000e  4616              MOV      r6,r2                 ;2379
000010  469a              MOV      r10,r3                ;2379
000012  6800              LDR      r0,[r0,#0]
000014  f7fffffe          BL       validate
;;;2389   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d103              BNE      |L19.36|
;;;2390   	if (fp->flag & FA__ERROR)					/* Aborted file? */
00001c  79a0              LDRB     r0,[r4,#6]
00001e  0601              LSLS     r1,r0,#24
000020  d502              BPL      |L19.40|
                  |L19.34|
;;;2391   		LEAVE_FF(fp->fs, FR_INT_ERR);
000022  2002              MOVS     r0,#2
                  |L19.36|
;;;2392   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
;;;2393   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2394   	remain = fp->fsize - fp->fptr;
;;;2395   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2396   
;;;2397   	for ( ;  btr;								/* Repeat until all data read */
;;;2398   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2399   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2400   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2401   			if (!csect) {						/* On the cluster boundary? */
;;;2402   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2403   					clst = fp->sclust;			/* Follow from the origin */
;;;2404   				} else {						/* Middle or end of the file */
;;;2405   #if _USE_FASTSEEK
;;;2406   					if (fp->cltbl)
;;;2407   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2408   					else
;;;2409   #endif
;;;2410   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2411   				}
;;;2412   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2413   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2414   				fp->clust = clst;				/* Update current cluster */
;;;2415   			}
;;;2416   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2417   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2418   			sect += csect;
;;;2419   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2420   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2421   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2422   					cc = fp->fs->csize - csect;
;;;2423   				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
;;;2424   					ABORT(fp->fs, FR_DISK_ERR);
;;;2425   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2426   #if _FS_TINY
;;;2427   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2428   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2429   #else
;;;2430   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2431   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
;;;2432   #endif
;;;2433   #endif
;;;2434   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2435   				continue;
;;;2436   			}
;;;2437   #if !_FS_TINY
;;;2438   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2439   #if !_FS_READONLY
;;;2440   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2441   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2442   						ABORT(fp->fs, FR_DISK_ERR);
;;;2443   					fp->flag &= ~FA__DIRTY;
;;;2444   				}
;;;2445   #endif
;;;2446   				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
;;;2447   					ABORT(fp->fs, FR_DISK_ERR);
;;;2448   			}
;;;2449   #endif
;;;2450   			fp->dsect = sect;
;;;2451   		}
;;;2452   		rcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2453   		if (rcnt > btr) rcnt = btr;
;;;2454   #if _FS_TINY
;;;2455   		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
;;;2456   			ABORT(fp->fs, FR_DISK_ERR);
;;;2457   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2458   #else
;;;2459   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2460   #endif
;;;2461   	}
;;;2462   
;;;2463   	LEAVE_FF(fp->fs, FR_OK);
;;;2464   }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L19.40|
000028  07c0              LSLS     r0,r0,#31             ;2392
00002a  d008              BEQ      |L19.62|
00002c  e9d41002          LDRD     r1,r0,[r4,#8]         ;2392
000030  1a40              SUBS     r0,r0,r1              ;2394
000032  f1040b24          ADD      r11,r4,#0x24          ;2431
000036  4286              CMP      r6,r0                 ;2395
000038  d900              BLS      |L19.60|
00003a  4606              MOV      r6,r0                 ;2395
                  |L19.60|
00003c  e07e              B        |L19.316|
                  |L19.62|
00003e  2007              MOVS     r0,#7                 ;2393
000040  e7f0              B        |L19.36|
                  |L19.66|
000042  68a0              LDR      r0,[r4,#8]            ;2399
000044  05c1              LSLS     r1,r0,#23             ;2399
000046  d161              BNE      |L19.268|
000048  6822              LDR      r2,[r4,#0]            ;2400
00004a  7891              LDRB     r1,[r2,#2]            ;2400
00004c  1e49              SUBS     r1,r1,#1              ;2400
00004e  ea012150          AND      r1,r1,r0,LSR #9       ;2400
000052  f01107ff          ANDS     r7,r1,#0xff           ;2400
000056  d109              BNE      |L19.108|
000058  b1f8              CBZ      r0,|L19.154|
00005a  4610              MOV      r0,r2                 ;2410
00005c  6961              LDR      r1,[r4,#0x14]         ;2410
00005e  f7fffffe          BL       get_fat
                  |L19.98|
000062  2802              CMP      r0,#2                 ;2412
000064  d31b              BCC      |L19.158|
000066  1c41              ADDS     r1,r0,#1              ;2413
000068  d048              BEQ      |L19.252|
00006a  6160              STR      r0,[r4,#0x14]         ;2414
                  |L19.108|
00006c  6961              LDR      r1,[r4,#0x14]         ;2416
00006e  6820              LDR      r0,[r4,#0]            ;2416
000070  f7fffffe          BL       clust2sect
000074  b198              CBZ      r0,|L19.158|
000076  eb000807          ADD      r8,r0,r7              ;2418
00007a  0a75              LSRS     r5,r6,#9              ;2419
00007c  d025              BEQ      |L19.202|
00007e  6821              LDR      r1,[r4,#0]            ;2421
000080  197a              ADDS     r2,r7,r5              ;2421
000082  7888              LDRB     r0,[r1,#2]            ;2421
000084  4282              CMP      r2,r0                 ;2421
000086  d900              BLS      |L19.138|
000088  1bc5              SUBS     r5,r0,r7              ;2422
                  |L19.138|
00008a  7848              LDRB     r0,[r1,#1]            ;2423
00008c  b2eb              UXTB     r3,r5                 ;2423
00008e  4642              MOV      r2,r8                 ;2423
000090  4649              MOV      r1,r9                 ;2423
000092  f7fffffe          BL       disk_read
000096  bb88              CBNZ     r0,|L19.252|
000098  e006              B        |L19.168|
                  |L19.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;2403
00009c  e7e1              B        |L19.98|
                  |L19.158|
00009e  79a0              LDRB     r0,[r4,#6]            ;2417
0000a0  f0400080          ORR      r0,r0,#0x80           ;2417
0000a4  71a0              STRB     r0,[r4,#6]            ;2417
0000a6  e7bc              B        |L19.34|
                  |L19.168|
0000a8  79a0              LDRB     r0,[r4,#6]            ;2430
0000aa  0640              LSLS     r0,r0,#25             ;2430
0000ac  d50b              BPL      |L19.198|
0000ae  69a1              LDR      r1,[r4,#0x18]         ;2430
0000b0  eba10008          SUB      r0,r1,r8              ;2430
0000b4  42a8              CMP      r0,r5                 ;2430
0000b6  d206              BCS      |L19.198|
0000b8  eb092040          ADD      r0,r9,r0,LSL #9       ;2431
0000bc  f44f7200          MOV      r2,#0x200             ;2431
0000c0  4659              MOV      r1,r11                ;2431
0000c2  f7fffffe          BL       mem_cpy
                  |L19.198|
0000c6  026d              LSLS     r5,r5,#9              ;2434
0000c8  e02e              B        |L19.296|
                  |L19.202|
0000ca  69a2              LDR      r2,[r4,#0x18]         ;2438
0000cc  4542              CMP      r2,r8                 ;2438
0000ce  d01b              BEQ      |L19.264|
0000d0  79a0              LDRB     r0,[r4,#6]            ;2440
0000d2  0640              LSLS     r0,r0,#25             ;2440
0000d4  d50a              BPL      |L19.236|
0000d6  6820              LDR      r0,[r4,#0]            ;2441
0000d8  2301              MOVS     r3,#1                 ;2441
0000da  4659              MOV      r1,r11                ;2441
0000dc  7840              LDRB     r0,[r0,#1]            ;2441
0000de  f7fffffe          BL       disk_write
0000e2  b958              CBNZ     r0,|L19.252|
0000e4  79a0              LDRB     r0,[r4,#6]            ;2443
0000e6  f0200040          BIC      r0,r0,#0x40           ;2443
0000ea  71a0              STRB     r0,[r4,#6]            ;2443
                  |L19.236|
0000ec  6820              LDR      r0,[r4,#0]            ;2446
0000ee  2301              MOVS     r3,#1                 ;2446
0000f0  4642              MOV      r2,r8                 ;2446
0000f2  7840              LDRB     r0,[r0,#1]            ;2446
0000f4  4659              MOV      r1,r11                ;2446
0000f6  f7fffffe          BL       disk_read
0000fa  b128              CBZ      r0,|L19.264|
                  |L19.252|
0000fc  79a0              LDRB     r0,[r4,#6]            ;2447
0000fe  f0400080          ORR      r0,r0,#0x80           ;2447
000102  71a0              STRB     r0,[r4,#6]            ;2447
000104  2001              MOVS     r0,#1                 ;2447
000106  e78d              B        |L19.36|
                  |L19.264|
000108  f8c48018          STR      r8,[r4,#0x18]         ;2450
                  |L19.268|
00010c  68a0              LDR      r0,[r4,#8]            ;2452
00010e  f3c00008          UBFX     r0,r0,#0,#9           ;2452
000112  f5c07500          RSB      r5,r0,#0x200          ;2452
000116  42b5              CMP      r5,r6                 ;2453
000118  d900              BLS      |L19.284|
00011a  4635              MOV      r5,r6                 ;2453
                  |L19.284|
00011c  1901              ADDS     r1,r0,r4              ;2459
00011e  3124              ADDS     r1,r1,#0x24           ;2459
000120  462a              MOV      r2,r5                 ;2459
000122  4648              MOV      r0,r9                 ;2459
000124  f7fffffe          BL       mem_cpy
                  |L19.296|
000128  68a0              LDR      r0,[r4,#8]            ;2398
00012a  44a9              ADD      r9,r9,r5              ;2398
00012c  4428              ADD      r0,r0,r5              ;2398
00012e  60a0              STR      r0,[r4,#8]            ;2398
000130  f8da0000          LDR      r0,[r10,#0]           ;2398
000134  1941              ADDS     r1,r0,r5              ;2398
000136  1b76              SUBS     r6,r6,r5              ;2398
000138  f8ca1000          STR      r1,[r10,#0]           ;2398
                  |L19.316|
00013c  2e00              CMP      r6,#0                 ;2397
00013e  d180              BNE      |L19.66|
000140  2000              MOVS     r0,#0                 ;2463
000142  e76f              B        |L19.36|
;;;2465   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3001   
;;;3002   FRESULT f_readdir (
000000  b5fe              PUSH     {r1-r7,lr}
;;;3003   	DIR *dj,			/* Pointer to the open directory object */
;;;3004   	FILINFO *fno		/* Pointer to file information to return */
;;;3005   )
;;;3006   {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;3007   	FRESULT res;
;;;3008   	DEF_NAMEBUF;
;;;3009   
;;;3010   
;;;3011   	res = validate(dj->fs, dj->id);			/* Check validity of the object */
000006  8881              LDRH     r1,[r0,#4]
000008  6800              LDR      r0,[r0,#0]
00000a  f7fffffe          BL       validate
;;;3012   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d116              BNE      |L20.64|
;;;3013   		if (!fno) {
000012  b1b5              CBZ      r5,|L20.66|
;;;3014   			res = dir_sdi(dj, 0);			/* Rewind the directory object */
;;;3015   		} else {
;;;3016   			INIT_BUF(*dj);
000014  f8c4d018          STR      sp,[r4,#0x18]
;;;3017   			res = dir_read(dj);				/* Read an directory item */
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       dir_read
00001e  2600              MOVS     r6,#0                 ;3007
;;;3018   			if (res == FR_NO_FILE) {		/* Reached end of dir */
000020  2804              CMP      r0,#4
000022  d013              BEQ      |L20.76|
;;;3019   				dj->sect = 0;
;;;3020   				res = FR_OK;
;;;3021   			}
;;;3022   			if (res == FR_OK) {				/* A valid entry is found */
000024  2800              CMP      r0,#0
000026  d10b              BNE      |L20.64|
                  |L20.40|
;;;3023   				get_fileinfo(dj, fno);		/* Get the object information */
000028  4629              MOV      r1,r5
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       get_fileinfo
;;;3024   				res = dir_next(dj, 0);		/* Increment index for next */
000030  2100              MOVS     r1,#0
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       dir_next
;;;3025   				if (res == FR_NO_FILE) {
000038  2804              CMP      r0,#4
00003a  d101              BNE      |L20.64|
;;;3026   					dj->sect = 0;
;;;3027   					res = FR_OK;
00003c  2000              MOVS     r0,#0
00003e  6126              STR      r6,[r4,#0x10]
                  |L20.64|
;;;3028   				}
;;;3029   			}
;;;3030   			FREE_BUF();
;;;3031   		}
;;;3032   	}
;;;3033   
;;;3034   	LEAVE_FF(dj->fs, res);
;;;3035   }
000040  bdfe              POP      {r1-r7,pc}
                  |L20.66|
000042  2100              MOVS     r1,#0                 ;3014
000044  4620              MOV      r0,r4                 ;3014
000046  f7fffffe          BL       dir_sdi
00004a  bdfe              POP      {r1-r7,pc}
                  |L20.76|
00004c  6126              STR      r6,[r4,#0x10]         ;3020
00004e  e7eb              B        |L20.40|
;;;3036   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3413   
;;;3414   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3415   	const TCHAR *path_old,	/* Pointer to the old name */
;;;3416   	const TCHAR *path_new	/* Pointer to the new name */
;;;3417   )
;;;3418   {
000002  b099              SUB      sp,sp,#0x64
000004  460c              MOV      r4,r1
;;;3419   	FRESULT res;
;;;3420   	DIR djo, djn;
;;;3421   	BYTE buf[21], *dir;
;;;3422   	DWORD dw;
;;;3423   	DEF_NAMEBUF;
;;;3424   
;;;3425   
;;;3426   	res = chk_mounted(&path_old, &djo.fs, 1);
000006  2201              MOVS     r2,#1
000008  a908              ADD      r1,sp,#0x20
00000a  a819              ADD      r0,sp,#0x64
00000c  f7fffffe          BL       chk_mounted
;;;3427   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d151              BNE      |L21.184|
;;;3428   		djn.fs = djo.fs;
000014  9808              LDR      r0,[sp,#0x20]
;;;3429   		INIT_BUF(djo);
000016  9001              STR      r0,[sp,#4]
000018  a815              ADD      r0,sp,#0x54
;;;3430   		res = follow_path(&djo, path_old);		/* Check old object */
00001a  900e              STR      r0,[sp,#0x38]
00001c  a808              ADD      r0,sp,#0x20
00001e  9919              LDR      r1,[sp,#0x64]
000020  f7fffffe          BL       follow_path
;;;3431   		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
;;;3432   			res = FR_INVALID_NAME;
;;;3433   #if _FS_SHARE
;;;3434   		if (res == FR_OK) res = chk_lock(&djo, 2);
;;;3435   #endif
;;;3436   		if (res == FR_OK) {						/* Old object is found */
000024  2800              CMP      r0,#0
000026  d147              BNE      |L21.184|
;;;3437   			if (!djo.dir) {						/* Is root dir? */
000028  980d              LDR      r0,[sp,#0x34]
00002a  b3f0              CBZ      r0,|L21.170|
;;;3438   				res = FR_NO_FILE;
;;;3439   			} else {
;;;3440   				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except for name */
00002c  f100010b          ADD      r1,r0,#0xb
000030  2215              MOVS     r2,#0x15
000032  a80f              ADD      r0,sp,#0x3c
000034  f7fffffe          BL       mem_cpy
;;;3441   				mem_cpy(&djn, &djo, sizeof(DIR));		/* Check new object */
000038  221c              MOVS     r2,#0x1c
00003a  a908              ADD      r1,sp,#0x20
00003c  a801              ADD      r0,sp,#4
00003e  f7fffffe          BL       mem_cpy
;;;3442   				res = follow_path(&djn, path_new);
000042  4621              MOV      r1,r4
000044  a801              ADD      r0,sp,#4
000046  f7fffffe          BL       follow_path
;;;3443   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
00004a  b378              CBZ      r0,|L21.172|
;;;3444   				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
00004c  2804              CMP      r0,#4
00004e  d133              BNE      |L21.184|
;;;3445   /* Start critical section that any interruption or error can cause cross-link */
;;;3446   					res = dir_register(&djn);			/* Register the new entry */
000050  a801              ADD      r0,sp,#4
000052  f7fffffe          BL       dir_register
;;;3447   					if (res == FR_OK) {
000056  2800              CMP      r0,#0
000058  d12e              BNE      |L21.184|
;;;3448   						dir = djn.dir;					/* Copy object information except for name */
;;;3449   						mem_cpy(dir+13, buf+2, 19);
00005a  9c06              LDR      r4,[sp,#0x18]
00005c  2213              MOVS     r2,#0x13
00005e  f10d013e          ADD      r1,sp,#0x3e
000062  f104000d          ADD      r0,r4,#0xd
000066  f7fffffe          BL       mem_cpy
;;;3450   						dir[DIR_Attr] = buf[0] | AM_ARC;
00006a  f89d003c          LDRB     r0,[sp,#0x3c]
;;;3451   						djo.fs->wflag = 1;
00006e  2501              MOVS     r5,#1
000070  f0400020          ORR      r0,r0,#0x20           ;3450
000074  72e0              STRB     r0,[r4,#0xb]          ;3450
000076  9808              LDR      r0,[sp,#0x20]
000078  7105              STRB     r5,[r0,#4]
;;;3452   						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
00007a  9903              LDR      r1,[sp,#0xc]
00007c  980a              LDR      r0,[sp,#0x28]
00007e  4288              CMP      r0,r1
000080  d034              BEQ      |L21.236|
000082  7ae0              LDRB     r0,[r4,#0xb]
000084  06c0              LSLS     r0,r0,#27
000086  d531              BPL      |L21.236|
;;;3453   							dw = clust2sect(djn.fs, LD_CLUST(dir));
000088  8aa0              LDRH     r0,[r4,#0x14]
00008a  8b61              LDRH     r1,[r4,#0x1a]
00008c  f360411f          BFI      r1,r0,#16,#16
000090  9801              LDR      r0,[sp,#4]
000092  f7fffffe          BL       clust2sect
000096  0001              MOVS     r1,r0
;;;3454   							if (!dw) {
000098  d012              BEQ      |L21.192|
;;;3455   								res = FR_INT_ERR;
;;;3456   							} else {
;;;3457   								res = move_window(djn.fs, dw);
00009a  9801              LDR      r0,[sp,#4]
00009c  f7fffffe          BL       move_window
;;;3458   								dir = djn.fs->win+SZ_DIR;	/* .. entry */
0000a0  9901              LDR      r1,[sp,#4]
0000a2  3150              ADDS     r1,r1,#0x50
;;;3459   								if (res == FR_OK && dir[1] == '.') {
0000a4  2800              CMP      r0,#0
0000a6  d107              BNE      |L21.184|
0000a8  e001              B        |L21.174|
                  |L21.170|
0000aa  e004              B        |L21.182|
                  |L21.172|
0000ac  e006              B        |L21.188|
                  |L21.174|
0000ae  7848              LDRB     r0,[r1,#1]
0000b0  282e              CMP      r0,#0x2e
0000b2  d007              BEQ      |L21.196|
0000b4  e01a              B        |L21.236|
                  |L21.182|
0000b6  2004              MOVS     r0,#4                 ;3438
                  |L21.184|
;;;3460   									dw = (djn.fs->fs_type == FS_FAT32 && djn.sclust == djn.fs->dirbase) ? 0 : djn.sclust;
;;;3461   									ST_CLUST(dir, dw);
;;;3462   									djn.fs->wflag = 1;
;;;3463   								}
;;;3464   							}
;;;3465   						}
;;;3466   						if (res == FR_OK) {
;;;3467   							res = dir_remove(&djo);		/* Remove old entry */
;;;3468   							if (res == FR_OK)
;;;3469   								res = sync(djo.fs);
;;;3470   						}
;;;3471   					}
;;;3472   /* End critical section */
;;;3473   				}
;;;3474   			}
;;;3475   		}
;;;3476   		FREE_BUF();
;;;3477   	}
;;;3478   	LEAVE_FF(djo.fs, res);
;;;3479   }
0000b8  b01b              ADD      sp,sp,#0x6c
0000ba  bd30              POP      {r4,r5,pc}
                  |L21.188|
0000bc  2008              MOVS     r0,#8                 ;3443
0000be  e7fb              B        |L21.184|
                  |L21.192|
0000c0  2002              MOVS     r0,#2                 ;3455
0000c2  e7f9              B        |L21.184|
                  |L21.196|
0000c4  9a01              LDR      r2,[sp,#4]            ;3460
0000c6  2000              MOVS     r0,#0                 ;3460
0000c8  7812              LDRB     r2,[r2,#0]            ;3460
0000ca  2a03              CMP      r2,#3                 ;3460
0000cc  d104              BNE      |L21.216|
0000ce  9b01              LDR      r3,[sp,#4]            ;3460
0000d0  9a03              LDR      r2,[sp,#0xc]          ;3460
0000d2  6a5b              LDR      r3,[r3,#0x24]         ;3460
0000d4  429a              CMP      r2,r3                 ;3460
0000d6  d000              BEQ      |L21.218|
                  |L21.216|
0000d8  9803              LDR      r0,[sp,#0xc]          ;3460
                  |L21.218|
0000da  7688              STRB     r0,[r1,#0x1a]         ;3461
0000dc  0a02              LSRS     r2,r0,#8              ;3461
0000de  76ca              STRB     r2,[r1,#0x1b]         ;3461
0000e0  0c02              LSRS     r2,r0,#16             ;3461
0000e2  750a              STRB     r2,[r1,#0x14]         ;3461
0000e4  0e00              LSRS     r0,r0,#24             ;3461
0000e6  7548              STRB     r0,[r1,#0x15]         ;3461
0000e8  9801              LDR      r0,[sp,#4]            ;3462
0000ea  7105              STRB     r5,[r0,#4]            ;3462
                  |L21.236|
0000ec  a808              ADD      r0,sp,#0x20           ;3467
0000ee  f7fffffe          BL       dir_remove
0000f2  2800              CMP      r0,#0                 ;3468
0000f4  d1e0              BNE      |L21.184|
0000f6  9808              LDR      r0,[sp,#0x20]         ;3469
0000f8  f7fffffe          BL       sync
0000fc  e7dc              B        |L21.184|
;;;3480   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3043   
;;;3044   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3045   	const TCHAR *path,	/* Pointer to the file path */
;;;3046   	FILINFO *fno		/* Pointer to file information to return */
;;;3047   )
;;;3048   {
000002  b08b              SUB      sp,sp,#0x2c
000004  460d              MOV      r5,r1
;;;3049   	FRESULT res;
;;;3050   	DIR dj;
;;;3051   	DEF_NAMEBUF;
;;;3052   
;;;3053   
;;;3054   	res = chk_mounted(&path, &dj.fs, 0);
000006  2200              MOVS     r2,#0
000008  4669              MOV      r1,sp
00000a  a80b              ADD      r0,sp,#0x2c
00000c  f7fffffe          BL       chk_mounted
000010  0004              MOVS     r4,r0
;;;3055   	if (res == FR_OK) {
000012  d10f              BNE      |L22.52|
;;;3056   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3057   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990b              LDR      r1,[sp,#0x2c]
00001c  f7fffffe          BL       follow_path
000020  0004              MOVS     r4,r0
;;;3058   		if (res == FR_OK) {				/* Follow completed */
000022  d107              BNE      |L22.52|
;;;3059   			if (dj.dir)		/* Found an object */
000024  9805              LDR      r0,[sp,#0x14]
000026  b120              CBZ      r0,|L22.50|
;;;3060   				get_fileinfo(&dj, fno);
000028  4629              MOV      r1,r5
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       get_fileinfo
000030  e000              B        |L22.52|
                  |L22.50|
;;;3061   			else			/* It is root dir */
;;;3062   				res = FR_INVALID_NAME;
000032  2406              MOVS     r4,#6
                  |L22.52|
;;;3063   		}
;;;3064   		FREE_BUF();
;;;3065   	}
;;;3066   
;;;3067   	LEAVE_FF(dj.fs, res);
;;;3068   }
000034  b00d              ADD      sp,sp,#0x34
000036  4620              MOV      r0,r4                 ;3067
000038  bd30              POP      {r4,r5,pc}
;;;3069   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2592   
;;;2593   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2594   	FIL *fp		/* Pointer to the file object */
;;;2595   )
;;;2596   {
000002  4604              MOV      r4,r0
;;;2597   	FRESULT res;
;;;2598   	DWORD tim;
;;;2599   	BYTE *dir;
;;;2600   
;;;2601   
;;;2602   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
;;;2603   	if (res == FR_OK) {
00000c  2800              CMP      r0,#0
00000e  d10e              BNE      |L23.46|
;;;2604   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
000010  79a1              LDRB     r1,[r4,#6]
000012  068a              LSLS     r2,r1,#26
000014  d50b              BPL      |L23.46|
;;;2605   #if !_FS_TINY	/* Write-back dirty buffer */
;;;2606   			if (fp->flag & FA__DIRTY) {
000016  0648              LSLS     r0,r1,#25
000018  d50e              BPL      |L23.56|
;;;2607   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
00001a  6820              LDR      r0,[r4,#0]
00001c  2301              MOVS     r3,#1
00001e  f1040124          ADD      r1,r4,#0x24
000022  7840              LDRB     r0,[r0,#1]
000024  69a2              LDR      r2,[r4,#0x18]
000026  f7fffffe          BL       disk_write
00002a  b108              CBZ      r0,|L23.48|
;;;2608   					LEAVE_FF(fp->fs, FR_DISK_ERR);
00002c  2001              MOVS     r0,#1
                  |L23.46|
;;;2609   				fp->flag &= ~FA__DIRTY;
;;;2610   			}
;;;2611   #endif
;;;2612   			/* Update the directory entry */
;;;2613   			res = move_window(fp->fs, fp->dir_sect);
;;;2614   			if (res == FR_OK) {
;;;2615   				dir = fp->dir_ptr;
;;;2616   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2617   				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;;;2618   				ST_CLUST(dir, fp->sclust);					/* Update start cluster */
;;;2619   				tim = get_fattime();						/* Update updated time */
;;;2620   				ST_DWORD(dir+DIR_WrtTime, tim);
;;;2621   				fp->flag &= ~FA__WRITTEN;
;;;2622   				fp->fs->wflag = 1;
;;;2623   				res = sync(fp->fs);
;;;2624   			}
;;;2625   		}
;;;2626   	}
;;;2627   
;;;2628   	LEAVE_FF(fp->fs, res);
;;;2629   }
00002e  bd70              POP      {r4-r6,pc}
                  |L23.48|
000030  79a0              LDRB     r0,[r4,#6]            ;2609
000032  f0200040          BIC      r0,r0,#0x40           ;2609
000036  71a0              STRB     r0,[r4,#6]            ;2609
                  |L23.56|
000038  69e1              LDR      r1,[r4,#0x1c]         ;2613
00003a  6820              LDR      r0,[r4,#0]            ;2613
00003c  f7fffffe          BL       move_window
000040  2800              CMP      r0,#0                 ;2614
000042  d1f4              BNE      |L23.46|
000044  6a25              LDR      r5,[r4,#0x20]         ;2616
000046  7ae8              LDRB     r0,[r5,#0xb]          ;2616
000048  f0400020          ORR      r0,r0,#0x20           ;2616
00004c  72e8              STRB     r0,[r5,#0xb]          ;2616
00004e  68e0              LDR      r0,[r4,#0xc]          ;2617
000050  7728              STRB     r0,[r5,#0x1c]         ;2617
000052  68e0              LDR      r0,[r4,#0xc]          ;2617
000054  0a00              LSRS     r0,r0,#8              ;2617
000056  7768              STRB     r0,[r5,#0x1d]         ;2617
000058  68e0              LDR      r0,[r4,#0xc]          ;2617
00005a  0c00              LSRS     r0,r0,#16             ;2617
00005c  77a8              STRB     r0,[r5,#0x1e]         ;2617
00005e  68e0              LDR      r0,[r4,#0xc]          ;2617
000060  0e00              LSRS     r0,r0,#24             ;2617
000062  77e8              STRB     r0,[r5,#0x1f]         ;2617
000064  6920              LDR      r0,[r4,#0x10]         ;2618
000066  76a8              STRB     r0,[r5,#0x1a]         ;2618
000068  6920              LDR      r0,[r4,#0x10]         ;2618
00006a  0a00              LSRS     r0,r0,#8              ;2618
00006c  76e8              STRB     r0,[r5,#0x1b]         ;2618
00006e  6920              LDR      r0,[r4,#0x10]         ;2618
000070  0c00              LSRS     r0,r0,#16             ;2618
000072  7528              STRB     r0,[r5,#0x14]         ;2618
000074  6920              LDR      r0,[r4,#0x10]         ;2618
000076  0e00              LSRS     r0,r0,#24             ;2618
000078  7568              STRB     r0,[r5,#0x15]         ;2618
00007a  f7fffffe          BL       get_fattime
00007e  75a8              STRB     r0,[r5,#0x16]         ;2620
000080  0a01              LSRS     r1,r0,#8              ;2620
000082  75e9              STRB     r1,[r5,#0x17]         ;2620
000084  0c01              LSRS     r1,r0,#16             ;2620
000086  7629              STRB     r1,[r5,#0x18]         ;2620
000088  0e00              LSRS     r0,r0,#24             ;2620
00008a  7668              STRB     r0,[r5,#0x19]         ;2620
00008c  79a0              LDRB     r0,[r4,#6]            ;2621
00008e  f0200020          BIC      r0,r0,#0x20           ;2621
000092  71a0              STRB     r0,[r4,#6]            ;2621
000094  6821              LDR      r1,[r4,#0]            ;2622
000096  2001              MOVS     r0,#1                 ;2622
000098  7108              STRB     r0,[r1,#4]            ;2622
00009a  6820              LDR      r0,[r4,#0]            ;2623
00009c  e8bd4070          POP      {r4-r6,lr}            ;2623
0000a0  f7ffbffe          B.W      sync
;;;2630   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3141   
;;;3142   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3143   	FIL *fp		/* Pointer to the file object */
;;;3144   )
;;;3145   {
000002  4604              MOV      r4,r0
;;;3146   	FRESULT res;
;;;3147   	DWORD ncl;
;;;3148   
;;;3149   
;;;3150   	res = validate(fp->fs, fp->id);		/* Check validity of the object */
000004  8881              LDRH     r1,[r0,#4]
000006  6800              LDR      r0,[r0,#0]
000008  f7fffffe          BL       validate
00000c  0005              MOVS     r5,r0
;;;3151   	if (res == FR_OK) {
00000e  d13d              BNE      |L24.140|
;;;3152   		if (fp->flag & FA__ERROR) {			/* Check abort flag */
000010  79a0              LDRB     r0,[r4,#6]
000012  0601              LSLS     r1,r0,#24
000014  d501              BPL      |L24.26|
;;;3153   			res = FR_INT_ERR;
000016  2502              MOVS     r5,#2
000018  e038              B        |L24.140|
                  |L24.26|
;;;3154   		} else {
;;;3155   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
00001a  0781              LSLS     r1,r0,#30
00001c  d401              BMI      |L24.34|
;;;3156   				res = FR_DENIED;
00001e  2507              MOVS     r5,#7
000020  e034              B        |L24.140|
                  |L24.34|
000022  e9d41202          LDRD     r1,r2,[r4,#8]
;;;3157   		}
;;;3158   	}
;;;3159   	if (res == FR_OK) {
;;;3160   		if (fp->fsize > fp->fptr) {
000026  428a              CMP      r2,r1
000028  d930              BLS      |L24.140|
;;;3161   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;3162   			fp->flag |= FA__WRITTEN;
00002a  f0400020          ORR      r0,r0,#0x20
00002e  60e1              STR      r1,[r4,#0xc]
000030  71a0              STRB     r0,[r4,#6]
;;;3163   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000032  b151              CBZ      r1,|L24.74|
;;;3164   				res = remove_chain(fp->fs, fp->sclust);
;;;3165   				fp->sclust = 0;
;;;3166   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3167   				ncl = get_fat(fp->fs, fp->clust);
000034  6961              LDR      r1,[r4,#0x14]
000036  6820              LDR      r0,[r4,#0]
000038  f7fffffe          BL       get_fat
00003c  4606              MOV      r6,r0
;;;3168   				res = FR_OK;
;;;3169   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
00003e  1c40              ADDS     r0,r0,#1
000040  d00b              BEQ      |L24.90|
;;;3170   				if (ncl == 1) res = FR_INT_ERR;
000042  2e01              CMP      r6,#1
000044  d00b              BEQ      |L24.94|
;;;3171   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000046  b165              CBZ      r5,|L24.98|
000048  e01c              B        |L24.132|
                  |L24.74|
00004a  6921              LDR      r1,[r4,#0x10]         ;3164
00004c  6820              LDR      r0,[r4,#0]            ;3164
00004e  f7fffffe          BL       remove_chain
000052  4605              MOV      r5,r0                 ;3164
000054  2000              MOVS     r0,#0                 ;3165
000056  6120              STR      r0,[r4,#0x10]         ;3165
000058  e013              B        |L24.130|
                  |L24.90|
00005a  2501              MOVS     r5,#1                 ;3169
00005c  e012              B        |L24.132|
                  |L24.94|
00005e  2502              MOVS     r5,#2                 ;3170
000060  e010              B        |L24.132|
                  |L24.98|
000062  6820              LDR      r0,[r4,#0]
000064  6981              LDR      r1,[r0,#0x18]
000066  42b1              CMP      r1,r6
000068  d910              BLS      |L24.140|
;;;3172   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
00006a  f06f4270          MVN      r2,#0xf0000000
00006e  6961              LDR      r1,[r4,#0x14]
000070  f7fffffe          BL       put_fat
000074  0005              MOVS     r5,r0
;;;3173   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000076  d105              BNE      |L24.132|
000078  4631              MOV      r1,r6
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       remove_chain
000080  4605              MOV      r5,r0
                  |L24.130|
;;;3174   				}
;;;3175   			}
;;;3176   		}
;;;3177   		if (res != FR_OK) fp->flag |= FA__ERROR;
000082  b11d              CBZ      r5,|L24.140|
                  |L24.132|
000084  79a0              LDRB     r0,[r4,#6]
000086  f0400080          ORR      r0,r0,#0x80
00008a  71a0              STRB     r0,[r4,#6]
                  |L24.140|
;;;3178   	}
;;;3179   
;;;3180   	LEAVE_FF(fp->fs, res);
00008c  4628              MOV      r0,r5
;;;3181   }
00008e  bd70              POP      {r4-r6,pc}
;;;3182   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3189   
;;;3190   FRESULT f_unlink (
000000  b511              PUSH     {r0,r4,lr}
;;;3191   	const TCHAR *path		/* Pointer to the file or directory path */
;;;3192   )
;;;3193   {
000002  b091              SUB      sp,sp,#0x44
;;;3194   	FRESULT res;
;;;3195   	DIR dj, sdj;
;;;3196   	BYTE *dir;
;;;3197   	DWORD dclst;
;;;3198   	DEF_NAMEBUF;
;;;3199   
;;;3200   
;;;3201   	res = chk_mounted(&path, &dj.fs, 1);
000004  2201              MOVS     r2,#1
000006  4669              MOV      r1,sp
000008  a811              ADD      r0,sp,#0x44
00000a  f7fffffe          BL       chk_mounted
;;;3202   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d119              BNE      |L25.70|
;;;3203   		INIT_BUF(dj);
000012  a80e              ADD      r0,sp,#0x38
;;;3204   		res = follow_path(&dj, path);		/* Follow the file path */
000014  9006              STR      r0,[sp,#0x18]
000016  4668              MOV      r0,sp
000018  9911              LDR      r1,[sp,#0x44]
00001a  f7fffffe          BL       follow_path
;;;3205   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3206   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3207   #if _FS_SHARE
;;;3208   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
;;;3209   #endif
;;;3210   		if (res == FR_OK) {					/* The object is accessible */
00001e  2800              CMP      r0,#0
000020  d111              BNE      |L25.70|
;;;3211   			dir = dj.dir;
;;;3212   			if (!dir) {
000022  9a05              LDR      r2,[sp,#0x14]
000024  b18a              CBZ      r2,|L25.74|
;;;3213   				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
;;;3214   			} else {
;;;3215   				if (dir[DIR_Attr] & AM_RDO)
000026  7ad1              LDRB     r1,[r2,#0xb]
000028  07c9              LSLS     r1,r1,#31
00002a  d000              BEQ      |L25.46|
;;;3216   					res = FR_DENIED;		/* Cannot remove R/O object */
00002c  2007              MOVS     r0,#7
                  |L25.46|
;;;3217   			}
;;;3218   			dclst = LD_CLUST(dir);
00002e  8a91              LDRH     r1,[r2,#0x14]
000030  8b54              LDRH     r4,[r2,#0x1a]
;;;3219   			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
000032  2800              CMP      r0,#0
000034  f361441f          BFI      r4,r1,#16,#16         ;3218
000038  d105              BNE      |L25.70|
00003a  7ad0              LDRB     r0,[r2,#0xb]
00003c  06c0              LSLS     r0,r0,#27
00003e  d51a              BPL      |L25.118|
;;;3220   				if (dclst < 2) {
000040  2c02              CMP      r4,#2
000042  d204              BCS      |L25.78|
;;;3221   					res = FR_INT_ERR;
000044  2002              MOVS     r0,#2
                  |L25.70|
;;;3222   				} else {
;;;3223   					mem_cpy(&sdj, &dj, sizeof(DIR));	/* Check if the sub-dir is empty or not */
;;;3224   					sdj.sclust = dclst;
;;;3225   					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
;;;3226   					if (res == FR_OK) {
;;;3227   						res = dir_read(&sdj);
;;;3228   						if (res == FR_OK			/* Not empty dir */
;;;3229   #if _FS_RPATH
;;;3230   						|| dclst == sdj.fs->cdir	/* Current dir */
;;;3231   #endif
;;;3232   						) res = FR_DENIED;
;;;3233   						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
;;;3234   					}
;;;3235   				}
;;;3236   			}
;;;3237   			if (res == FR_OK) {
;;;3238   				res = dir_remove(&dj);		/* Remove the directory entry */
;;;3239   				if (res == FR_OK) {
;;;3240   					if (dclst)				/* Remove the cluster chain if exist */
;;;3241   						res = remove_chain(dj.fs, dclst);
;;;3242   					if (res == FR_OK) res = sync(dj.fs);
;;;3243   				}
;;;3244   			}
;;;3245   		}
;;;3246   		FREE_BUF();
;;;3247   	}
;;;3248   	LEAVE_FF(dj.fs, res);
;;;3249   }
000046  b012              ADD      sp,sp,#0x48
000048  bd10              POP      {r4,pc}
                  |L25.74|
00004a  2006              MOVS     r0,#6                 ;3213
00004c  e7ef              B        |L25.46|
                  |L25.78|
00004e  221c              MOVS     r2,#0x1c              ;3223
000050  4669              MOV      r1,sp                 ;3223
000052  a807              ADD      r0,sp,#0x1c           ;3223
000054  f7fffffe          BL       mem_cpy
000058  2102              MOVS     r1,#2                 ;3225
00005a  a807              ADD      r0,sp,#0x1c           ;3225
00005c  9409              STR      r4,[sp,#0x24]         ;3225
00005e  f7fffffe          BL       dir_sdi
000062  2800              CMP      r0,#0                 ;3226
000064  d1ef              BNE      |L25.70|
000066  a807              ADD      r0,sp,#0x1c           ;3227
000068  f7fffffe          BL       dir_read
00006c  b198              CBZ      r0,|L25.150|
00006e  2804              CMP      r0,#4                 ;3233
000070  d001              BEQ      |L25.118|
000072  2800              CMP      r0,#0                 ;3237
000074  d1e7              BNE      |L25.70|
                  |L25.118|
000076  4668              MOV      r0,sp                 ;3238
000078  f7fffffe          BL       dir_remove
00007c  2800              CMP      r0,#0                 ;3239
00007e  d1e2              BNE      |L25.70|
000080  b12c              CBZ      r4,|L25.142|
000082  4621              MOV      r1,r4                 ;3241
000084  9800              LDR      r0,[sp,#0]            ;3241
000086  f7fffffe          BL       remove_chain
00008a  2800              CMP      r0,#0                 ;3242
00008c  d1db              BNE      |L25.70|
                  |L25.142|
00008e  9800              LDR      r0,[sp,#0]            ;3242
000090  f7fffffe          BL       sync
000094  e7d7              B        |L25.70|
                  |L25.150|
000096  2007              MOVS     r0,#7                 ;3232
000098  e7d5              B        |L25.70|
;;;3250   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3372   
;;;3373   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3374   	const TCHAR *path,	/* Pointer to the file/directory name */
;;;3375   	const FILINFO *fno	/* Pointer to the time stamp to be set */
;;;3376   )
;;;3377   {
000002  b08a              SUB      sp,sp,#0x28
000004  460c              MOV      r4,r1
;;;3378   	FRESULT res;
;;;3379   	DIR dj;
;;;3380   	BYTE *dir;
;;;3381   	DEF_NAMEBUF;
;;;3382   
;;;3383   
;;;3384   	res = chk_mounted(&path, &dj.fs, 1);
000006  2201              MOVS     r2,#1
000008  4669              MOV      r1,sp
00000a  a80a              ADD      r0,sp,#0x28
00000c  f7fffffe          BL       chk_mounted
;;;3385   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d119              BNE      |L26.72|
;;;3386   		INIT_BUF(dj);
000014  a807              ADD      r0,sp,#0x1c
;;;3387   		res = follow_path(&dj, path);	/* Follow the file path */
000016  9006              STR      r0,[sp,#0x18]
000018  4668              MOV      r0,sp
00001a  990a              LDR      r1,[sp,#0x28]
00001c  f7fffffe          BL       follow_path
;;;3388   		FREE_BUF();
;;;3389   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3390   			res = FR_INVALID_NAME;
;;;3391   		if (res == FR_OK) {
000020  2800              CMP      r0,#0
000022  d111              BNE      |L26.72|
;;;3392   			dir = dj.dir;
;;;3393   			if (!dir) {					/* Root directory */
000024  9805              LDR      r0,[sp,#0x14]
000026  b188              CBZ      r0,|L26.76|
;;;3394   				res = FR_INVALID_NAME;
;;;3395   			} else {					/* File or sub-directory */
;;;3396   				ST_WORD(dir+DIR_WrtTime, fno->ftime);
000028  88e1              LDRH     r1,[r4,#6]
00002a  7581              STRB     r1,[r0,#0x16]
00002c  88e1              LDRH     r1,[r4,#6]
00002e  0a09              LSRS     r1,r1,#8
000030  75c1              STRB     r1,[r0,#0x17]
;;;3397   				ST_WORD(dir+DIR_WrtDate, fno->fdate);
000032  88a1              LDRH     r1,[r4,#4]
000034  7601              STRB     r1,[r0,#0x18]
000036  88a1              LDRH     r1,[r4,#4]
000038  0a09              LSRS     r1,r1,#8
00003a  7641              STRB     r1,[r0,#0x19]
;;;3398   				dj.fs->wflag = 1;
00003c  9900              LDR      r1,[sp,#0]
00003e  2001              MOVS     r0,#1
000040  7108              STRB     r0,[r1,#4]
;;;3399   				res = sync(dj.fs);
000042  9800              LDR      r0,[sp,#0]
000044  f7fffffe          BL       sync
                  |L26.72|
;;;3400   			}
;;;3401   		}
;;;3402   	}
;;;3403   
;;;3404   	LEAVE_FF(dj.fs, res);
;;;3405   }
000048  b00c              ADD      sp,sp,#0x30
00004a  bd10              POP      {r4,pc}
                  |L26.76|
00004c  2006              MOVS     r0,#6                 ;3394
00004e  e7fb              B        |L26.72|
;;;3406   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2473   
;;;2474   FRESULT f_write (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;2475   	FIL *fp,			/* Pointer to the file object */
;;;2476   	const void *buff,	/* Pointer to the data to be written */
;;;2477   	UINT btw,			/* Number of bytes to write */
;;;2478   	UINT *bw			/* Pointer to number of bytes written */
;;;2479   )
;;;2480   {
;;;2481   	FRESULT res;
;;;2482   	DWORD clst, sect;
;;;2483   	UINT wcnt, cc;
;;;2484   	const BYTE *wbuff = buff;
000004  4689              MOV      r9,r1
;;;2485   	BYTE csect;
;;;2486   
;;;2487   
;;;2488   	*bw = 0;	/* Initialize byte counter */
000006  2100              MOVS     r1,#0
;;;2489   
;;;2490   	res = validate(fp->fs, fp->id);			/* Check validity */
000008  6019              STR      r1,[r3,#0]
00000a  4604              MOV      r4,r0                 ;2480
00000c  8881              LDRH     r1,[r0,#4]
00000e  4616              MOV      r6,r2                 ;2480
000010  469a              MOV      r10,r3                ;2480
000012  6800              LDR      r0,[r0,#0]
000014  f7fffffe          BL       validate
;;;2491   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000018  2800              CMP      r0,#0
00001a  d103              BNE      |L27.36|
;;;2492   	if (fp->flag & FA__ERROR)				/* Aborted file? */
00001c  79a0              LDRB     r0,[r4,#6]
00001e  0601              LSLS     r1,r0,#24
000020  d502              BPL      |L27.40|
                  |L27.34|
;;;2493   		LEAVE_FF(fp->fs, FR_INT_ERR);
000022  2002              MOVS     r0,#2
                  |L27.36|
;;;2494   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
;;;2495   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2496   	if ((DWORD)(fp->fsize + btw) < fp->fsize) btw = 0;	/* File size cannot reach 4GB */
;;;2497   
;;;2498   	for ( ;  btw;							/* Repeat until all data written */
;;;2499   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2500   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2501   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2502   			if (!csect) {					/* On the cluster boundary? */
;;;2503   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2504   					clst = fp->sclust;		/* Follow from the origin */
;;;2505   					if (clst == 0)			/* When no cluster is allocated, */
;;;2506   						fp->sclust = clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2507   				} else {					/* Middle or end of the file */
;;;2508   #if _USE_FASTSEEK
;;;2509   					if (fp->cltbl)
;;;2510   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2511   					else
;;;2512   #endif
;;;2513   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2514   				}
;;;2515   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2516   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2517   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2518   				fp->clust = clst;			/* Update current cluster */
;;;2519   			}
;;;2520   #if _FS_TINY
;;;2521   			if (fp->fs->winsect == fp->dsect && move_window(fp->fs, 0))	/* Write-back sector cache */
;;;2522   				ABORT(fp->fs, FR_DISK_ERR);
;;;2523   #else
;;;2524   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2525   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1) != RES_OK)
;;;2526   					ABORT(fp->fs, FR_DISK_ERR);
;;;2527   				fp->flag &= ~FA__DIRTY;
;;;2528   			}
;;;2529   #endif
;;;2530   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2531   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2532   			sect += csect;
;;;2533   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2534   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2535   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2536   					cc = fp->fs->csize - csect;
;;;2537   				if (disk_write(fp->fs->drv, wbuff, sect, (BYTE)cc) != RES_OK)
;;;2538   					ABORT(fp->fs, FR_DISK_ERR);
;;;2539   #if _FS_TINY
;;;2540   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2541   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2542   					fp->fs->wflag = 0;
;;;2543   				}
;;;2544   #else
;;;2545   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2546   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2547   					fp->flag &= ~FA__DIRTY;
;;;2548   				}
;;;2549   #endif
;;;2550   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2551   				continue;
;;;2552   			}
;;;2553   #if _FS_TINY
;;;2554   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2555   				if (move_window(fp->fs, 0)) ABORT(fp->fs, FR_DISK_ERR);
;;;2556   				fp->fs->winsect = sect;
;;;2557   			}
;;;2558   #else
;;;2559   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2560   				if (fp->fptr < fp->fsize &&
;;;2561   					disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)
;;;2562   						ABORT(fp->fs, FR_DISK_ERR);
;;;2563   			}
;;;2564   #endif
;;;2565   			fp->dsect = sect;
;;;2566   		}
;;;2567   		wcnt = SS(fp->fs) - (fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2568   		if (wcnt > btw) wcnt = btw;
;;;2569   #if _FS_TINY
;;;2570   		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
;;;2571   			ABORT(fp->fs, FR_DISK_ERR);
;;;2572   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2573   		fp->fs->wflag = 1;
;;;2574   #else
;;;2575   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2576   		fp->flag |= FA__DIRTY;
;;;2577   #endif
;;;2578   	}
;;;2579   
;;;2580   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2581   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2582   
;;;2583   	LEAVE_FF(fp->fs, FR_OK);
;;;2584   }
000024  e8bd9ff0          POP      {r4-r12,pc}
                  |L27.40|
000028  0780              LSLS     r0,r0,#30             ;2494
00002a  d401              BMI      |L27.48|
00002c  2007              MOVS     r0,#7                 ;2495
00002e  e7f9              B        |L27.36|
                  |L27.48|
000030  68e0              LDR      r0,[r4,#0xc]          ;2496
000032  f1040b24          ADD      r11,r4,#0x24          ;2525
000036  1982              ADDS     r2,r0,r6              ;2496
000038  4282              CMP      r2,r0                 ;2496
00003a  d346              BCC      |L27.202|
00003c  e092              B        |L27.356|
                  |L27.62|
00003e  68a0              LDR      r0,[r4,#8]            ;2500
000040  05c1              LSLS     r1,r0,#23             ;2500
000042  d173              BNE      |L27.300|
000044  6822              LDR      r2,[r4,#0]            ;2501
000046  7891              LDRB     r1,[r2,#2]            ;2501
000048  1e49              SUBS     r1,r1,#1              ;2501
00004a  ea012150          AND      r1,r1,r0,LSR #9       ;2501
00004e  f01105ff          ANDS     r5,r1,#0xff           ;2501
000052  d10a              BNE      |L27.106|
000054  b1a8              CBZ      r0,|L27.130|
000056  4610              MOV      r0,r2                 ;2513
000058  6961              LDR      r1,[r4,#0x14]         ;2513
00005a  f7fffffe          BL       create_chain
                  |L27.94|
00005e  b3a0              CBZ      r0,|L27.202|
                  |L27.96|
000060  2801              CMP      r0,#1                 ;2516
000062  d033              BEQ      |L27.204|
000064  1c41              ADDS     r1,r0,#1              ;2517
000066  d058              BEQ      |L27.282|
000068  6160              STR      r0,[r4,#0x14]         ;2518
                  |L27.106|
00006a  79a0              LDRB     r0,[r4,#6]            ;2524
00006c  0640              LSLS     r0,r0,#25             ;2524
00006e  d515              BPL      |L27.156|
000070  6820              LDR      r0,[r4,#0]            ;2525
000072  2301              MOVS     r3,#1                 ;2525
000074  4659              MOV      r1,r11                ;2525
000076  7840              LDRB     r0,[r0,#1]            ;2525
000078  69a2              LDR      r2,[r4,#0x18]         ;2525
00007a  f7fffffe          BL       disk_write
00007e  bbe0              CBNZ     r0,|L27.250|
000080  e008              B        |L27.148|
                  |L27.130|
000082  6920              LDR      r0,[r4,#0x10]         ;2505
000084  2800              CMP      r0,#0                 ;2505
000086  d1eb              BNE      |L27.96|
000088  2100              MOVS     r1,#0                 ;2506
00008a  4610              MOV      r0,r2                 ;2506
00008c  f7fffffe          BL       create_chain
000090  6120              STR      r0,[r4,#0x10]         ;2506
000092  e7e4              B        |L27.94|
                  |L27.148|
000094  79a0              LDRB     r0,[r4,#6]            ;2527
000096  f0200040          BIC      r0,r0,#0x40           ;2527
00009a  71a0              STRB     r0,[r4,#6]            ;2527
                  |L27.156|
00009c  6961              LDR      r1,[r4,#0x14]         ;2530
00009e  6820              LDR      r0,[r4,#0]            ;2530
0000a0  f7fffffe          BL       clust2sect
0000a4  b190              CBZ      r0,|L27.204|
0000a6  eb000805          ADD      r8,r0,r5              ;2532
0000aa  0a77              LSRS     r7,r6,#9              ;2533
0000ac  d026              BEQ      |L27.252|
0000ae  6820              LDR      r0,[r4,#0]            ;2535
0000b0  19ea              ADDS     r2,r5,r7              ;2535
0000b2  7881              LDRB     r1,[r0,#2]            ;2535
0000b4  428a              CMP      r2,r1                 ;2535
0000b6  d900              BLS      |L27.186|
0000b8  1b4f              SUBS     r7,r1,r5              ;2536
                  |L27.186|
0000ba  7840              LDRB     r0,[r0,#1]            ;2537
0000bc  b2fb              UXTB     r3,r7                 ;2537
0000be  4642              MOV      r2,r8                 ;2537
0000c0  4649              MOV      r1,r9                 ;2537
0000c2  f7fffffe          BL       disk_write
0000c6  b9c0              CBNZ     r0,|L27.250|
0000c8  e005              B        |L27.214|
                  |L27.202|
0000ca  e04e              B        |L27.362|
                  |L27.204|
0000cc  79a0              LDRB     r0,[r4,#6]            ;2531
0000ce  f0400080          ORR      r0,r0,#0x80           ;2531
0000d2  71a0              STRB     r0,[r4,#6]            ;2531
0000d4  e7a5              B        |L27.34|
                  |L27.214|
0000d6  69a1              LDR      r1,[r4,#0x18]         ;2545
0000d8  eba10008          SUB      r0,r1,r8              ;2545
0000dc  42b8              CMP      r0,r7                 ;2545
0000de  d20a              BCS      |L27.246|
0000e0  eb092140          ADD      r1,r9,r0,LSL #9       ;2546
0000e4  f44f7200          MOV      r2,#0x200             ;2546
0000e8  4658              MOV      r0,r11                ;2546
0000ea  f7fffffe          BL       mem_cpy
0000ee  79a0              LDRB     r0,[r4,#6]            ;2547
0000f0  f0200040          BIC      r0,r0,#0x40           ;2547
0000f4  71a0              STRB     r0,[r4,#6]            ;2547
                  |L27.246|
0000f6  027d              LSLS     r5,r7,#9              ;2550
0000f8  e02a              B        |L27.336|
                  |L27.250|
0000fa  e00e              B        |L27.282|
                  |L27.252|
0000fc  69a1              LDR      r1,[r4,#0x18]         ;2559
0000fe  4541              CMP      r1,r8                 ;2559
000100  d012              BEQ      |L27.296|
000102  e9d40102          LDRD     r0,r1,[r4,#8]         ;2559
000106  4288              CMP      r0,r1                 ;2560
000108  d20e              BCS      |L27.296|
00010a  6820              LDR      r0,[r4,#0]            ;2561
00010c  2301              MOVS     r3,#1                 ;2561
00010e  4642              MOV      r2,r8                 ;2561
000110  7840              LDRB     r0,[r0,#1]            ;2561
000112  4659              MOV      r1,r11                ;2561
000114  f7fffffe          BL       disk_read
000118  b130              CBZ      r0,|L27.296|
                  |L27.282|
00011a  79a0              LDRB     r0,[r4,#6]            ;2562
00011c  f0400080          ORR      r0,r0,#0x80           ;2562
000120  71a0              STRB     r0,[r4,#6]            ;2562
000122  2001              MOVS     r0,#1                 ;2562
000124  e77e              B        |L27.36|
000126  e001              B        |L27.300|
                  |L27.296|
000128  f8c48018          STR      r8,[r4,#0x18]         ;2565
                  |L27.300|
00012c  68a0              LDR      r0,[r4,#8]            ;2567
00012e  f3c00008          UBFX     r0,r0,#0,#9           ;2567
000132  f5c07500          RSB      r5,r0,#0x200          ;2567
000136  42b5              CMP      r5,r6                 ;2568
000138  d900              BLS      |L27.316|
00013a  4635              MOV      r5,r6                 ;2568
                  |L27.316|
00013c  4420              ADD      r0,r0,r4              ;2575
00013e  3024              ADDS     r0,r0,#0x24           ;2575
000140  462a              MOV      r2,r5                 ;2575
000142  4649              MOV      r1,r9                 ;2575
000144  f7fffffe          BL       mem_cpy
000148  79a0              LDRB     r0,[r4,#6]            ;2576
00014a  f0400040          ORR      r0,r0,#0x40           ;2576
00014e  71a0              STRB     r0,[r4,#6]            ;2576
                  |L27.336|
000150  68a0              LDR      r0,[r4,#8]            ;2499
000152  44a9              ADD      r9,r9,r5              ;2499
000154  4428              ADD      r0,r0,r5              ;2499
000156  60a0              STR      r0,[r4,#8]            ;2499
000158  f8da0000          LDR      r0,[r10,#0]           ;2499
00015c  1941              ADDS     r1,r0,r5              ;2499
00015e  1b76              SUBS     r6,r6,r5              ;2499
000160  f8ca1000          STR      r1,[r10,#0]           ;2499
                  |L27.356|
000164  2e00              CMP      r6,#0                 ;2498
000166  f47faf6a          BNE      |L27.62|
                  |L27.362|
00016a  e9d40102          LDRD     r0,r1,[r4,#8]         ;2498
00016e  4288              CMP      r0,r1                 ;2580
000170  d900              BLS      |L27.372|
000172  60e0              STR      r0,[r4,#0xc]          ;2580
                  |L27.372|
000174  79a0              LDRB     r0,[r4,#6]            ;2581
000176  f0400020          ORR      r0,r0,#0x20           ;2581
00017a  71a0              STRB     r0,[r4,#6]            ;2581
00017c  2000              MOVS     r0,#0                 ;2583
00017e  e751              B        |L27.36|
;;;2585   
                          ENDP


                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;1918   static
;;;1919   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;1920   	DIR *dj,			/* Directory object to return last directory and found object */
;;;1921   	const TCHAR *path	/* Full-path string to find a file or directory */
;;;1922   )
;;;1923   {
000002  4604              MOV      r4,r0
;;;1924   	FRESULT res;
;;;1925   	BYTE *dir, ns;
;;;1926   
;;;1927   
;;;1928   #if _FS_RPATH
;;;1929   	if (*path == '/' || *path == '\\') { /* There is a heading separator */
;;;1930   		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
;;;1931   	} else {							/* No heading separator */
;;;1932   		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
;;;1933   	}
;;;1934   #else
;;;1935   	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
000004  9901              LDR      r1,[sp,#4]
000006  7808              LDRB     r0,[r1,#0]
000008  282f              CMP      r0,#0x2f
00000a  d001              BEQ      |L28.16|
00000c  285c              CMP      r0,#0x5c
00000e  d101              BNE      |L28.20|
                  |L28.16|
;;;1936   		path++;
000010  1c49              ADDS     r1,r1,#1
000012  9101              STR      r1,[sp,#4]
                  |L28.20|
;;;1937   	dj->sclust = 0;						/* Start from the root dir */
000014  2500              MOVS     r5,#0
;;;1938   #endif
;;;1939   
;;;1940   	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
000016  60a5              STR      r5,[r4,#8]
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L28.44|
;;;1941   		res = dir_sdi(dj, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;1942   		dj->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L28.42|
;;;1943   
;;;1944   	} else {							/* Follow path */
;;;1945   		for (;;) {
;;;1946   			res = create_name(dj, &path);	/* Get a segment */
;;;1947   			if (res != FR_OK) break;
;;;1948   			res = dir_find(dj);				/* Find it */
;;;1949   			ns = *(dj->fn+NS);
;;;1950   			if (res != FR_OK) {				/* Failed to find the object */
;;;1951   				if (res != FR_NO_FILE) break;	/* Abort if any hard error occured */
;;;1952   				/* Object not found */
;;;1953   				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
;;;1954   					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
;;;1955   					res = FR_OK;
;;;1956   					if (!(ns & NS_LAST)) continue;
;;;1957   				} else {							/* Could not find the object */
;;;1958   					if (!(ns & NS_LAST)) res = FR_NO_PATH;
;;;1959   				}
;;;1960   				break;
;;;1961   			}
;;;1962   			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
;;;1963   			dir = dj->dir;						/* There is next segment. Follow the sub directory */
;;;1964   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
;;;1965   				res = FR_NO_PATH; break;
;;;1966   			}
;;;1967   			dj->sclust = LD_CLUST(dir);
;;;1968   		}
;;;1969   	}
;;;1970   
;;;1971   	return res;
;;;1972   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L28.44|
00002c  a901              ADD      r1,sp,#4              ;1946
00002e  4620              MOV      r0,r4                 ;1946
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;1947
000036  d1f8              BNE      |L28.42|
000038  2100              MOVS     r1,#0                 ;1947
00003a  4620              MOV      r0,r4                 ;1947
00003c  f7fffffe          BL       dir_sdi
000040  b9f8              CBNZ     r0,|L28.130|
                  |L28.66|
000042  6921              LDR      r1,[r4,#0x10]         ;1947
000044  6820              LDR      r0,[r4,#0]            ;1947
000046  f7fffffe          BL       move_window
00004a  b9d0              CBNZ     r0,|L28.130|
00004c  6961              LDR      r1,[r4,#0x14]         ;1947
00004e  780a              LDRB     r2,[r1,#0]            ;1947
000050  b172              CBZ      r2,|L28.112|
000052  7aca              LDRB     r2,[r1,#0xb]          ;1947
000054  0712              LSLS     r2,r2,#28             ;1947
000056  d40e              BMI      |L28.118|
000058  250b              MOVS     r5,#0xb               ;1947
00005a  69a2              LDR      r2,[r4,#0x18]         ;1947
00005c  2300              MOVS     r3,#0                 ;1947
                  |L28.94|
00005e  1e6d              SUBS     r5,r5,#1              ;1947
000060  d308              BCC      |L28.116|
000062  f8113b01          LDRB     r3,[r1],#1            ;1947
000066  f8126b01          LDRB     r6,[r2],#1            ;1947
00006a  1b9b              SUBS     r3,r3,r6              ;1947
00006c  d0f7              BEQ      |L28.94|
00006e  e002              B        |L28.118|
                  |L28.112|
000070  2004              MOVS     r0,#4                 ;1947
000072  e006              B        |L28.130|
                  |L28.116|
000074  b12b              CBZ      r3,|L28.130|
                  |L28.118|
000076  2100              MOVS     r1,#0                 ;1947
000078  4620              MOV      r0,r4                 ;1947
00007a  f7fffffe          BL       dir_next
00007e  2800              CMP      r0,#0                 ;1947
000080  d0df              BEQ      |L28.66|
                  |L28.130|
000082  69a1              LDR      r1,[r4,#0x18]         ;1949
000084  7ac9              LDRB     r1,[r1,#0xb]          ;1949
000086  b128              CBZ      r0,|L28.148|
000088  2804              CMP      r0,#4                 ;1951
00008a  d1ce              BNE      |L28.42|
00008c  0749              LSLS     r1,r1,#29             ;1958
00008e  d4cc              BMI      |L28.42|
                  |L28.144|
000090  2005              MOVS     r0,#5                 ;1958
                  |L28.146|
000092  bd7c              POP      {r2-r6,pc}
                  |L28.148|
000094  0749              LSLS     r1,r1,#29             ;1962
000096  d4fc              BMI      |L28.146|
000098  6960              LDR      r0,[r4,#0x14]         ;1964
00009a  7ac1              LDRB     r1,[r0,#0xb]          ;1964
00009c  06c9              LSLS     r1,r1,#27             ;1964
00009e  d5f7              BPL      |L28.144|
0000a0  8a81              LDRH     r1,[r0,#0x14]         ;1967
0000a2  8b40              LDRH     r0,[r0,#0x1a]         ;1967
0000a4  f361401f          BFI      r0,r1,#16,#16         ;1967
0000a8  60a0              STR      r0,[r4,#8]            ;1956
0000aa  e7bf              B        |L28.44|
;;;1973   
                          ENDP


                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;818    
;;;819    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;820    	FATFS *fs,	/* File system object */
;;;821    	DWORD clst	/* Cluster# to get the link information */
;;;822    )
;;;823    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;824    	UINT wc, bc;
;;;825    	BYTE *p;
;;;826    
;;;827    
;;;828    	if (clst < 2 || clst >= fs->n_fatent)	/* Chack range */
000008  2902              CMP      r1,#2
00000a  d302              BCC      |L29.18|
00000c  69a0              LDR      r0,[r4,#0x18]
00000e  42a8              CMP      r0,r5
000010  d802              BHI      |L29.24|
                  |L29.18|
;;;829    		return 1;
000012  2001              MOVS     r0,#1
                  |L29.20|
;;;830    
;;;831    	switch (fs->fs_type) {
;;;832    	case FS_FAT12 :
;;;833    		bc = (UINT)clst; bc += bc / 2;
;;;834    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;835    		wc = fs->win[bc % SS(fs)]; bc++;
;;;836    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;837    		wc |= fs->win[bc % SS(fs)] << 8;
;;;838    		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
;;;839    
;;;840    	case FS_FAT16 :
;;;841    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
;;;842    		p = &fs->win[clst * 2 % SS(fs)];
;;;843    		return LD_WORD(p);
;;;844    
;;;845    	case FS_FAT32 :
;;;846    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
;;;847    		p = &fs->win[clst * 4 % SS(fs)];
;;;848    		return LD_DWORD(p) & 0x0FFFFFFF;
;;;849    	}
;;;850    
;;;851    	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
;;;852    }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L29.24|
000018  7820              LDRB     r0,[r4,#0]            ;831
00001a  2801              CMP      r0,#1                 ;831
00001c  d004              BEQ      |L29.40|
00001e  2802              CMP      r0,#2                 ;831
000020  d025              BEQ      |L29.110|
000022  2803              CMP      r0,#3                 ;831
000024  d136              BNE      |L29.148|
000026  e02e              B        |L29.134|
                  |L29.40|
000028  6a20              LDR      r0,[r4,#0x20]         ;834
00002a  eb050655          ADD      r6,r5,r5,LSR #1       ;833
00002e  eb002156          ADD      r1,r0,r6,LSR #9       ;834
000032  4620              MOV      r0,r4                 ;834
000034  f7fffffe          BL       move_window
000038  bb60              CBNZ     r0,|L29.148|
00003a  f3c60008          UBFX     r0,r6,#0,#9           ;835
00003e  4420              ADD      r0,r0,r4              ;835
000040  1c76              ADDS     r6,r6,#1              ;835
000042  f8907030          LDRB     r7,[r0,#0x30]         ;835
000046  6a20              LDR      r0,[r4,#0x20]         ;836
000048  eb002156          ADD      r1,r0,r6,LSR #9       ;836
00004c  4620              MOV      r0,r4                 ;836
00004e  f7fffffe          BL       move_window
000052  b9f8              CBNZ     r0,|L29.148|
000054  f3c60008          UBFX     r0,r6,#0,#9           ;837
000058  4420              ADD      r0,r0,r4              ;837
00005a  f8900030          LDRB     r0,[r0,#0x30]         ;837
00005e  ea472100          ORR      r1,r7,r0,LSL #8       ;837
000062  0908              LSRS     r0,r1,#4              ;838
000064  07ea              LSLS     r2,r5,#31             ;838
000066  d1d5              BNE      |L29.20|
000068  f3c1000b          UBFX     r0,r1,#0,#12          ;838
00006c  e7d2              B        |L29.20|
                  |L29.110|
00006e  6a20              LDR      r0,[r4,#0x20]         ;841
000070  eb002115          ADD      r1,r0,r5,LSR #8       ;841
000074  4620              MOV      r0,r4                 ;841
000076  f7fffffe          BL       move_window
00007a  b958              CBNZ     r0,|L29.148|
00007c  b2e8              UXTB     r0,r5                 ;842
00007e  eb040040          ADD      r0,r4,r0,LSL #1       ;842
000082  8e00              LDRH     r0,[r0,#0x30]         ;843
000084  e7c6              B        |L29.20|
                  |L29.134|
000086  6a20              LDR      r0,[r4,#0x20]         ;846
000088  eb0011d5          ADD      r1,r0,r5,LSR #7       ;846
00008c  4620              MOV      r0,r4                 ;846
00008e  f7fffffe          BL       move_window
000092  b110              CBZ      r0,|L29.154|
                  |L29.148|
000094  f04f30ff          MOV      r0,#0xffffffff        ;851
000098  e7bc              B        |L29.20|
                  |L29.154|
00009a  f24010ff          MOV      r0,#0x1ff             ;847
00009e  ea000085          AND      r0,r0,r5,LSL #2       ;847
0000a2  4420              ADD      r0,r0,r4              ;847
0000a4  f8101f30          LDRB     r1,[r0,#0x30]!        ;848
0000a8  f8d00001          LDR      r0,[r0,#1]            ;848
0000ac  ea412000          ORR      r0,r1,r0,LSL #8       ;848
0000b0  f0204070          BIC      r0,r0,#0xf0000000     ;848
0000b4  e7ae              B        |L29.20|
;;;853    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1836   static
;;;1837   void get_fileinfo (		/* No return code */
000000  b510              PUSH     {r4,lr}
;;;1838   	DIR *dj,			/* Pointer to the directory object */
;;;1839   	FILINFO *fno	 	/* Pointer to the file information to be filled */
;;;1840   )
;;;1841   {
;;;1842   	UINT i;
;;;1843   	BYTE nt, *dir;
;;;1844   	TCHAR *p, c;
;;;1845   
;;;1846   
;;;1847   	p = fno->fname;
;;;1848   	if (dj->sect) {
000002  6903              LDR      r3,[r0,#0x10]
000004  f1010209          ADD      r2,r1,#9              ;1847
000008  b33b              CBZ      r3,|L30.90|
;;;1849   		dir = dj->dir;
00000a  6940              LDR      r0,[r0,#0x14]
;;;1850   		nt = dir[DIR_NTres];		/* NT flag */
;;;1851   		for (i = 0; i < 8; i++) {	/* Copy name body */
00000c  2400              MOVS     r4,#0
                  |L30.14|
;;;1852   			c = dir[i];
00000e  5d03              LDRB     r3,[r0,r4]
;;;1853   			if (c == ' ') break;
000010  2b20              CMP      r3,#0x20
000012  d007              BEQ      |L30.36|
;;;1854   			if (c == NDDE) c = (TCHAR)DDE;
000014  2b05              CMP      r3,#5
000016  d100              BNE      |L30.26|
000018  23e5              MOVS     r3,#0xe5
                  |L30.26|
00001a  1c64              ADDS     r4,r4,#1              ;1851
;;;1855   			if (_USE_LFN && (nt & NS_BODY) && IsUpper(c)) c += 0x20;
;;;1856   #if _LFN_UNICODE
;;;1857   			if (IsDBCS1(c) && i < 7 && IsDBCS2(dir[i+1]))
;;;1858   				c = (c << 8) | dir[++i];
;;;1859   			c = ff_convert(c, 1);
;;;1860   			if (!c) c = '?';
;;;1861   #endif
;;;1862   			*p++ = c;
00001c  f8023b01          STRB     r3,[r2],#1
000020  2c08              CMP      r4,#8                 ;1851
000022  d3f4              BCC      |L30.14|
                  |L30.36|
;;;1863   		}
;;;1864   		if (dir[8] != ' ') {		/* Copy name extension */
000024  7a03              LDRB     r3,[r0,#8]
000026  2b20              CMP      r3,#0x20
000028  d00b              BEQ      |L30.66|
;;;1865   			*p++ = '.';
00002a  232e              MOVS     r3,#0x2e
00002c  f8023b01          STRB     r3,[r2],#1
;;;1866   			for (i = 8; i < 11; i++) {
000030  2308              MOVS     r3,#8
                  |L30.50|
;;;1867   				c = dir[i];
000032  5cc4              LDRB     r4,[r0,r3]
;;;1868   				if (c == ' ') break;
000034  2c20              CMP      r4,#0x20
000036  d004              BEQ      |L30.66|
000038  1c5b              ADDS     r3,r3,#1              ;1866
;;;1869   				if (_USE_LFN && (nt & NS_EXT) && IsUpper(c)) c += 0x20;
;;;1870   #if _LFN_UNICODE
;;;1871   				if (IsDBCS1(c) && i < 10 && IsDBCS2(dir[i+1]))
;;;1872   					c = (c << 8) | dir[++i];
;;;1873   				c = ff_convert(c, 1);
;;;1874   				if (!c) c = '?';
;;;1875   #endif
;;;1876   				*p++ = c;
00003a  f8024b01          STRB     r4,[r2],#1
00003e  2b0b              CMP      r3,#0xb               ;1866
000040  d3f7              BCC      |L30.50|
                  |L30.66|
;;;1877   			}
;;;1878   		}
;;;1879   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000042  7ac3              LDRB     r3,[r0,#0xb]
000044  720b              STRB     r3,[r1,#8]
;;;1880   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
000046  7f03              LDRB     r3,[r0,#0x1c]
000048  f8d0401d          LDR      r4,[r0,#0x1d]
00004c  ea432304          ORR      r3,r3,r4,LSL #8
;;;1881   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
000050  600b              STR      r3,[r1,#0]
000052  8b03              LDRH     r3,[r0,#0x18]
000054  808b              STRH     r3,[r1,#4]
;;;1882   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
000056  8ac0              LDRH     r0,[r0,#0x16]
000058  80c8              STRH     r0,[r1,#6]
                  |L30.90|
;;;1883   	}
;;;1884   	*p = 0;		/* Terminate SFN str by a \0 */
00005a  2000              MOVS     r0,#0
00005c  7010              STRB     r0,[r2,#0]
;;;1885   
;;;1886   #if _USE_LFN
;;;1887   	if (fno->lfname && fno->lfsize) {
;;;1888   		TCHAR *tp = fno->lfname;
;;;1889   		WCHAR w, *lfn;
;;;1890   
;;;1891   		i = 0;
;;;1892   		if (dj->sect && dj->lfn_idx != 0xFFFF) {/* Get LFN if available */
;;;1893   			lfn = dj->lfn;
;;;1894   			while ((w = *lfn++) != 0) {			/* Get an LFN char */
;;;1895   #if !_LFN_UNICODE
;;;1896   				w = ff_convert(w, 0);			/* Unicode -> OEM conversion */
;;;1897   				if (!w) { i = 0; break; }		/* Could not convert, no LFN */
;;;1898   				if (_DF1S && w >= 0x100)		/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
;;;1899   					tp[i++] = (TCHAR)(w >> 8);
;;;1900   #endif
;;;1901   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* Buffer overflow, no LFN */
;;;1902   				tp[i++] = (TCHAR)w;
;;;1903   			}
;;;1904   		}
;;;1905   		tp[i] = 0;	/* Terminate the LFN str by a \0 */
;;;1906   	}
;;;1907   #endif
;;;1908   }
00005e  bd10              POP      {r4,pc}
;;;1909   #endif /* _FS_MINIMIZE <= 1 */
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=1

                  mem_cpy PROC
;;;528    static
;;;529    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e003              B        |L31.10|
                  |L31.2|
;;;530    	BYTE *d = (BYTE*)dst;
;;;531    	const BYTE *s = (const BYTE*)src;
;;;532    
;;;533    #if _WORD_ACCESS == 1
;;;534    	while (cnt >= sizeof(int)) {
;;;535    		*(int*)d = *(int*)s;
;;;536    		d += sizeof(int); s += sizeof(int);
;;;537    		cnt -= sizeof(int);
;;;538    	}
;;;539    #endif
;;;540    	while (cnt--)
;;;541    		*d++ = *s++;
000002  f8113b01          LDRB     r3,[r1],#1
000006  f8003b01          STRB     r3,[r0],#1
                  |L31.10|
00000a  1e52              SUBS     r2,r2,#1              ;540
00000c  d2f9              BCS      |L31.2|
;;;542    }
00000e  4770              BX       lr
;;;543    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;545    static
;;;546    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
;;;547    	BYTE *d = (BYTE*)dst;
;;;548    
;;;549    	while (cnt--)
;;;550    		*d++ = (BYTE)val;
000002  e001              B        |L32.8|
                  |L32.4|
000004  f8001b01          STRB     r1,[r0],#1
                  |L32.8|
000008  1e52              SUBS     r2,r2,#1              ;549
00000a  d2fb              BCS      |L32.4|
;;;551    }
00000c  4770              BX       lr
;;;552    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;718    static
;;;719    FRESULT move_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;720    	FATFS *fs,		/* File system object */
;;;721    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;722    )					/* Move to zero only writes back dirty window */
;;;723    {
;;;724    	DWORD wsect;
;;;725    
;;;726    
;;;727    	wsect = fs->winsect;
;;;728    	if (wsect != sector) {	/* Changed current window */
000004  6ac5              LDR      r5,[r0,#0x2c]
000006  4604              MOV      r4,r0                 ;723
000008  460f              MOV      r7,r1                 ;723
00000a  428d              CMP      r5,r1
00000c  d02b              BEQ      |L33.102|
;;;729    #if !_FS_READONLY
;;;730    		if (fs->wflag) {	/* Write back dirty window if needed */
00000e  7921              LDRB     r1,[r4,#4]
;;;731    			if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK)
000010  f1040830          ADD      r8,r4,#0x30
000014  b1d9              CBZ      r1,|L33.78|
000016  7860              LDRB     r0,[r4,#1]
000018  2301              MOVS     r3,#1
00001a  462a              MOV      r2,r5
00001c  4641              MOV      r1,r8
00001e  f7fffffe          BL       disk_write
000022  b9e0              CBNZ     r0,|L33.94|
;;;732    				return FR_DISK_ERR;
;;;733    			fs->wflag = 0;
000024  2000              MOVS     r0,#0
000026  7120              STRB     r0,[r4,#4]
000028  e9d41007          LDRD     r1,r0,[r4,#0x1c]
;;;734    			if (wsect < (fs->fatbase + fs->fsize)) {	/* In FAT area */
00002c  4408              ADD      r0,r0,r1
00002e  42a8              CMP      r0,r5
000030  d90d              BLS      |L33.78|
;;;735    				BYTE nf;
;;;736    				for (nf = fs->n_fats; nf > 1; nf--) {	/* Reflect the change to all FAT copies */
000032  78e6              LDRB     r6,[r4,#3]
000034  e009              B        |L33.74|
                  |L33.54|
;;;737    					wsect += fs->fsize;
000036  69e0              LDR      r0,[r4,#0x1c]
;;;738    					disk_write(fs->drv, fs->win, wsect, 1);
000038  2301              MOVS     r3,#1
00003a  4405              ADD      r5,r5,r0              ;737
00003c  7860              LDRB     r0,[r4,#1]
00003e  462a              MOV      r2,r5
000040  4641              MOV      r1,r8
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1              ;736
000048  b2f6              UXTB     r6,r6                 ;736
                  |L33.74|
00004a  2e01              CMP      r6,#1                 ;736
00004c  d8f3              BHI      |L33.54|
                  |L33.78|
;;;739    				}
;;;740    			}
;;;741    		}
;;;742    #endif
;;;743    		if (sector) {
00004e  b157              CBZ      r7,|L33.102|
;;;744    			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
000050  7860              LDRB     r0,[r4,#1]
000052  2301              MOVS     r3,#1
000054  463a              MOV      r2,r7
000056  4641              MOV      r1,r8
000058  f7fffffe          BL       disk_read
00005c  b110              CBZ      r0,|L33.100|
                  |L33.94|
;;;745    				return FR_DISK_ERR;
00005e  2001              MOVS     r0,#1
                  |L33.96|
;;;746    			fs->winsect = sector;
;;;747    		}
;;;748    	}
;;;749    
;;;750    	return FR_OK;
;;;751    }
000060  e8bd81f0          POP      {r4-r8,pc}
                  |L33.100|
000064  62e7              STR      r7,[r4,#0x2c]         ;746
                  |L33.102|
000066  2000              MOVS     r0,#0                 ;750
000068  e7fa              B        |L33.96|
;;;752    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=1

                  put_fat PROC
;;;861    
;;;862    FRESULT put_fat (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;863    	FATFS *fs,	/* File system object */
;;;864    	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
;;;865    	DWORD val	/* New value to mark the cluster */
;;;866    )
;;;867    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;868    	UINT bc;
;;;869    	BYTE *p;
;;;870    	FRESULT res;
;;;871    
;;;872    
;;;873    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L34.20|
00000e  69a0              LDR      r0,[r4,#0x18]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L34.26|
                  |L34.20|
;;;874    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L34.22|
;;;875    
;;;876    	} else {
;;;877    		switch (fs->fs_type) {
;;;878    		case FS_FAT12 :
;;;879    			bc = clst; bc += bc / 2;
;;;880    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;881    			if (res != FR_OK) break;
;;;882    			p = &fs->win[bc % SS(fs)];
;;;883    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;884    			bc++;
;;;885    			fs->wflag = 1;
;;;886    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;887    			if (res != FR_OK) break;
;;;888    			p = &fs->win[bc % SS(fs)];
;;;889    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;890    			break;
;;;891    
;;;892    		case FS_FAT16 :
;;;893    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;894    			if (res != FR_OK) break;
;;;895    			p = &fs->win[clst * 2 % SS(fs)];
;;;896    			ST_WORD(p, (WORD)val);
;;;897    			break;
;;;898    
;;;899    		case FS_FAT32 :
;;;900    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;901    			if (res != FR_OK) break;
;;;902    			p = &fs->win[clst * 4 % SS(fs)];
;;;903    			val |= LD_DWORD(p) & 0xF0000000;
;;;904    			ST_DWORD(p, val);
;;;905    			break;
;;;906    
;;;907    		default :
;;;908    			res = FR_INT_ERR;
;;;909    		}
;;;910    		fs->wflag = 1;
;;;911    	}
;;;912    
;;;913    	return res;
;;;914    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L34.26|
00001a  7820              LDRB     r0,[r4,#0]            ;877
00001c  f04f0801          MOV      r8,#1                 ;877
000020  2801              CMP      r0,#1                 ;877
000022  d007              BEQ      |L34.52|
000024  2802              CMP      r0,#2                 ;877
000026  d038              BEQ      |L34.154|
000028  2803              CMP      r0,#3                 ;877
00002a  d046              BEQ      |L34.186|
00002c  2002              MOVS     r0,#2                 ;908
                  |L34.46|
00002e  f8848004          STRB     r8,[r4,#4]            ;910
000032  e7f0              B        |L34.22|
                  |L34.52|
000034  6a20              LDR      r0,[r4,#0x20]         ;880
000036  eb050755          ADD      r7,r5,r5,LSR #1       ;879
00003a  eb002157          ADD      r1,r0,r7,LSR #9       ;880
00003e  4620              MOV      r0,r4                 ;880
000040  f7fffffe          BL       move_window
000044  2800              CMP      r0,#0                 ;881
000046  d1f2              BNE      |L34.46|
000048  f3c70008          UBFX     r0,r7,#0,#9           ;882
00004c  4420              ADD      r0,r0,r4              ;882
00004e  3030              ADDS     r0,r0,#0x30           ;882
000050  b2f1              UXTB     r1,r6                 ;883
000052  07ea              LSLS     r2,r5,#31             ;883
000054  d003              BEQ      |L34.94|
000056  460a              MOV      r2,r1                 ;883
000058  7801              LDRB     r1,[r0,#0]            ;883
00005a  f362111f          BFI      r1,r2,#4,#28          ;883
                  |L34.94|
00005e  7001              STRB     r1,[r0,#0]            ;883
000060  f8848004          STRB     r8,[r4,#4]            ;885
000064  6a20              LDR      r0,[r4,#0x20]         ;886
000066  1c7f              ADDS     r7,r7,#1              ;884
000068  eb002157          ADD      r1,r0,r7,LSR #9       ;886
00006c  4620              MOV      r0,r4                 ;886
00006e  f7fffffe          BL       move_window
000072  2800              CMP      r0,#0                 ;887
000074  d1db              BNE      |L34.46|
000076  f3c70108          UBFX     r1,r7,#0,#9           ;888
00007a  4421              ADD      r1,r1,r4              ;888
00007c  3130              ADDS     r1,r1,#0x30           ;888
00007e  07ea              LSLS     r2,r5,#31             ;889
000080  d002              BEQ      |L34.136|
000082  f3c61207          UBFX     r2,r6,#4,#8           ;889
000086  e006              B        |L34.150|
                  |L34.136|
000088  780a              LDRB     r2,[r1,#0]            ;889
00008a  0a33              LSRS     r3,r6,#8              ;889
00008c  f00202f0          AND      r2,r2,#0xf0           ;889
000090  f3c30303          UBFX     r3,r3,#0,#4           ;889
000094  431a              ORRS     r2,r2,r3              ;889
                  |L34.150|
000096  700a              STRB     r2,[r1,#0]            ;889
000098  e7c9              B        |L34.46|
                  |L34.154|
00009a  6a20              LDR      r0,[r4,#0x20]         ;893
00009c  eb002115          ADD      r1,r0,r5,LSR #8       ;893
0000a0  4620              MOV      r0,r4                 ;893
0000a2  f7fffffe          BL       move_window
0000a6  2800              CMP      r0,#0                 ;894
0000a8  d1c1              BNE      |L34.46|
0000aa  b2e9              UXTB     r1,r5                 ;895
0000ac  eb040141          ADD      r1,r4,r1,LSL #1       ;895
0000b0  0a32              LSRS     r2,r6,#8              ;896
0000b2  f8016f30          STRB     r6,[r1,#0x30]!        ;896
0000b6  704a              STRB     r2,[r1,#1]            ;896
0000b8  e7b9              B        |L34.46|
                  |L34.186|
0000ba  6a20              LDR      r0,[r4,#0x20]         ;900
0000bc  eb0011d5          ADD      r1,r0,r5,LSR #7       ;900
0000c0  4620              MOV      r0,r4                 ;900
0000c2  f7fffffe          BL       move_window
0000c6  2800              CMP      r0,#0                 ;901
0000c8  d1b1              BNE      |L34.46|
0000ca  f24011ff          MOV      r1,#0x1ff             ;902
0000ce  ea010185          AND      r1,r1,r5,LSL #2       ;902
0000d2  4421              ADD      r1,r1,r4              ;902
0000d4  3130              ADDS     r1,r1,#0x30           ;902
0000d6  f04f4370          MOV      r3,#0xf0000000        ;903
0000da  f8d12001          LDR      r2,[r1,#1]            ;903
0000de  ea032202          AND      r2,r3,r2,LSL #8       ;903
0000e2  4332              ORRS     r2,r2,r6              ;903
0000e4  700a              STRB     r2,[r1,#0]            ;904
0000e6  0a13              LSRS     r3,r2,#8              ;904
0000e8  704b              STRB     r3,[r1,#1]            ;904
0000ea  0c13              LSRS     r3,r2,#16             ;904
0000ec  708b              STRB     r3,[r1,#2]            ;904
0000ee  0e12              LSRS     r2,r2,#24             ;904
0000f0  70ca              STRB     r2,[r1,#3]            ;904
0000f2  e79c              B        |L34.46|
;;;915    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;924    static
;;;925    FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;926    	FATFS *fs,			/* File system object */
;;;927    	DWORD clst			/* Cluster# to remove a chain from */
;;;928    )
;;;929    {
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
;;;930    	FRESULT res;
;;;931    	DWORD nxt;
;;;932    #if _USE_ERASE
;;;933    	DWORD scl = clst, ecl = clst, resion[2];
;;;934    #endif
;;;935    
;;;936    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2902              CMP      r1,#2
00000a  d318              BCC      |L35.62|
00000c  69a8              LDR      r0,[r5,#0x18]
00000e  42b8              CMP      r0,r7
000010  d915              BLS      |L35.62|
;;;937    		res = FR_INT_ERR;
;;;938    
;;;939    	} else {
;;;940    		res = FR_OK;
000012  2600              MOVS     r6,#0
000014  f04f0801          MOV      r8,#1                 ;931
;;;941    		while (clst < fs->n_fatent) {			/* Not a last link? */
;;;942    			nxt = get_fat(fs, clst);			/* Get cluster status */
;;;943    			if (nxt == 0) break;				/* Empty cluster? */
;;;944    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
;;;945    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
;;;946    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
;;;947    			if (res != FR_OK) break;
;;;948    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSInfo */
;;;949    				fs->free_clust++;
;;;950    				fs->fsi_flag = 1;
;;;951    			}
;;;952    #if _USE_ERASE
;;;953    			if (ecl + 1 == nxt) {	/* Next cluster is contiguous */
;;;954    				ecl = nxt;
;;;955    			} else {				/* End of contiguous clusters */ 
;;;956    				resion[0] = clust2sect(fs, scl);					/* Start sector */
;;;957    				resion[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;958    				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, resion);		/* Erase the block */
;;;959    				scl = ecl = nxt;
;;;960    			}
;;;961    #endif
;;;962    			clst = nxt;	/* Next cluster */
000018  e01d              B        |L35.86|
                  |L35.26|
00001a  4639              MOV      r1,r7                 ;942
00001c  4628              MOV      r0,r5                 ;942
00001e  f7fffffe          BL       get_fat
000022  0004              MOVS     r4,r0                 ;942
000024  d01a              BEQ      |L35.92|
000026  2c01              CMP      r4,#1                 ;944
000028  d009              BEQ      |L35.62|
00002a  1c60              ADDS     r0,r4,#1              ;945
00002c  d009              BEQ      |L35.66|
00002e  2200              MOVS     r2,#0                 ;946
000030  4639              MOV      r1,r7                 ;946
000032  4628              MOV      r0,r5                 ;946
000034  f7fffffe          BL       put_fat
000038  0006              MOVS     r6,r0                 ;946
00003a  d10f              BNE      |L35.92|
00003c  e003              B        |L35.70|
                  |L35.62|
00003e  2602              MOVS     r6,#2                 ;944
000040  e00c              B        |L35.92|
                  |L35.66|
000042  2601              MOVS     r6,#1                 ;945
000044  e00a              B        |L35.92|
                  |L35.70|
000046  6928              LDR      r0,[r5,#0x10]         ;948
000048  1c41              ADDS     r1,r0,#1              ;948
00004a  d003              BEQ      |L35.84|
00004c  1c40              ADDS     r0,r0,#1              ;949
00004e  6128              STR      r0,[r5,#0x10]         ;950
000050  f8858005          STRB     r8,[r5,#5]            ;950
                  |L35.84|
000054  4627              MOV      r7,r4
                  |L35.86|
000056  69a8              LDR      r0,[r5,#0x18]         ;941
000058  42b8              CMP      r0,r7                 ;941
00005a  d8de              BHI      |L35.26|
                  |L35.92|
;;;963    		}
;;;964    	}
;;;965    
;;;966    	return res;
00005c  4630              MOV      r0,r6
;;;967    }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;968    #endif
                          ENDP


                          AREA ||i.sync||, CODE, READONLY, ALIGN=1

                  sync PROC
;;;760    static
;;;761    FRESULT sync (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;762    	FATFS *fs	/* File system object */
;;;763    )
;;;764    {
000004  4604              MOV      r4,r0
;;;765    	FRESULT res;
;;;766    
;;;767    
;;;768    	res = move_window(fs, 0);
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       move_window
00000c  0005              MOVS     r5,r0
;;;769    	if (res == FR_OK) {
00000e  d150              BNE      |L36.178|
;;;770    		/* Update FSInfo sector if needed */
;;;771    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag) {
000010  7820              LDRB     r0,[r4,#0]
000012  2803              CMP      r0,#3
000014  d146              BNE      |L36.164|
000016  7960              LDRB     r0,[r4,#5]
000018  b3f0              CBZ      r0,|L36.152|
;;;772    			fs->winsect = 0;
00001a  2600              MOVS     r6,#0
;;;773    			/* Create FSInfo structure */
;;;774    			mem_set(fs->win, 0, 512);
00001c  f1040030          ADD      r0,r4,#0x30
000020  f44f7200          MOV      r2,#0x200
000024  4631              MOV      r1,r6
000026  4607              MOV      r7,r0
000028  62e6              STR      r6,[r4,#0x2c]
00002a  f7fffffe          BL       mem_set
;;;775    			ST_WORD(fs->win+BS_55AA, 0xAA55);
00002e  2055              MOVS     r0,#0x55
000030  f884022e          STRB     r0,[r4,#0x22e]
000034  20aa              MOVS     r0,#0xaa
000036  f884022f          STRB     r0,[r4,#0x22f]
;;;776    			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
00003a  2052              MOVS     r0,#0x52
00003c  f8840030          STRB     r0,[r4,#0x30]
000040  f8840031          STRB     r0,[r4,#0x31]
000044  2161              MOVS     r1,#0x61
000046  f8841032          STRB     r1,[r4,#0x32]
00004a  2241              MOVS     r2,#0x41
00004c  f8842033          STRB     r2,[r4,#0x33]
;;;777    			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
000050  2072              MOVS     r0,#0x72
000052  f8840214          STRB     r0,[r4,#0x214]
000056  f8840215          STRB     r0,[r4,#0x215]
00005a  f8842216          STRB     r2,[r4,#0x216]
00005e  f8841217          STRB     r1,[r4,#0x217]
;;;778    			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
000062  6920              LDR      r0,[r4,#0x10]
000064  f8840218          STRB     r0,[r4,#0x218]
000068  0a01              LSRS     r1,r0,#8
00006a  f8841219          STRB     r1,[r4,#0x219]
00006e  0c01              LSRS     r1,r0,#16
000070  f884121a          STRB     r1,[r4,#0x21a]
000074  0e00              LSRS     r0,r0,#24
000076  f884021b          STRB     r0,[r4,#0x21b]
;;;779    			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
00007a  68e0              LDR      r0,[r4,#0xc]
00007c  f884021c          STRB     r0,[r4,#0x21c]
000080  0a01              LSRS     r1,r0,#8
000082  f884121d          STRB     r1,[r4,#0x21d]
000086  0c01              LSRS     r1,r0,#16
000088  0e00              LSRS     r0,r0,#24
00008a  f884121e          STRB     r1,[r4,#0x21e]
00008e  f884021f          STRB     r0,[r4,#0x21f]
;;;780    			/* Write it into the FSInfo sector */
;;;781    			disk_write(fs->drv, fs->win, fs->fsi_sector, 1);
000092  7860              LDRB     r0,[r4,#1]
000094  2301              MOVS     r3,#1
000096  e000              B        |L36.154|
                  |L36.152|
000098  e004              B        |L36.164|
                  |L36.154|
00009a  4639              MOV      r1,r7
00009c  6962              LDR      r2,[r4,#0x14]
00009e  f7fffffe          BL       disk_write
;;;782    			fs->fsi_flag = 0;
0000a2  7166              STRB     r6,[r4,#5]
                  |L36.164|
;;;783    		}
;;;784    		/* Make sure that no pending write process in the physical drive */
;;;785    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
0000a4  2200              MOVS     r2,#0
0000a6  7860              LDRB     r0,[r4,#1]
0000a8  4611              MOV      r1,r2
0000aa  f7fffffe          BL       disk_ioctl
0000ae  b100              CBZ      r0,|L36.178|
;;;786    			res = FR_DISK_ERR;
0000b0  2501              MOVS     r5,#1
                  |L36.178|
;;;787    	}
;;;788    
;;;789    	return res;
0000b2  4628              MOV      r0,r5
;;;790    }
0000b4  e8bd81f0          POP      {r4-r8,pc}
;;;791    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2171   static
;;;2172   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2173   	FATFS *fs,		/* Pointer to the file system object */
;;;2174   	WORD id			/* Member id of the target object to be checked */
;;;2175   )
;;;2176   {
;;;2177   	if (!fs || !fs->fs_type || fs->id != id)
000002  b120              CBZ      r0,|L37.14|
000004  7802              LDRB     r2,[r0,#0]
000006  b112              CBZ      r2,|L37.14|
000008  88c2              LDRH     r2,[r0,#6]
00000a  428a              CMP      r2,r1
00000c  d001              BEQ      |L37.18|
                  |L37.14|
;;;2178   		return FR_INVALID_OBJECT;
00000e  2009              MOVS     r0,#9
                  |L37.16|
;;;2179   
;;;2180   	ENTER_FF(fs);		/* Lock file system */
;;;2181   
;;;2182   	if (disk_status(fs->drv) & STA_NOINIT)
;;;2183   		return FR_NOT_READY;
;;;2184   
;;;2185   	return FR_OK;
;;;2186   }
000010  bd10              POP      {r4,pc}
                  |L37.18|
000012  7840              LDRB     r0,[r0,#1]            ;2182
000014  f7fffffe          BL       disk_status
000018  07c0              LSLS     r0,r0,#31             ;2182
00001a  d0f9              BEQ      |L37.16|
00001c  2003              MOVS     r0,#3                 ;2183
00001e  bd10              POP      {r4,pc}
;;;2187   
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Fsid
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  FatFs
                          DCD      0x00000000
