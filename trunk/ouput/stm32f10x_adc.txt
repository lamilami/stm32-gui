; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_adc.o --depend=.\ouput\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_adc.crf Source\FWLib\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;1080     */
;;;1081   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  6842              LDR      r2,[r0,#4]
;;;1082   {
;;;1083     uint32_t tmpreg = 0;
;;;1084     /* Check the parameters */
;;;1085     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1086     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1087     /* Get the old register value */
;;;1088     tmpreg = ADCx->CR1;
;;;1089     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1090     tmpreg &= CR1_AWDMode_Reset;
000002  4b02              LDR      r3,|L1.12|
000004  401a              ANDS     r2,r2,r3
;;;1091     /* Set the analog watchdog enable mode */
;;;1092     tmpreg |= ADC_AnalogWatchdog;
000006  430a              ORRS     r2,r2,r1
;;;1093     /* Store the new register value */
;;;1094     ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;1095   }
00000a  4770              BX       lr
;;;1096   
                          ENDP

                  |L1.12|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1143     */
;;;1144   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  6842              LDR      r2,[r0,#4]
;;;1145   {
;;;1146     uint32_t tmpreg = 0;
;;;1147     /* Check the parameters */
;;;1148     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1149     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1150     /* Get the old register value */
;;;1151     tmpreg = ADCx->CR1;
;;;1152     /* Clear the Analog watchdog channel select bits */
;;;1153     tmpreg &= CR1_AWDCH_Reset;
000002  f022021f          BIC      r2,r2,#0x1f
;;;1154     /* Set the Analog watchdog channel */
;;;1155     tmpreg |= ADC_Channel;
000006  430a              ORRS     r2,r2,r1
;;;1156     /* Store the new register value */
;;;1157     ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;1158   }
00000a  4770              BX       lr
;;;1159   
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1105     */
;;;1106   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  6241              STR      r1,[r0,#0x24]
;;;1107                                           uint16_t LowThreshold)
;;;1108   {
;;;1109     /* Check the parameters */
;;;1110     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1111     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1112     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1113     /* Set the ADCx high threshold */
;;;1114     ADCx->HTR = HighThreshold;
;;;1115     /* Set the ADCx low threshold */
;;;1116     ADCx->LTR = LowThreshold;
000002  6282              STR      r2,[r0,#0x28]
;;;1117   }
000004  4770              BX       lr
;;;1118   
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;732      */
;;;733    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;734    {
;;;735      /* Check the parameters */
;;;736      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;737      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;738      if (NewState != DISABLE)
;;;739      {
;;;740        /* Enable the selected ADC automatic injected group conversion */
;;;741        ADCx->CR1 |= CR1_JAUTO_Set;
;;;742      }
;;;743      else
;;;744      {
;;;745        /* Disable the selected ADC automatic injected group conversion */
;;;746        ADCx->CR1 &= CR1_JAUTO_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L4.12|
000006  f4416180          ORR      r1,r1,#0x400          ;741
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L4.16|
000010  6041              STR      r1,[r0,#4]            ;741
;;;747      }
;;;748    }
000012  4770              BX       lr
;;;749    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1226     */
;;;1227   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  43c9              MVNS     r1,r1
;;;1228   {
;;;1229     /* Check the parameters */
;;;1230     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1231     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1232     /* Clear the selected ADC flags */
;;;1233     ADCx->SR = ~(uint32_t)ADC_FLAG;
000002  6001              STR      r1,[r0,#0]
;;;1234   }
000004  4770              BX       lr
;;;1235   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1281     */
;;;1282   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  ea6f2111          MVN      r1,r1,LSR #8
;;;1283   {
;;;1284     uint8_t itmask = 0;
;;;1285     /* Check the parameters */
;;;1286     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1287     assert_param(IS_ADC_IT(ADC_IT));
;;;1288     /* Get the ADC IT index */
;;;1289     itmask = (uint8_t)(ADC_IT >> 8);
;;;1290     /* Clear the selected ADC interrupt pending bits */
;;;1291     ADCx->SR = ~(uint32_t)itmask;
000004  6001              STR      r1,[r0,#0]
;;;1292   }
000006  4770              BX       lr
;;;1293   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;297      */
;;;298    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;299    {
;;;300      /* Check the parameters */
;;;301      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;302      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;303      if (NewState != DISABLE)
;;;304      {
;;;305        /* Set the ADON bit to wake up the ADC from power down mode */
;;;306        ADCx->CR2 |= CR2_ADON_Set;
;;;307      }
;;;308      else
;;;309      {
;;;310        /* Disable the selected ADC peripheral */
;;;311        ADCx->CR2 &= CR2_ADON_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;306
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  6081              STR      r1,[r0,#8]            ;306
;;;312      }
;;;313    }
000012  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;322      */
;;;323    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;324    {
;;;325      /* Check the parameters */
;;;326      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;327      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;328      if (NewState != DISABLE)
;;;329      {
;;;330        /* Enable the selected ADC DMA request */
;;;331        ADCx->CR2 |= CR2_DMA_Set;
;;;332      }
;;;333      else
;;;334      {
;;;335        /* Disable the selected ADC DMA request */
;;;336        ADCx->CR2 &= CR2_DMA_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L8.12|
000006  f4417180          ORR      r1,r1,#0x100          ;331
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L8.16|
000010  6081              STR      r1,[r0,#8]            ;331
;;;337      }
;;;338    }
000012  4770              BX       lr
;;;339    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;177      */
;;;178    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  490d              LDR      r1,|L9.56|
;;;179    {
000002  b510              PUSH     {r4,lr}
;;;180      /* Check the parameters */
;;;181      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;182      
;;;183      if (ADCx == ADC1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L9.14|
;;;184      {
;;;185        /* Enable ADC1 reset state */
;;;186        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  1544              ASRS     r4,r0,#21
;;;187        /* Release ADC1 from reset state */
;;;188        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
00000c  e00a              B        |L9.36|
                  |L9.14|
;;;189      }
;;;190      else if (ADCx == ADC2)
00000e  490b              LDR      r1,|L9.60|
000010  4288              CMP      r0,r1
000012  d102              BNE      |L9.26|
;;;191      {
;;;192        /* Enable ADC2 reset state */
;;;193        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
000014  2101              MOVS     r1,#1
000016  1504              ASRS     r4,r0,#20
;;;194        /* Release ADC2 from reset state */
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
000018  e004              B        |L9.36|
                  |L9.26|
;;;196      }
;;;197      else
;;;198      {
;;;199        if (ADCx == ADC3)
00001a  4909              LDR      r1,|L9.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L9.54|
;;;200        {
;;;201          /* Enable ADC3 reset state */
;;;202          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000020  2101              MOVS     r1,#1
000022  03cc              LSLS     r4,r1,#15
                  |L9.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;203          /* Release ADC3 from reset state */
;;;204          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L9.54|
;;;205        }
;;;206      }
;;;207    }
000036  bd10              POP      {r4,pc}
;;;208    
                          ENDP

                  |L9.56|
                          DCD      0x40012400
                  |L9.60|
                          DCD      0x40012800
                  |L9.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;507      */
;;;508    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  6842              LDR      r2,[r0,#4]
;;;509    {
;;;510      uint32_t tmpreg1 = 0;
;;;511      uint32_t tmpreg2 = 0;
;;;512      /* Check the parameters */
;;;513      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;514      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;515      /* Get the old register value */
;;;516      tmpreg1 = ADCx->CR1;
;;;517      /* Clear the old discontinuous mode channel count */
;;;518      tmpreg1 &= CR1_DISCNUM_Reset;
;;;519      /* Set the discontinuous mode channel count */
;;;520      tmpreg2 = Number - 1;
000002  1e49              SUBS     r1,r1,#1
000004  f4224260          BIC      r2,r2,#0xe000         ;518
;;;521      tmpreg1 |= tmpreg2 << 13;
000008  ea423141          ORR      r1,r2,r1,LSL #13
;;;522      /* Store the new register value */
;;;523      ADCx->CR1 = tmpreg1;
00000c  6041              STR      r1,[r0,#4]
;;;524    }
00000e  4770              BX       lr
;;;525    
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;534      */
;;;535    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;536    {
;;;537      /* Check the parameters */
;;;538      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;539      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;540      if (NewState != DISABLE)
;;;541      {
;;;542        /* Enable the selected ADC regular discontinuous mode */
;;;543        ADCx->CR1 |= CR1_DISCEN_Set;
;;;544      }
;;;545      else
;;;546      {
;;;547        /* Disable the selected ADC regular discontinuous mode */
;;;548        ADCx->CR1 &= CR1_DISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L11.12|
000006  f4416100          ORR      r1,r1,#0x800          ;543
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L11.16|
000010  6041              STR      r1,[r0,#4]            ;543
;;;549      }
;;;550    }
000012  4770              BX       lr
;;;551    
                          ENDP


                          AREA ||i.ADC_ExternalTrigConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigConvCmd PROC
;;;684      */
;;;685    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;686    {
;;;687      /* Check the parameters */
;;;688      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;689      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;690      if (NewState != DISABLE)
;;;691      {
;;;692        /* Enable the selected ADC conversion on external event */
;;;693        ADCx->CR2 |= CR2_EXTTRIG_Set;
;;;694      }
;;;695      else
;;;696      {
;;;697        /* Disable the selected ADC conversion on external event */
;;;698        ADCx->CR2 &= CR2_EXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L12.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;693
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L12.16|
000010  6081              STR      r1,[r0,#8]            ;693
;;;699      }
;;;700    }
000012  4770              BX       lr
;;;701    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;822      */
;;;823    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;824    {
;;;825      /* Check the parameters */
;;;826      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;827      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;828      if (NewState != DISABLE)
;;;829      {
;;;830        /* Enable the selected ADC external event selection for injected group */
;;;831        ADCx->CR2 |= CR2_JEXTTRIG_Set;
;;;832      }
;;;833      else
;;;834      {
;;;835        /* Disable the selected ADC external event selection for injected group */
;;;836        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L13.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;831
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L13.16|
000010  6081              STR      r1,[r0,#8]            ;831
;;;837      }
;;;838    }
000012  4770              BX       lr
;;;839    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;797      */
;;;798    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  6882              LDR      r2,[r0,#8]
;;;799    {
;;;800      uint32_t tmpreg = 0;
;;;801      /* Check the parameters */
;;;802      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;803      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;804      /* Get the old register value */
;;;805      tmpreg = ADCx->CR2;
;;;806      /* Clear the old external event selection for injected group */
;;;807      tmpreg &= CR2_JEXTSEL_Reset;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;808      /* Set the external event selection for injected group */
;;;809      tmpreg |= ADC_ExternalTrigInjecConv;
000006  430a              ORRS     r2,r2,r1
;;;810      /* Store the new register value */
;;;811      ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;812    }
00000a  4770              BX       lr
;;;813    
                          ENDP


                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationStatus PROC
;;;428      */
;;;429    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;430    {
;;;431      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;432      /* Check the parameters */
;;;433      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;434      /* Check the status of CAL bit */
;;;435      if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0749              LSLS     r1,r1,#29
000008  d500              BPL      |L15.12|
;;;436      {
;;;437        /* CAL bit is set: calibration on going */
;;;438        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L15.12|
;;;439      }
;;;440      else
;;;441      {
;;;442        /* CAL bit is reset: end of calibration */
;;;443        bitstatus = RESET;
;;;444      }
;;;445      /* Return the CAL bit status */
;;;446      return  bitstatus;
;;;447    }
00000c  4770              BX       lr
;;;448    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;706      */
;;;707    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;708    {
;;;709      /* Check the parameters */
;;;710      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;711      /* Return the selected ADC conversion value */
;;;712      return (uint16_t) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;713    }
000004  4770              BX       lr
;;;714    
                          ENDP


                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;718      */
;;;719    uint32_t ADC_GetDualModeConversionValue(void)
000000  4801              LDR      r0,|L17.8|
;;;720    {
;;;721      /* Return the dual mode conversion value */
;;;722      return (*(__IO uint32_t *) DR_ADDRESS);
000002  6800              LDR      r0,[r0,#0]
;;;723    }
000004  4770              BX       lr
;;;724    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x4001244c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1193     */
;;;1194   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1195   {
;;;1196     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1197     /* Check the parameters */
;;;1198     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1199     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1200     /* Check the status of the specified ADC flag */
;;;1201     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L18.12|
;;;1202     {
;;;1203       /* ADC_FLAG is set */
;;;1204       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;1205     }
;;;1206     else
;;;1207     {
;;;1208       /* ADC_FLAG is reset */
;;;1209       bitstatus = RESET;
;;;1210     }
;;;1211     /* Return the ADC_FLAG status */
;;;1212     return  bitstatus;
;;;1213   }
00000c  4770              BX       lr
;;;1214   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1245     */
;;;1246   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;1247   {
000002  4602              MOV      r2,r0
;;;1248     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1249     uint32_t itmask = 0, enablestatus = 0;
;;;1250     /* Check the parameters */
;;;1251     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1252     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1253     /* Get the ADC IT index */
;;;1254     itmask = ADC_IT >> 8;
;;;1255     /* Get the ADC_IT enable bit status */
;;;1256     enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
000006  6854              LDR      r4,[r2,#4]
000008  0a0b              LSRS     r3,r1,#8              ;1254
00000a  b2c9              UXTB     r1,r1
00000c  400c              ANDS     r4,r4,r1
;;;1257     /* Check the status of the specified ADC interrupt */
;;;1258     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
00000e  6811              LDR      r1,[r2,#0]
000010  4219              TST      r1,r3
000012  d002              BEQ      |L19.26|
000014  2c00              CMP      r4,#0
000016  d000              BEQ      |L19.26|
;;;1259     {
;;;1260       /* ADC_IT is set */
;;;1261       bitstatus = SET;
000018  2001              MOVS     r0,#1
                  |L19.26|
;;;1262     }
;;;1263     else
;;;1264     {
;;;1265       /* ADC_IT is reset */
;;;1266       bitstatus = RESET;
;;;1267     }
;;;1268     /* Return the ADC_IT status */
;;;1269     return  bitstatus;
;;;1270   }
00001a  bd10              POP      {r4,pc}
;;;1271   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1050     */
;;;1051   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  4408              ADD      r0,r0,r1
;;;1052   {
;;;1053     __IO uint32_t tmp = 0;
;;;1054     
;;;1055     /* Check the parameters */
;;;1056     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1057     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1058   
;;;1059     tmp = (uint32_t)ADCx;
;;;1060     tmp += ADC_InjectedChannel + JDR_Offset;
;;;1061     
;;;1062     /* Returns the selected injected channel conversion data value */
;;;1063     return (uint16_t) (*(__IO uint32_t*)  tmp);   
000002  6a80              LDR      r0,[r0,#0x28]
000004  b280              UXTH     r0,r0
;;;1064   }
000006  4770              BX       lr
;;;1065   
                          ENDP


                          AREA ||i.ADC_GetResetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetResetCalibrationStatus PROC
;;;390      */
;;;391    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;392    {
;;;393      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;394      /* Check the parameters */
;;;395      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;396      /* Check the status of RSTCAL bit */
;;;397      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0709              LSLS     r1,r1,#28
000008  d500              BPL      |L21.12|
;;;398      {
;;;399        /* RSTCAL bit is set */
;;;400        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L21.12|
;;;401      }
;;;402      else
;;;403      {
;;;404        /* RSTCAL bit is reset */
;;;405        bitstatus = RESET;
;;;406      }
;;;407      /* Return the RSTCAL bit status */
;;;408      return  bitstatus;
;;;409    }
00000c  4770              BX       lr
;;;410    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;479      */
;;;480    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;481    {
;;;482      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;483      /* Check the parameters */
;;;484      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;485      /* Check the status of SWSTART bit */
;;;486      if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0249              LSLS     r1,r1,#9
000008  d500              BPL      |L22.12|
;;;487      {
;;;488        /* SWSTART bit is set */
;;;489        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L22.12|
;;;490      }
;;;491      else
;;;492      {
;;;493        /* SWSTART bit is reset */
;;;494        bitstatus = RESET;
;;;495      }
;;;496      /* Return the SWSTART bit status */
;;;497      return  bitstatus;
;;;498    }
00000c  4770              BX       lr
;;;499    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;871      */
;;;872    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;873    {
;;;874      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;875      /* Check the parameters */
;;;876      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;877      /* Check the status of JSWSTART bit */
;;;878      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0289              LSLS     r1,r1,#10
000008  d500              BPL      |L23.12|
;;;879      {
;;;880        /* JSWSTART bit is set */
;;;881        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L23.12|
;;;882      }
;;;883      else
;;;884      {
;;;885        /* JSWSTART bit is reset */
;;;886        bitstatus = RESET;
;;;887      }
;;;888      /* Return the JSWSTART bit status */
;;;889      return  bitstatus;
;;;890    }
00000c  4770              BX       lr
;;;891    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;351      */
;;;352    void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;353    {
;;;354      uint8_t itmask = 0;
;;;355      /* Check the parameters */
;;;356      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;357      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;358      assert_param(IS_ADC_IT(ADC_IT));
;;;359      /* Get the ADC IT index */
;;;360      itmask = (uint8_t)ADC_IT;
;;;361      if (NewState != DISABLE)
;;;362      {
;;;363        /* Enable the selected ADC interrupts */
;;;364        ADCx->CR1 |= itmask;
;;;365      }
;;;366      else
;;;367      {
;;;368        /* Disable the selected ADC interrupts */
;;;369        ADCx->CR1 &= (~(uint32_t)itmask);
000002  6842              LDR      r2,[r0,#4]
000004  b2c9              UXTB     r1,r1                 ;360
000006  d001              BEQ      |L24.12|
000008  430a              ORRS     r2,r2,r1              ;364
00000a  e000              B        |L24.14|
                  |L24.12|
00000c  438a              BICS     r2,r2,r1
                  |L24.14|
00000e  6042              STR      r2,[r0,#4]            ;364
;;;370      }
;;;371    }
000010  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;216      */
;;;217    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;218    {
;;;219      uint32_t tmpreg1 = 0;
;;;220      uint8_t tmpreg2 = 0;
;;;221      /* Check the parameters */
;;;222      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;223      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;224      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;225      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;226      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;227      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;228      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;229    
;;;230      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;231      /* Get the ADCx CR1 value */
;;;232      tmpreg1 = ADCx->CR1;
000002  6842              LDR      r2,[r0,#4]
;;;233      /* Clear DUALMOD and SCAN bits */
;;;234      tmpreg1 &= CR1_CLEAR_Mask;
000004  4b0e              LDR      r3,|L25.64|
;;;235      /* Configure ADCx: Dual mode and scan conversion mode */
;;;236      /* Set DUALMOD bits according to ADC_Mode value */
;;;237      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;238      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
000006  790c              LDRB     r4,[r1,#4]
000008  401a              ANDS     r2,r2,r3              ;234
00000a  680b              LDR      r3,[r1,#0]
00000c  ea422204          ORR      r2,r2,r4,LSL #8
000010  4313              ORRS     r3,r3,r2
;;;239      /* Write to ADCx CR1 */
;;;240      ADCx->CR1 = tmpreg1;
000012  6043              STR      r3,[r0,#4]
;;;241    
;;;242      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;243      /* Get the ADCx CR2 value */
;;;244      tmpreg1 = ADCx->CR2;
000014  6882              LDR      r2,[r0,#8]
;;;245      /* Clear CONT, ALIGN and EXTSEL bits */
;;;246      tmpreg1 &= CR2_CLEAR_Mask;
000016  4b0b              LDR      r3,|L25.68|
000018  401a              ANDS     r2,r2,r3
00001a  e9d14302          LDRD     r4,r3,[r1,#8]
;;;247      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;248      /* Set ALIGN bit according to ADC_DataAlign value */
;;;249      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;250      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;251      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00001e  4323              ORRS     r3,r3,r4
000020  794c              LDRB     r4,[r1,#5]
000022  ea420244          ORR      r2,r2,r4,LSL #1
000026  4313              ORRS     r3,r3,r2
;;;252                ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;253      /* Write to ADCx CR2 */
;;;254      ADCx->CR2 = tmpreg1;
000028  6083              STR      r3,[r0,#8]
;;;255    
;;;256      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;257      /* Get the ADCx SQR1 value */
;;;258      tmpreg1 = ADCx->SQR1;
00002a  6ac2              LDR      r2,[r0,#0x2c]
;;;259      /* Clear L bits */
;;;260      tmpreg1 &= SQR1_CLEAR_Mask;
;;;261      /* Configure ADCx: regular channel sequence length */
;;;262      /* Set L bits according to ADC_NbrOfChannel value */
;;;263      tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
00002c  7c09              LDRB     r1,[r1,#0x10]
00002e  f4220270          BIC      r2,r2,#0xf00000       ;260
000032  1e49              SUBS     r1,r1,#1
000034  b2c9              UXTB     r1,r1
;;;264      tmpreg1 |= (uint32_t)tmpreg2 << 20;
000036  ea425101          ORR      r1,r2,r1,LSL #20
;;;265      /* Write to ADCx SQR1 */
;;;266      ADCx->SQR1 = tmpreg1;
00003a  62c1              STR      r1,[r0,#0x2c]
;;;267    }
00003c  bd10              POP      {r4,pc}
;;;268    
                          ENDP

00003e  0000              DCW      0x0000
                  |L25.64|
                          DCD      0xfff0feff
                  |L25.68|
                          DCD      0xfff1f7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;928      */
;;;929    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;930    {
;;;931      uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;932      /* Check the parameters */
;;;933      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;934      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;935      assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;936      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;937      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;938      if (ADC_Channel > ADC_Channel_9)
;;;939      {
;;;940        /* Get the old register value */
;;;941        tmpreg1 = ADCx->SMPR1;
;;;942        /* Calculate the mask to clear */
;;;943        tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
000002  2607              MOVS     r6,#7
000004  2909              CMP      r1,#9                 ;938
000006  d90a              BLS      |L26.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;941
00000a  f1a1040a          SUB      r4,r1,#0xa
00000e  eb040444          ADD      r4,r4,r4,LSL #1
000012  40a6              LSLS     r6,r6,r4
;;;944        /* Clear the old channel sample time */
;;;945        tmpreg1 &= ~tmpreg2;
000014  43b5              BICS     r5,r5,r6
;;;946        /* Calculate the mask to set */
;;;947        tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
000016  40a3              LSLS     r3,r3,r4
;;;948        /* Set the new channel sample time */
;;;949        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;950        /* Store the new register value */
;;;951        ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L26.46|
                  |L26.30|
;;;952      }
;;;953      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;954      {
;;;955        /* Get the old register value */
;;;956        tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;957        /* Calculate the mask to clear */
;;;958        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000020  eb010441          ADD      r4,r1,r1,LSL #1
000024  40a6              LSLS     r6,r6,r4
;;;959        /* Clear the old channel sample time */
;;;960        tmpreg1 &= ~tmpreg2;
000026  43b5              BICS     r5,r5,r6
;;;961        /* Calculate the mask to set */
;;;962        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40a3              LSLS     r3,r3,r4
;;;963        /* Set the new channel sample time */
;;;964        tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;965        /* Store the new register value */
;;;966        ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L26.46|
;;;967      }
;;;968      /* Rank configuration */
;;;969      /* Get the old register value */
;;;970      tmpreg1 = ADCx->JSQR;
00002e  6b83              LDR      r3,[r0,#0x38]
;;;971      /* Get JL value: Number = JL+1 */
;;;972      tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000030  f3c35401          UBFX     r4,r3,#20,#2
;;;973      /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;974      tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000034  1b12              SUBS     r2,r2,r4
000036  1c92              ADDS     r2,r2,#2
000038  eb020282          ADD      r2,r2,r2,LSL #2
00003c  241f              MOVS     r4,#0x1f
00003e  4094              LSLS     r4,r4,r2
;;;975      /* Clear the old JSQx bits for the selected rank */
;;;976      tmpreg1 &= ~tmpreg2;
000040  43a3              BICS     r3,r3,r4
;;;977      /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;978      tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000042  4091              LSLS     r1,r1,r2
;;;979      /* Set the JSQx bits for the selected rank */
;;;980      tmpreg1 |= tmpreg2;
000044  430b              ORRS     r3,r3,r1
;;;981      /* Store the new register value */
;;;982      ADCx->JSQR = tmpreg1;
000046  6383              STR      r3,[r0,#0x38]
;;;983    }
000048  bd70              POP      {r4-r6,pc}
;;;984    
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;758      */
;;;759    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;760    {
;;;761      /* Check the parameters */
;;;762      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;763      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;764      if (NewState != DISABLE)
;;;765      {
;;;766        /* Enable the selected ADC injected discontinuous mode */
;;;767        ADCx->CR1 |= CR1_JDISCEN_Set;
;;;768      }
;;;769      else
;;;770      {
;;;771        /* Disable the selected ADC injected discontinuous mode */
;;;772        ADCx->CR1 &= CR1_JDISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L27.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;767
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L27.16|
000010  6041              STR      r1,[r0,#4]            ;767
;;;773      }
;;;774    }
000012  4770              BX       lr
;;;775    
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;991      */
;;;992    void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  6b82              LDR      r2,[r0,#0x38]
;;;993    {
;;;994      uint32_t tmpreg1 = 0;
;;;995      uint32_t tmpreg2 = 0;
;;;996      /* Check the parameters */
;;;997      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;998      assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;999      
;;;1000     /* Get the old register value */
;;;1001     tmpreg1 = ADCx->JSQR;
;;;1002     /* Clear the old injected sequnence lenght JL bits */
;;;1003     tmpreg1 &= JSQR_JL_Reset;
;;;1004     /* Set the injected sequnence lenght JL bits */
;;;1005     tmpreg2 = Length - 1; 
000002  1e49              SUBS     r1,r1,#1
000004  f4221240          BIC      r2,r2,#0x300000       ;1003
;;;1006     tmpreg1 |= tmpreg2 << 20;
000008  ea425101          ORR      r1,r2,r1,LSL #20
;;;1007     /* Store the new register value */
;;;1008     ADCx->JSQR = tmpreg1;
00000c  6381              STR      r1,[r0,#0x38]
;;;1009   }
00000e  4770              BX       lr
;;;1010   
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;588      */
;;;589    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;590    {
;;;591      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;592      /* Check the parameters */
;;;593      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;594      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;595      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;596      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;597      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;598      if (ADC_Channel > ADC_Channel_9)
;;;599      {
;;;600        /* Get the old register value */
;;;601        tmpreg1 = ADCx->SMPR1;
;;;602        /* Calculate the mask to clear */
;;;603        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000002  2607              MOVS     r6,#7
000004  2909              CMP      r1,#9                 ;598
000006  d90a              BLS      |L29.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;601
00000a  f1a1040a          SUB      r4,r1,#0xa
00000e  eb040444          ADD      r4,r4,r4,LSL #1
000012  40a6              LSLS     r6,r6,r4
;;;604        /* Clear the old channel sample time */
;;;605        tmpreg1 &= ~tmpreg2;
000014  43b5              BICS     r5,r5,r6
;;;606        /* Calculate the mask to set */
;;;607        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000016  40a3              LSLS     r3,r3,r4
;;;608        /* Set the new channel sample time */
;;;609        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;610        /* Store the new register value */
;;;611        ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L29.46|
                  |L29.30|
;;;612      }
;;;613      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;614      {
;;;615        /* Get the old register value */
;;;616        tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;617        /* Calculate the mask to clear */
;;;618        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000020  eb010441          ADD      r4,r1,r1,LSL #1
000024  40a6              LSLS     r6,r6,r4
;;;619        /* Clear the old channel sample time */
;;;620        tmpreg1 &= ~tmpreg2;
000026  43b5              BICS     r5,r5,r6
;;;621        /* Calculate the mask to set */
;;;622        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40a3              LSLS     r3,r3,r4
;;;623        /* Set the new channel sample time */
;;;624        tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;625        /* Store the new register value */
;;;626        ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L29.46|
;;;627      }
;;;628      /* For Rank 1 to 6 */
;;;629      if (Rank < 7)
;;;630      {
;;;631        /* Get the old register value */
;;;632        tmpreg1 = ADCx->SQR3;
;;;633        /* Calculate the mask to clear */
;;;634        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
00002e  231f              MOVS     r3,#0x1f
000030  2a07              CMP      r2,#7                 ;629
000032  d209              BCS      |L29.72|
000034  6b44              LDR      r4,[r0,#0x34]         ;632
000036  1e52              SUBS     r2,r2,#1
000038  eb020282          ADD      r2,r2,r2,LSL #2
00003c  4093              LSLS     r3,r3,r2
;;;635        /* Clear the old SQx bits for the selected rank */
;;;636        tmpreg1 &= ~tmpreg2;
00003e  439c              BICS     r4,r4,r3
;;;637        /* Calculate the mask to set */
;;;638        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000040  4091              LSLS     r1,r1,r2
;;;639        /* Set the SQx bits for the selected rank */
;;;640        tmpreg1 |= tmpreg2;
000042  430c              ORRS     r4,r4,r1
;;;641        /* Store the new register value */
;;;642        ADCx->SQR3 = tmpreg1;
000044  6344              STR      r4,[r0,#0x34]
;;;643      }
;;;644      /* For Rank 7 to 12 */
;;;645      else if (Rank < 13)
;;;646      {
;;;647        /* Get the old register value */
;;;648        tmpreg1 = ADCx->SQR2;
;;;649        /* Calculate the mask to clear */
;;;650        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
;;;651        /* Clear the old SQx bits for the selected rank */
;;;652        tmpreg1 &= ~tmpreg2;
;;;653        /* Calculate the mask to set */
;;;654        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
;;;655        /* Set the SQx bits for the selected rank */
;;;656        tmpreg1 |= tmpreg2;
;;;657        /* Store the new register value */
;;;658        ADCx->SQR2 = tmpreg1;
;;;659      }
;;;660      /* For Rank 13 to 16 */
;;;661      else
;;;662      {
;;;663        /* Get the old register value */
;;;664        tmpreg1 = ADCx->SQR1;
;;;665        /* Calculate the mask to clear */
;;;666        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
;;;667        /* Clear the old SQx bits for the selected rank */
;;;668        tmpreg1 &= ~tmpreg2;
;;;669        /* Calculate the mask to set */
;;;670        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
;;;671        /* Set the SQx bits for the selected rank */
;;;672        tmpreg1 |= tmpreg2;
;;;673        /* Store the new register value */
;;;674        ADCx->SQR1 = tmpreg1;
;;;675      }
;;;676    }
000046  bd70              POP      {r4-r6,pc}
                  |L29.72|
000048  2a0d              CMP      r2,#0xd               ;645
00004a  d209              BCS      |L29.96|
00004c  6b04              LDR      r4,[r0,#0x30]         ;648
00004e  1fd2              SUBS     r2,r2,#7              ;650
000050  eb020282          ADD      r2,r2,r2,LSL #2       ;650
000054  4093              LSLS     r3,r3,r2              ;650
000056  439c              BICS     r4,r4,r3              ;652
000058  4091              LSLS     r1,r1,r2              ;654
00005a  430c              ORRS     r4,r4,r1              ;656
00005c  6304              STR      r4,[r0,#0x30]         ;658
00005e  bd70              POP      {r4-r6,pc}
                  |L29.96|
000060  6ac4              LDR      r4,[r0,#0x2c]         ;664
000062  3a0d              SUBS     r2,r2,#0xd            ;666
000064  eb020282          ADD      r2,r2,r2,LSL #2       ;666
000068  4093              LSLS     r3,r3,r2              ;666
00006a  439c              BICS     r4,r4,r3              ;668
00006c  4091              LSLS     r1,r1,r2              ;670
00006e  430c              ORRS     r4,r4,r1              ;672
000070  62c4              STR      r4,[r0,#0x2c]         ;674
000072  bd70              POP      {r4-r6,pc}
;;;677    
                          ENDP


                          AREA ||i.ADC_ResetCalibration||, CODE, READONLY, ALIGN=1

                  ADC_ResetCalibration PROC
;;;377      */
;;;378    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;379    {
;;;380      /* Check the parameters */
;;;381      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;382      /* Resets the selected ADC calibartion registers */  
;;;383      ADCx->CR2 |= CR2_RSTCAL_Set;
000002  f0410108          ORR      r1,r1,#8
000006  6081              STR      r1,[r0,#8]
;;;384    }
000008  4770              BX       lr
;;;385    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1023     */
;;;1024   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  5042              STR      r2,[r0,r1]
;;;1025   {
;;;1026     __IO uint32_t tmp = 0;
;;;1027     
;;;1028     /* Check the parameters */
;;;1029     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1030     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1031     assert_param(IS_ADC_OFFSET(Offset));  
;;;1032     
;;;1033     tmp = (uint32_t)ADCx;
;;;1034     tmp += ADC_InjectedChannel;
;;;1035     
;;;1036     /* Set the selected injected channel data offset */
;;;1037     *(__IO uint32_t *) tmp = (uint32_t)Offset;
;;;1038   }
000002  4770              BX       lr
;;;1039   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConvCmd PROC
;;;455      */
;;;456    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;457    {
;;;458      /* Check the parameters */
;;;459      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;460      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;461      if (NewState != DISABLE)
;;;462      {
;;;463        /* Enable the selected ADC conversion on external event and start the selected
;;;464           ADC conversion */
;;;465        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
;;;466      }
;;;467      else
;;;468      {
;;;469        /* Disable the selected ADC conversion on external event and stop the selected
;;;470           ADC conversion */
;;;471        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L32.12|
000006  f44101a0          ORR      r1,r1,#0x500000       ;465
00000a  e001              B        |L32.16|
                  |L32.12|
00000c  f42101a0          BIC      r1,r1,#0x500000
                  |L32.16|
000010  6081              STR      r1,[r0,#8]            ;465
;;;472      }
;;;473    }
000012  4770              BX       lr
;;;474    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;847      */
;;;848    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;849    {
;;;850      /* Check the parameters */
;;;851      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;852      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;853      if (NewState != DISABLE)
;;;854      {
;;;855        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;856           ADC injected conversion */
;;;857        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
;;;858      }
;;;859      else
;;;860      {
;;;861        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;862           ADC injected conversion */
;;;863        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L33.12|
000006  f4411102          ORR      r1,r1,#0x208000       ;857
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4211102          BIC      r1,r1,#0x208000
                  |L33.16|
000010  6081              STR      r1,[r0,#8]            ;857
;;;864      }
;;;865    }
000012  4770              BX       lr
;;;866    
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=1

                  ADC_StartCalibration PROC
;;;415      */
;;;416    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;417    {
;;;418      /* Check the parameters */
;;;419      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;420      /* Enable the selected ADC calibration process */  
;;;421      ADCx->CR2 |= CR2_CAL_Set;
000002  f0410104          ORR      r1,r1,#4
000006  6081              STR      r1,[r0,#8]
;;;422    }
000008  4770              BX       lr
;;;423    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;273      */
;;;274    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;275    {
;;;276      /* Reset ADC init structure parameters values */
;;;277      /* Initialize the ADC_Mode member */
;;;278      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
;;;279      /* initialize the ADC_ScanConvMode member */
;;;280      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;281      /* Initialize the ADC_ContinuousConvMode member */
;;;282      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;283      /* Initialize the ADC_ExternalTrigConv member */
;;;284      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
;;;285      /* Initialize the ADC_DataAlign member */
;;;286      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
000008  6081              STR      r1,[r0,#8]
;;;287      /* Initialize the ADC_NbrOfChannel member */
;;;288      ADC_InitStruct->ADC_NbrOfChannel = 1;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;289    }
000010  4770              BX       lr
;;;290    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;1165     */
;;;1166   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
000000  4906              LDR      r1,|L36.28|
;;;1167   {
;;;1168     /* Check the parameters */
;;;1169     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1170     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;1171     {
;;;1172       /* Enable the temperature sensor and Vrefint channel*/
;;;1173       ADC1->CR2 |= CR2_TSVREFE_Set;
;;;1174     }
;;;1175     else
;;;1176     {
;;;1177       /* Disable the temperature sensor and Vrefint channel*/
;;;1178       ADC1->CR2 &= CR2_TSVREFE_Reset;
000004  f8d10408          LDR      r0,[r1,#0x408]
000008  d002              BEQ      |L36.16|
00000a  f4400000          ORR      r0,r0,#0x800000       ;1173
00000e  e001              B        |L36.20|
                  |L36.16|
000010  f4200000          BIC      r0,r0,#0x800000
                  |L36.20|
000014  f8c10408          STR      r0,[r1,#0x408]        ;1173
;;;1179     }
;;;1180   }
000018  4770              BX       lr
;;;1181   
                          ENDP

00001a  0000              DCW      0x0000
                  |L36.28|
                          DCD      0x40012000

;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_adc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_adc_c_e11a2ea2____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___15_stm32f10x_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
