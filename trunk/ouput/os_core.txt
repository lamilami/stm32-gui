; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\os_core.o --depend=.\ouput\os_core.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\os_core.crf Source\uCOS-II\Source\os_core.c]
                          THUMB

                          AREA ||i.OSEventNameGet||, CODE, READONLY, ALIGN=2

                  OSEventNameGet PROC
;;;107    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;108    INT8U  OSEventNameGet (OS_EVENT   *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;109                           INT8U     **pname,
;;;110                           INT8U      *perr)
;;;111    {
000002  0005              MOVS     r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;112        INT8U      len;
;;;113    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;114        OS_CPU_SR  cpu_sr = 0u;
;;;115    #endif
;;;116    
;;;117    
;;;118    
;;;119    #ifdef OS_SAFETY_CRITICAL
;;;120        if (perr == (INT8U *)0) {
;;;121            OS_SAFETY_CRITICAL_EXCEPTION();
;;;122        }
;;;123    #endif
;;;124    
;;;125    #if OS_ARG_CHK_EN > 0u
;;;126        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
000008  d005              BEQ      |L1.22|
;;;127            *perr = OS_ERR_PEVENT_NULL;
;;;128            return (0u);
;;;129        }
;;;130        if (pname == (INT8U **)0) {                   /* Is 'pname' a NULL pointer?                         */
00000a  b136              CBZ      r6,|L1.26|
;;;131            *perr = OS_ERR_PNAME_NULL;
;;;132            return (0u);
;;;133        }
;;;134    #endif
;;;135        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  4812              LDR      r0,|L1.88|
00000e  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
000010  b130              CBZ      r0,|L1.32|
;;;136            *perr  = OS_ERR_NAME_GET_ISR;
000012  2011              MOVS     r0,#0x11
;;;137            return (0u);
000014  e002              B        |L1.28|
                  |L1.22|
000016  2004              MOVS     r0,#4                 ;127
000018  e000              B        |L1.28|
                  |L1.26|
00001a  200c              MOVS     r0,#0xc               ;131
                  |L1.28|
00001c  7010              STRB     r0,[r2,#0]            ;127
00001e  e00a              B        |L1.54|
                  |L1.32|
;;;138        }
;;;139        switch (pevent->OSEventType) {
000020  782a              LDRB     r2,[r5,#0]
000022  2a01              CMP      r2,#1
000024  d009              BEQ      |L1.58|
000026  2a02              CMP      r2,#2
000028  d007              BEQ      |L1.58|
00002a  2a03              CMP      r2,#3
00002c  d005              BEQ      |L1.58|
00002e  2a04              CMP      r2,#4
000030  d003              BEQ      |L1.58|
;;;140            case OS_EVENT_TYPE_SEM:
;;;141            case OS_EVENT_TYPE_MUTEX:
;;;142            case OS_EVENT_TYPE_MBOX:
;;;143            case OS_EVENT_TYPE_Q:
;;;144                 break;
;;;145    
;;;146            default:
;;;147                 *perr = OS_ERR_EVENT_TYPE;
000032  2001              MOVS     r0,#1
000034  7020              STRB     r0,[r4,#0]
                  |L1.54|
;;;148                 return (0u);
000036  2000              MOVS     r0,#0
;;;149        }
;;;150        OS_ENTER_CRITICAL();
;;;151        *pname = pevent->OSEventName;
;;;152        len    = OS_StrLen(*pname);
;;;153        OS_EXIT_CRITICAL();
;;;154        *perr  = OS_ERR_NONE;
;;;155        return (len);
;;;156    }
000038  bd70              POP      {r4-r6,pc}
                  |L1.58|
00003a  f7fffffe          BL       OS_CPU_SR_Save
00003e  4603              MOV      r3,r0                 ;150
000040  6968              LDR      r0,[r5,#0x14]         ;151
000042  6030              STR      r0,[r6,#0]            ;152
000044  f7fffffe          BL       OS_StrLen
000048  4605              MOV      r5,r0                 ;152
00004a  4618              MOV      r0,r3                 ;153
00004c  f7fffffe          BL       OS_CPU_SR_Restore
000050  2000              MOVS     r0,#0                 ;154
000052  7020              STRB     r0,[r4,#0]            ;154
000054  4628              MOV      r0,r5                 ;155
000056  bd70              POP      {r4-r6,pc}
;;;157    #endif
                          ENDP

                  |L1.88|
                          DCD      ||.data||

                          AREA ||i.OSEventNameSet||, CODE, READONLY, ALIGN=2

                  OSEventNameSet PROC
;;;186    #if (OS_EVENT_EN) && (OS_EVENT_NAME_EN > 0u)
;;;187    void  OSEventNameSet (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;188                          INT8U     *pname,
;;;189                          INT8U     *perr)
;;;190    {
000002  0005              MOVS     r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;191    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;192        OS_CPU_SR  cpu_sr = 0u;
;;;193    #endif
;;;194    
;;;195    
;;;196    
;;;197    #ifdef OS_SAFETY_CRITICAL
;;;198        if (perr == (INT8U *)0) {
;;;199            OS_SAFETY_CRITICAL_EXCEPTION();
;;;200        }
;;;201    #endif
;;;202    
;;;203    #if OS_ARG_CHK_EN > 0u
;;;204        if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
000008  d006              BEQ      |L2.24|
;;;205            *perr = OS_ERR_PEVENT_NULL;
;;;206            return;
;;;207        }
;;;208        if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
00000a  b13e              CBZ      r6,|L2.28|
;;;209            *perr = OS_ERR_PNAME_NULL;
;;;210            return;
;;;211        }
;;;212    #endif
;;;213        if (OSIntNesting > 0u) {                     /* See if trying to call from an ISR                  */
00000c  480e              LDR      r0,|L2.72|
00000e  7880              LDRB     r0,[r0,#2]  ; OSIntNesting
000010  b130              CBZ      r0,|L2.32|
;;;214            *perr = OS_ERR_NAME_SET_ISR;
000012  2012              MOVS     r0,#0x12
                  |L2.20|
000014  7010              STRB     r0,[r2,#0]
;;;215            return;
;;;216        }
;;;217        switch (pevent->OSEventType) {
;;;218            case OS_EVENT_TYPE_SEM:
;;;219            case OS_EVENT_TYPE_MUTEX:
;;;220            case OS_EVENT_TYPE_MBOX:
;;;221            case OS_EVENT_TYPE_Q:
;;;222                 break;
;;;223    
;;;224            default:
;;;225                 *perr = OS_ERR_EVENT_TYPE;
;;;226                 return;
;;;227        }
;;;228        OS_ENTER_CRITICAL();
;;;229        pevent->OSEventName = pname;
;;;230        OS_EXIT_CRITICAL();
;;;231        *perr = OS_ERR_NONE;
;;;232    }
000016  bd70              POP      {r4-r6,pc}
                  |L2.24|
000018  2004              MOVS     r0,#4                 ;205
00001a  e7fb              B        |L2.20|
                  |L2.28|
00001c  200c              MOVS     r0,#0xc               ;209
00001e  e7f9              B        |L2.20|
                  |L2.32|
000020  782a              LDRB     r2,[r5,#0]            ;217
000022  2a01              CMP      r2,#1                 ;217
000024  d007              BEQ      |L2.54|
000026  2a02              CMP      r2,#2                 ;217
000028  d005              BEQ      |L2.54|
00002a  2a03              CMP      r2,#3                 ;217
00002c  d003              BEQ      |L2.54|
00002e  2a04              CMP      r2,#4                 ;217
000030  d001              BEQ      |L2.54|
000032  2001              MOVS     r0,#1                 ;225
000034  e005              B        |L2.66|
                  |L2.54|
000036  f7fffffe          BL       OS_CPU_SR_Save
00003a  616e              STR      r6,[r5,#0x14]         ;230
00003c  f7fffffe          BL       OS_CPU_SR_Restore
000040  2000              MOVS     r0,#0                 ;231
                  |L2.66|
000042  7020              STRB     r0,[r4,#0]            ;231
000044  bd70              POP      {r4-r6,pc}
;;;233    #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      ||.data||

                          AREA ||i.OSInit||, CODE, READONLY, ALIGN=2

                  OSInit PROC
;;;569    
;;;570    void  OSInit (void)
000000  b500              PUSH     {lr}
;;;571    {
000002  b085              SUB      sp,sp,#0x14
;;;572        OSInitHookBegin();                                           /* Call port specific initialization code   */
000004  f7fffffe          BL       OSInitHookBegin
000008  4a22              LDR      r2,|L3.148|
00000a  2100              MOVS     r1,#0
00000c  6311              STR      r1,[r2,#0x30]  ; OSTime
00000e  7091              STRB     r1,[r2,#2]
000010  70d1              STRB     r1,[r2,#3]
000012  7211              STRB     r1,[r2,#8]
000014  71d1              STRB     r1,[r2,#7]
000016  60d1              STR      r1,[r2,#0xc]  ; OSCtxSwCtr
000018  61d1              STR      r1,[r2,#0x1c]  ; OSIdleCtr
00001a  6191              STR      r1,[r2,#0x18]  ; OSIdleCtrRun
00001c  6151              STR      r1,[r2,#0x14]  ; OSIdleCtrMax
00001e  7051              STRB     r1,[r2,#1]
000020  7191              STRB     r1,[r2,#6]
000022  4608              MOV      r0,r1
000024  f1020334          ADD      r3,r2,#0x34
                  |L3.40|
000028  5419              STRB     r1,[r3,r0]
00002a  1c40              ADDS     r0,r0,#1
00002c  b2c0              UXTB     r0,r0
00002e  2808              CMP      r0,#8
000030  d3fa              BCC      |L3.40|
000032  7111              STRB     r1,[r2,#4]
000034  7151              STRB     r1,[r2,#5]
000036  6291              STR      r1,[r2,#0x28]  ; OSTCBHighRdy
;;;573    
;;;574        OS_InitMisc();                                               /* Initialize miscellaneous variables       */
;;;575    
;;;576        OS_InitRdyList();                                            /* Initialize the Ready List                */
;;;577    
;;;578        OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
000038  6211              STR      r1,[r2,#0x20]  ; OSTCBCur
00003a  f7fffffe          BL       OS_InitTCBList
;;;579    
;;;580        OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
00003e  f7fffffe          BL       OS_InitEventList
000042  4815              LDR      r0,|L3.152|
000044  f10d0c04          ADD      r12,sp,#4
000048  2303              MOVS     r3,#3
00004a  2200              MOVS     r2,#0
00004c  2180              MOVS     r1,#0x80
00004e  e8ac000f          STM      r12!,{r0-r3}
000052  f64f73ff          MOV      r3,#0xffff
000056  9300              STR      r3,[sp,#0]
000058  f50072fe          ADD      r2,r0,#0x1fc
00005c  233f              MOVS     r3,#0x3f
00005e  2100              MOVS     r1,#0
000060  480e              LDR      r0,|L3.156|
000062  f7fffffe          BL       OSTaskCreateExt
000066  480e              LDR      r0,|L3.160|
000068  f10d0c04          ADD      r12,sp,#4
00006c  2303              MOVS     r3,#3
00006e  2200              MOVS     r2,#0
000070  2180              MOVS     r1,#0x80
000072  e8ac000f          STM      r12!,{r0-r3}
000076  f64f73fe          MOV      r3,#0xfffe
00007a  9300              STR      r3,[sp,#0]
00007c  f50072fe          ADD      r2,r0,#0x1fc
000080  233e              MOVS     r3,#0x3e
000082  2100              MOVS     r1,#0
000084  4807              LDR      r0,|L3.164|
000086  f7fffffe          BL       OSTaskCreateExt
;;;581    
;;;582    #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u)
;;;583        OS_FlagInit();                                               /* Initialize the event flag structures     */
;;;584    #endif
;;;585    
;;;586    #if (OS_MEM_EN > 0u) && (OS_MAX_MEM_PART > 0u)
;;;587        OS_MemInit();                                                /* Initialize the memory manager            */
;;;588    #endif
;;;589    
;;;590    #if (OS_Q_EN > 0u) && (OS_MAX_QS > 0u)
;;;591        OS_QInit();                                                  /* Initialize the message queue structures  */
;;;592    #endif
;;;593    
;;;594        OS_InitTaskIdle();                                           /* Create the Idle Task                     */
;;;595    #if OS_TASK_STAT_EN > 0u
;;;596        OS_InitTaskStat();                                           /* Create the Statistic Task                */
;;;597    #endif
;;;598    
;;;599    #if OS_TMR_EN > 0u
;;;600        OSTmr_Init();                                                /* Initialize the Timer Manager             */
;;;601    #endif
;;;602    
;;;603        OSInitHookEnd();                                             /* Call port specific init. code            */
00008a  b005              ADD      sp,sp,#0x14
00008c  f85deb04          POP      {lr}
000090  f7ffbffe          B.W      OSInitHookEnd
;;;604    
;;;605    #if OS_DEBUG_EN > 0u
;;;606        OSDebugInit();
;;;607    #endif
;;;608    }
;;;609    /*$PAGE*/
                          ENDP

                  |L3.148|
                          DCD      ||.data||
                  |L3.152|
                          DCD      ||.bss||+0x2f0
                  |L3.156|
                          DCD      OS_TaskIdle
                  |L3.160|
                          DCD      ||.bss||+0xf0
                  |L3.164|
                          DCD      OS_TaskStat

                          AREA ||i.OSIntEnter||, CODE, READONLY, ALIGN=2

                  OSIntEnter PROC
;;;634    
;;;635    void  OSIntEnter (void)
000000  4904              LDR      r1,|L4.20|
;;;636    {
;;;637        if (OSRunning == OS_TRUE) {
000002  79c8              LDRB     r0,[r1,#7]  ; OSRunning
000004  2801              CMP      r0,#1
000006  d104              BNE      |L4.18|
;;;638            if (OSIntNesting < 255u) {
000008  7888              LDRB     r0,[r1,#2]  ; OSIntNesting
00000a  28ff              CMP      r0,#0xff
00000c  d201              BCS      |L4.18|
;;;639                OSIntNesting++;                      /* Increment ISR nesting level                        */
00000e  1c40              ADDS     r0,r0,#1
000010  7088              STRB     r0,[r1,#2]
                  |L4.18|
;;;640            }
;;;641        }
;;;642    }
000012  4770              BX       lr
;;;643    /*$PAGE*/
                          ENDP

                  |L4.20|
                          DCD      ||.data||

                          AREA ||i.OSIntExit||, CODE, READONLY, ALIGN=2

                  OSIntExit PROC
;;;662    
;;;663    void  OSIntExit (void)
000000  b570              PUSH     {r4-r6,lr}
;;;664    {
;;;665    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;666        OS_CPU_SR  cpu_sr = 0u;
;;;667    #endif
;;;668    
;;;669    
;;;670    
;;;671        if (OSRunning == OS_TRUE) {
000002  4c14              LDR      r4,|L5.84|
000004  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d122              BNE      |L5.80|
;;;672            OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
;;;673            if (OSIntNesting > 0u) {                           /* Prevent OSIntNesting from wrapping       */
00000e  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000010  4605              MOV      r5,r0                 ;672
000012  b121              CBZ      r1,|L5.30|
;;;674                OSIntNesting--;
000014  1e49              SUBS     r1,r1,#1
000016  f01100ff          ANDS     r0,r1,#0xff
00001a  70a0              STRB     r0,[r4,#2]
;;;675            }
;;;676            if (OSIntNesting == 0u) {                          /* Reschedule only if all ISRs complete ... */
00001c  d113              BNE      |L5.70|
                  |L5.30|
;;;677                if (OSLockNesting == 0u) {                     /* ... and not locked.                      */
00001e  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
000020  b988              CBNZ     r0,|L5.70|
;;;678                    OS_SchedNew();
000022  f7fffffe          BL       OS_SchedNew
;;;679                    OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000026  490c              LDR      r1,|L5.88|
000028  7960              LDRB     r0,[r4,#5]  ; OSPrioHighRdy
00002a  f8511020          LDR      r1,[r1,r0,LSL #2]
;;;680                    if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
00002e  62a1              STR      r1,[r4,#0x28]  ; OSTCBHighRdy
000030  7922              LDRB     r2,[r4,#4]  ; OSPrioCur
000032  4290              CMP      r0,r2
000034  d007              BEQ      |L5.70|
;;;681    #if OS_TASK_PROFILE_EN > 0u
;;;682                        OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
000036  6b08              LDR      r0,[r1,#0x30]
000038  1c40              ADDS     r0,r0,#1
;;;683    #endif
;;;684                        OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
00003a  6308              STR      r0,[r1,#0x30]
00003c  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
00003e  1c40              ADDS     r0,r0,#1
;;;685                        OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
000040  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
000042  f7fffffe          BL       OSIntCtxSw
                  |L5.70|
;;;686                    }
;;;687                }
;;;688            }
;;;689            OS_EXIT_CRITICAL();
000046  4628              MOV      r0,r5
000048  e8bd4070          POP      {r4-r6,lr}
00004c  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L5.80|
;;;690        }
;;;691    }
000050  bd70              POP      {r4-r6,pc}
;;;692    /*$PAGE*/
                          ENDP

000052  0000              DCW      0x0000
                  |L5.84|
                          DCD      ||.data||
                  |L5.88|
                          DCD      ||.bss||+0x4f0

                          AREA ||i.OSSchedLock||, CODE, READONLY, ALIGN=2

                  OSSchedLock PROC
;;;735    #if OS_SCHED_LOCK_EN > 0u
;;;736    void  OSSchedLock (void)
000000  b510              PUSH     {r4,lr}
;;;737    {
;;;738    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;739        OS_CPU_SR  cpu_sr = 0u;
;;;740    #endif
;;;741    
;;;742    
;;;743    
;;;744        if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
000002  4c09              LDR      r4,|L6.40|
000004  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d10c              BNE      |L6.36|
;;;745            OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
;;;746            if (OSIntNesting == 0u) {                /* Can't call from an ISR                             */
00000e  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
000010  b921              CBNZ     r1,|L6.28|
;;;747                if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
000012  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
000014  29ff              CMP      r1,#0xff
000016  d201              BCS      |L6.28|
;;;748                    OSLockNesting++;                 /* Increment lock nesting level                       */
000018  1c49              ADDS     r1,r1,#1
00001a  70e1              STRB     r1,[r4,#3]
                  |L6.28|
;;;749                }
;;;750            }
;;;751            OS_EXIT_CRITICAL();
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L6.36|
;;;752        }
;;;753    }
000024  bd10              POP      {r4,pc}
;;;754    #endif
                          ENDP

000026  0000              DCW      0x0000
                  |L6.40|
                          DCD      ||.data||

                          AREA ||i.OSSchedUnlock||, CODE, READONLY, ALIGN=2

                  OSSchedUnlock PROC
;;;772    #if OS_SCHED_LOCK_EN > 0u
;;;773    void  OSSchedUnlock (void)
000000  b510              PUSH     {r4,lr}
;;;774    {
;;;775    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;776        OS_CPU_SR  cpu_sr = 0u;
;;;777    #endif
;;;778    
;;;779    
;;;780    
;;;781        if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
000002  4c0d              LDR      r4,|L7.56|
000004  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000006  2801              CMP      r0,#1
000008  d114              BNE      |L7.52|
;;;782            OS_ENTER_CRITICAL();
00000a  f7fffffe          BL       OS_CPU_SR_Save
;;;783            if (OSLockNesting > 0u) {                          /* Do not decrement if already 0            */
00000e  78e1              LDRB     r1,[r4,#3]  ; OSLockNesting
000010  b131              CBZ      r1,|L7.32|
;;;784                OSLockNesting--;                               /* Decrement lock nesting level             */
000012  1e49              SUBS     r1,r1,#1
000014  f01101ff          ANDS     r1,r1,#0xff
000018  70e1              STRB     r1,[r4,#3]
;;;785                if (OSLockNesting == 0u) {                     /* See if scheduler is enabled and ...      */
00001a  d101              BNE      |L7.32|
;;;786                    if (OSIntNesting == 0u) {                  /* ... not in an ISR                        */
00001c  78a1              LDRB     r1,[r4,#2]  ; OSIntNesting
00001e  b119              CBZ      r1,|L7.40|
                  |L7.32|
;;;787                        OS_EXIT_CRITICAL();
;;;788                        OS_Sched();                            /* See if a HPT is ready                    */
;;;789                    } else {
;;;790                        OS_EXIT_CRITICAL();
;;;791                    }
;;;792                } else {
;;;793                    OS_EXIT_CRITICAL();
;;;794                }
;;;795            } else {
;;;796                OS_EXIT_CRITICAL();
000020  e8bd4010          POP      {r4,lr}
000024  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L7.40|
000028  f7fffffe          BL       OS_CPU_SR_Restore
00002c  e8bd4010          POP      {r4,lr}               ;788
000030  f7ffbffe          B.W      OS_Sched
                  |L7.52|
;;;797            }
;;;798        }
;;;799    }
000034  bd10              POP      {r4,pc}
;;;800    #endif
                          ENDP

000036  0000              DCW      0x0000
                  |L7.56|
                          DCD      ||.data||

                          AREA ||i.OSStart||, CODE, READONLY, ALIGN=2

                  OSStart PROC
;;;822    
;;;823    void  OSStart (void)
000000  b510              PUSH     {r4,lr}
;;;824    {
;;;825        if (OSRunning == OS_FALSE) {
000002  4c09              LDR      r4,|L8.40|
000004  79e0              LDRB     r0,[r4,#7]  ; OSRunning
000006  2800              CMP      r0,#0
000008  d10c              BNE      |L8.36|
;;;826            OS_SchedNew();                               /* Find highest priority's task priority number   */
00000a  f7fffffe          BL       OS_SchedNew
;;;827            OSPrioCur     = OSPrioHighRdy;
00000e  7960              LDRB     r0,[r4,#5]  ; OSPrioHighRdy
;;;828            OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
000010  4906              LDR      r1,|L8.44|
000012  7120              STRB     r0,[r4,#4]            ;827
000014  f8510020          LDR      r0,[r1,r0,LSL #2]
;;;829            OSTCBCur      = OSTCBHighRdy;
000018  62a0              STR      r0,[r4,#0x28]  ; OSTCBHighRdy
;;;830            OSStartHighRdy();                            /* Execute target specific code to start task     */
00001a  6220              STR      r0,[r4,#0x20]  ; OSTCBCur
00001c  e8bd4010          POP      {r4,lr}
000020  f7ffbffe          B.W      OSStartHighRdy
                  |L8.36|
;;;831        }
;;;832    }
000024  bd10              POP      {r4,pc}
;;;833    /*$PAGE*/
                          ENDP

000026  0000              DCW      0x0000
                  |L8.40|
                          DCD      ||.data||
                  |L8.44|
                          DCD      ||.bss||+0x4f0

                          AREA ||i.OSStatInit||, CODE, READONLY, ALIGN=2

                  OSStatInit PROC
;;;854    #if OS_TASK_STAT_EN > 0u
;;;855    void  OSStatInit (void)
000000  b510              PUSH     {r4,lr}
;;;856    {
;;;857    #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;858        OS_CPU_SR  cpu_sr = 0u;
;;;859    #endif
;;;860    
;;;861    
;;;862    
;;;863        OSTimeDly(2u);                               /* Synchronize with clock tick                        */
000002  2002              MOVS     r0,#2
000004  f7fffffe          BL       OSTimeDly
;;;864        OS_ENTER_CRITICAL();
000008  f7fffffe          BL       OS_CPU_SR_Save
;;;865        OSIdleCtr    = 0uL;                          /* Clear idle counter                                 */
00000c  4c08              LDR      r4,|L9.48|
00000e  2100              MOVS     r1,#0
000010  61e1              STR      r1,[r4,#0x1c]  ; OSIdleCtr
;;;866        OS_EXIT_CRITICAL();
000012  f7fffffe          BL       OS_CPU_SR_Restore
;;;867        OSTimeDly(OS_TICKS_PER_SEC / 10u);           /* Determine MAX. idle counter value for 1/10 second  */
000016  2064              MOVS     r0,#0x64
000018  f7fffffe          BL       OSTimeDly
;;;868        OS_ENTER_CRITICAL();
00001c  f7fffffe          BL       OS_CPU_SR_Save
;;;869        OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
000020  69e1              LDR      r1,[r4,#0x1c]  ; OSIdleCtr
;;;870        OSStatRdy    = OS_TRUE;
000022  6161              STR      r1,[r4,#0x14]  ; OSIdleCtrMax
000024  2101              MOVS     r1,#1
000026  7061              STRB     r1,[r4,#1]
;;;871        OS_EXIT_CRITICAL();
000028  e8bd4010          POP      {r4,lr}
00002c  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;872    }
;;;873    #endif
                          ENDP

                  |L9.48|
                          DCD      ||.data||

                          AREA ||i.OSTimeTick||, CODE, READONLY, ALIGN=2

                  OSTimeTick PROC
;;;888    
;;;889    void  OSTimeTick (void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;890    {
;;;891        OS_TCB    *ptcb;
;;;892    #if OS_TICK_STEP_EN > 0u
;;;893        BOOLEAN    step;
;;;894    #endif
;;;895    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register     */
;;;896        OS_CPU_SR  cpu_sr = 0u;
;;;897    #endif
;;;898    
;;;899    
;;;900    
;;;901    #if OS_TIME_TICK_HOOK_EN > 0u
;;;902        OSTimeTickHook();                                      /* Call user definable hook                     */
000004  f7fffffe          BL       OSTimeTickHook
;;;903    #endif
;;;904    #if OS_TIME_GET_SET_EN > 0u
;;;905        OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
000008  f7fffffe          BL       OS_CPU_SR_Save
;;;906        OSTime++;
00000c  4d25              LDR      r5,|L10.164|
00000e  6b29              LDR      r1,[r5,#0x30]  ; OSTime
000010  1c49              ADDS     r1,r1,#1
000012  6329              STR      r1,[r5,#0x30]  ; OSTime
;;;907        OS_EXIT_CRITICAL();
000014  f7fffffe          BL       OS_CPU_SR_Restore
;;;908    #endif
;;;909        if (OSRunning == OS_TRUE) {
000018  79e8              LDRB     r0,[r5,#7]  ; OSRunning
00001a  2801              CMP      r0,#1
00001c  d140              BNE      |L10.160|
;;;910    #if OS_TICK_STEP_EN > 0u
;;;911            switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
00001e  7a68              LDRB     r0,[r5,#9]  ; OSTickStepState
000020  2601              MOVS     r6,#1                 ;909
000022  f04f0800          MOV      r8,#0                 ;896
000026  b128              CBZ      r0,|L10.52|
000028  2801              CMP      r0,#1
00002a  d039              BEQ      |L10.160|
00002c  2802              CMP      r0,#2
00002e  d003              BEQ      |L10.56|
;;;912                case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
;;;913                     step = OS_TRUE;
;;;914                     break;
;;;915    
;;;916                case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
;;;917                     step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
;;;918                     break;
;;;919    
;;;920                case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
;;;921                     step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
;;;922                     OSTickStepState = OS_TICK_STEP_WAIT;
;;;923                     break;
;;;924    
;;;925                default:                                       /* Invalid case, correct situation              */
;;;926                     step            = OS_TRUE;
;;;927                     OSTickStepState = OS_TICK_STEP_DIS;
000030  f8858009          STRB     r8,[r5,#9]
                  |L10.52|
;;;928                     break;
;;;929            }
;;;930            if (step == OS_FALSE) {                            /* Return if waiting for step command           */
;;;931                return;
;;;932            }
;;;933    #endif
;;;934            ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
;;;935            while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
000034  6aec              LDR      r4,[r5,#0x2c]  ; OSTCBList
000036  e02f              B        |L10.152|
                  |L10.56|
000038  726e              STRB     r6,[r5,#9]            ;922
00003a  e7fb              B        |L10.52|
                  |L10.60|
;;;936                OS_ENTER_CRITICAL();
00003c  f7fffffe          BL       OS_CPU_SR_Save
;;;937                if (ptcb->OSTCBDly != 0u) {                    /* No, Delayed or waiting for event with TO     */
000040  6a61              LDR      r1,[r4,#0x24]
000042  b331              CBZ      r1,|L10.146|
;;;938                    ptcb->OSTCBDly--;                          /* Decrement nbr of ticks to end of delay       */
000044  1e49              SUBS     r1,r1,#1
;;;939                    if (ptcb->OSTCBDly == 0u) {                /* Check for timeout                            */
000046  6261              STR      r1,[r4,#0x24]
000048  d123              BNE      |L10.146|
;;;940    
;;;941                        if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
00004a  f8941028          LDRB     r1,[r4,#0x28]
00004e  f0110f37          TST      r1,#0x37
000052  d006              BEQ      |L10.98|
;;;942                            ptcb->OSTCBStat  &= (INT8U)~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
000054  f00101c8          AND      r1,r1,#0xc8
000058  f8841028          STRB     r1,[r4,#0x28]
;;;943                            ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
00005c  f8846029          STRB     r6,[r4,#0x29]
000060  e001              B        |L10.102|
                  |L10.98|
;;;944                        } else {
;;;945                            ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
000062  f8848029          STRB     r8,[r4,#0x29]
                  |L10.102|
;;;946                        }
;;;947    
;;;948                        if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
000066  f8941028          LDRB     r1,[r4,#0x28]
00006a  0709              LSLS     r1,r1,#28
00006c  d411              BMI      |L10.146|
00006e  f104042c          ADD      r4,r4,#0x2c
;;;949                            OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
000072  79aa              LDRB     r2,[r5,#6]  ; OSRdyGrp
000074  78a1              LDRB     r1,[r4,#2]
000076  ea410102          ORR      r1,r1,r2
00007a  71a9              STRB     r1,[r5,#6]
;;;950                            OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
00007c  4a09              LDR      r2,|L10.164|
00007e  7821              LDRB     r1,[r4,#0]
000080  f1020234          ADD      r2,r2,#0x34
000084  7867              LDRB     r7,[r4,#1]
000086  5c53              LDRB     r3,[r2,r1]
000088  f1a4042c          SUB      r4,r4,#0x2c
00008c  ea430307          ORR      r3,r3,r7
000090  5453              STRB     r3,[r2,r1]
                  |L10.146|
;;;951                        }
;;;952                    }
;;;953                }
;;;954                ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
000092  6964              LDR      r4,[r4,#0x14]
;;;955                OS_EXIT_CRITICAL();
000094  f7fffffe          BL       OS_CPU_SR_Restore
                  |L10.152|
000098  f894002a          LDRB     r0,[r4,#0x2a]         ;935
00009c  283f              CMP      r0,#0x3f              ;935
00009e  d1cd              BNE      |L10.60|
                  |L10.160|
;;;956            }
;;;957        }
;;;958    }
0000a0  e8bd81f0          POP      {r4-r8,pc}
;;;959    
                          ENDP

                  |L10.164|
                          DCD      ||.data||

                          AREA ||i.OSVersion||, CODE, READONLY, ALIGN=1

                  OSVersion PROC
;;;974    
;;;975    INT16U  OSVersion (void)
000000  f2401023          MOV      r0,#0x123
;;;976    {
;;;977        return (OS_VERSION);
;;;978    }
000004  4770              BX       lr
;;;979    
                          ENDP


                          AREA ||i.OS_EventTaskRdy||, CODE, READONLY, ALIGN=2

                  OS_EventTaskRdy PROC
;;;1027   #if (OS_EVENT_EN)
;;;1028   INT8U  OS_EventTaskRdy (OS_EVENT  *pevent,
000000  b5f0              PUSH     {r4-r7,lr}
;;;1029                           void      *pmsg,
;;;1030                           INT8U      msk,
;;;1031                           INT8U      pend_stat)
;;;1032   {
000002  460f              MOV      r7,r1
000004  4606              MOV      r6,r0
;;;1033       OS_TCB   *ptcb;
;;;1034       INT8U     y;
;;;1035       INT8U     x;
;;;1036       INT8U     prio;
;;;1037   #if OS_LOWEST_PRIO > 63u
;;;1038       OS_PRIO  *ptbl;
;;;1039   #endif
;;;1040   
;;;1041   
;;;1042   #if OS_LOWEST_PRIO <= 63u
;;;1043       y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
000006  7a81              LDRB     r1,[r0,#0xa]
000008  4816              LDR      r0,|L12.100|
00000a  5c44              LDRB     r4,[r0,r1]
;;;1044       x    = OSUnMapTbl[pevent->OSEventTbl[y]];
00000c  eb060104          ADD      r1,r6,r4
000010  7ac9              LDRB     r1,[r1,#0xb]
000012  5c40              LDRB     r0,[r0,r1]
;;;1045       prio = (INT8U)((y << 3u) + x);                      /* Find priority of task getting the msg       */
;;;1046   #else
;;;1047       if ((pevent->OSEventGrp & 0xFFu) != 0u) {           /* Find HPT waiting for message                */
;;;1048           y = OSUnMapTbl[ pevent->OSEventGrp & 0xFFu];
;;;1049       } else {
;;;1050           y = OSUnMapTbl[(OS_PRIO)(pevent->OSEventGrp >> 8u) & 0xFFu] + 8u;
;;;1051       }
;;;1052       ptbl = &pevent->OSEventTbl[y];
;;;1053       if ((*ptbl & 0xFFu) != 0u) {
;;;1054           x = OSUnMapTbl[*ptbl & 0xFFu];
;;;1055       } else {
;;;1056           x = OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u;
;;;1057       }
;;;1058       prio = (INT8U)((y << 4u) + x);                      /* Find priority of task getting the msg       */
;;;1059   #endif
;;;1060   
;;;1061       ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
;;;1062       ptcb->OSTCBDly        =  0u;                        /* Prevent OSTimeTick() from readying task     */
000014  f04f0100          MOV      r1,#0
000018  eb0000c4          ADD      r0,r0,r4,LSL #3       ;1045
00001c  b2c5              UXTB     r5,r0                 ;1045
00001e  4812              LDR      r0,|L12.104|
000020  f8500025          LDR      r0,[r0,r5,LSL #2]     ;1061
000024  f1000020          ADD      r0,r0,#0x20
000028  e9c07100          STRD     r7,r1,[r0,#0]
;;;1063   #if ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u)) || (OS_MBOX_EN > 0u)
;;;1064       ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
;;;1065   #else
;;;1066       pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
;;;1067   #endif
;;;1068       ptcb->OSTCBStat      &= (INT8U)~msk;                /* Clear bit associated with event type        */
00002c  7a01              LDRB     r1,[r0,#8]
00002e  ea210102          BIC      r1,r1,r2
000032  7201              STRB     r1,[r0,#8]
;;;1069       ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
000034  7243              STRB     r3,[r0,#9]
000036  f1a00020          SUB      r0,r0,#0x20
;;;1070                                                           /* See if task is ready (could be susp'd)      */
;;;1071       if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
00003a  0709              LSLS     r1,r1,#28
00003c  d40c              BMI      |L12.88|
;;;1072           OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
00003e  490b              LDR      r1,|L12.108|
000040  f890202e          LDRB     r2,[r0,#0x2e]
000044  798b              LDRB     r3,[r1,#6]  ; OSRdyGrp
000046  431a              ORRS     r2,r2,r3
000048  718a              STRB     r2,[r1,#6]
;;;1073           OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
00004a  f1010234          ADD      r2,r1,#0x34
00004e  f890302d          LDRB     r3,[r0,#0x2d]
000052  5d11              LDRB     r1,[r2,r4]
000054  4319              ORRS     r1,r1,r3
000056  5511              STRB     r1,[r2,r4]
                  |L12.88|
;;;1074       }
;;;1075   
;;;1076       OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
000058  4631              MOV      r1,r6
00005a  f7fffffe          BL       OS_EventTaskRemove
;;;1077   #if (OS_EVENT_MULTI_EN > 0u)
;;;1078       if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
;;;1079           OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
;;;1080           ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
;;;1081       }
;;;1082   #endif
;;;1083   
;;;1084       return (prio);
00005e  4628              MOV      r0,r5
;;;1085   }
000060  bdf0              POP      {r4-r7,pc}
;;;1086   #endif
                          ENDP

000062  0000              DCW      0x0000
                  |L12.100|
                          DCD      ||.constdata||
                  |L12.104|
                          DCD      ||.bss||+0x4f0
                  |L12.108|
                          DCD      ||.data||

                          AREA ||i.OS_EventTaskRemove||, CODE, READONLY, ALIGN=1

                  OS_EventTaskRemove PROC
;;;1179   #if (OS_EVENT_EN)
;;;1180   void  OS_EventTaskRemove (OS_TCB   *ptcb,
000000  b510              PUSH     {r4,lr}
;;;1181                             OS_EVENT *pevent)
;;;1182   {
;;;1183       INT8U  y;
;;;1184   
;;;1185   
;;;1186       y                       =  ptcb->OSTCBY;
000002  f890202c          LDRB     r2,[r0,#0x2c]
;;;1187       pevent->OSEventTbl[y]  &= (OS_PRIO)~ptcb->OSTCBBitX;    /* Remove task from wait list              */
000006  f890402d          LDRB     r4,[r0,#0x2d]
00000a  188b              ADDS     r3,r1,r2
00000c  43e4              MVNS     r4,r4
00000e  7ada              LDRB     r2,[r3,#0xb]
000010  b2e4              UXTB     r4,r4
000012  4022              ANDS     r2,r2,r4
000014  72da              STRB     r2,[r3,#0xb]
;;;1188       if (pevent->OSEventTbl[y] == 0u) {
000016  d104              BNE      |L13.34|
;;;1189           pevent->OSEventGrp &= (OS_PRIO)~ptcb->OSTCBBitY;
000018  7a8a              LDRB     r2,[r1,#0xa]
00001a  f890002e          LDRB     r0,[r0,#0x2e]
00001e  4382              BICS     r2,r2,r0
000020  728a              STRB     r2,[r1,#0xa]
                  |L13.34|
;;;1190       }
;;;1191   }
000022  bd10              POP      {r4,pc}
;;;1192   #endif
                          ENDP


                          AREA ||i.OS_EventTaskWait||, CODE, READONLY, ALIGN=2

                  OS_EventTaskWait PROC
;;;1102   #if (OS_EVENT_EN)
;;;1103   void  OS_EventTaskWait (OS_EVENT *pevent)
000000  b530              PUSH     {r4,r5,lr}
;;;1104   {
;;;1105       INT8U  y;
;;;1106   
;;;1107   
;;;1108       OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
000002  4b13              LDR      r3,|L14.80|
;;;1109   
;;;1110       pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
000004  f100020b          ADD      r2,r0,#0xb
000008  6a19              LDR      r1,[r3,#0x20]         ;1108  ; OSTCBCur
00000a  f8410f1c          STR      r0,[r1,#0x1c]!        ;1108
00000e  7c0c              LDRB     r4,[r1,#0x10]
000010  7c49              LDRB     r1,[r1,#0x11]
000012  5ca5              LDRB     r5,[r4,r2]
000014  430d              ORRS     r5,r5,r1
000016  54a5              STRB     r5,[r4,r2]
;;;1111       pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
000018  6a19              LDR      r1,[r3,#0x20]  ; OSTCBCur
00001a  7a82              LDRB     r2,[r0,#0xa]
00001c  f101012c          ADD      r1,r1,#0x2c
000020  788c              LDRB     r4,[r1,#2]
000022  ea420204          ORR      r2,r2,r4
000026  7282              STRB     r2,[r0,#0xa]
;;;1112   
;;;1113       y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
000028  7808              LDRB     r0,[r1,#0]
;;;1114       OSRdyTbl[y]  &= (OS_PRIO)~OSTCBCur->OSTCBBitX;
00002a  f1030434          ADD      r4,r3,#0x34
00002e  784d              LDRB     r5,[r1,#1]
000030  5c22              LDRB     r2,[r4,r0]
000032  ea6f0505          MVN      r5,r5
000036  b2ed              UXTB     r5,r5
000038  402a              ANDS     r2,r2,r5
00003a  f1a1012c          SUB      r1,r1,#0x2c
00003e  5422              STRB     r2,[r4,r0]
;;;1115       if (OSRdyTbl[y] == 0u) {                      /* Clear event grp bit if this was only task pending */
000040  d105              BNE      |L14.78|
;;;1116           OSRdyGrp &= (OS_PRIO)~OSTCBCur->OSTCBBitY;
000042  f891002e          LDRB     r0,[r1,#0x2e]
000046  7999              LDRB     r1,[r3,#6]  ; OSRdyGrp
000048  ea210000          BIC      r0,r1,r0
00004c  7198              STRB     r0,[r3,#6]
                  |L14.78|
;;;1117       }
;;;1118   }
00004e  bd30              POP      {r4,r5,pc}
;;;1119   #endif
                          ENDP

                  |L14.80|
                          DCD      ||.data||

                          AREA ||i.OS_EventWaitListInit||, CODE, READONLY, ALIGN=1

                  OS_EventWaitListInit PROC
;;;1249   #if (OS_EVENT_EN)
;;;1250   void  OS_EventWaitListInit (OS_EVENT *pevent)
000000  2200              MOVS     r2,#0
;;;1251   {
;;;1252       INT8U  i;
;;;1253   
;;;1254   
;;;1255       pevent->OSEventGrp = 0u;                     /* No task waiting on event                           */
000002  7282              STRB     r2,[r0,#0xa]
;;;1256       for (i = 0u; i < OS_EVENT_TBL_SIZE; i++) {
000004  4611              MOV      r1,r2
                  |L15.6|
;;;1257           pevent->OSEventTbl[i] = 0u;
000006  1843              ADDS     r3,r0,r1
000008  1c49              ADDS     r1,r1,#1              ;1256
00000a  b2c9              UXTB     r1,r1                 ;1256
00000c  72da              STRB     r2,[r3,#0xb]
00000e  2908              CMP      r1,#8                 ;1256
000010  d3f9              BCC      |L15.6|
;;;1258       }
;;;1259   }
000012  4770              BX       lr
;;;1260   #endif
                          ENDP


                          AREA ||i.OS_InitEventList||, CODE, READONLY, ALIGN=2

                  OS_InitEventList PROC
;;;1274   
;;;1275   static  void  OS_InitEventList (void)
000000  b510              PUSH     {r4,lr}
;;;1276   {
;;;1277   #if (OS_EVENT_EN) && (OS_MAX_EVENTS > 0u)
;;;1278   #if (OS_MAX_EVENTS > 1u)
;;;1279       INT16U     ix;
;;;1280       INT16U     ix_next;
;;;1281       OS_EVENT  *pevent1;
;;;1282       OS_EVENT  *pevent2;
;;;1283   
;;;1284   
;;;1285       OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
000002  21f0              MOVS     r1,#0xf0
000004  4811              LDR      r0,|L16.76|
000006  f7fffffe          BL       OS_MemClr
;;;1286       for (ix = 0u; ix < (OS_MAX_EVENTS - 1u); ix++) {        /* Init. list of free EVENT control blocks */
00000a  2000              MOVS     r0,#0
00000c  4a0f              LDR      r2,|L16.76|
00000e  4603              MOV      r3,r0
                  |L16.16|
;;;1287           ix_next = ix + 1u;
000010  1c41              ADDS     r1,r0,#1
000012  460c              MOV      r4,r1
;;;1288           pevent1 = &OSEventTbl[ix];
000014  eb000040          ADD      r0,r0,r0,LSL #1
000018  b289              UXTH     r1,r1                 ;1287
00001a  eb0200c0          ADD      r0,r2,r0,LSL #3
;;;1289           pevent2 = &OSEventTbl[ix_next];
00001e  eb010141          ADD      r1,r1,r1,LSL #1
000022  eb0201c1          ADD      r1,r2,r1,LSL #3
;;;1290           pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
000026  7003              STRB     r3,[r0,#0]
;;;1291           pevent1->OSEventPtr     = pevent2;
;;;1292   #if OS_EVENT_NAME_EN > 0u
;;;1293           pevent1->OSEventName    = (INT8U *)(void *)"?";     /* Unknown name                            */
000028  6041              STR      r1,[r0,#4]
00002a  a109              ADR      r1,|L16.80|
00002c  6141              STR      r1,[r0,#0x14]         ;1286
00002e  b2a0              UXTH     r0,r4                 ;1286
000030  2809              CMP      r0,#9                 ;1286
000032  d3ed              BCC      |L16.16|
;;;1294   #endif
;;;1295       }
;;;1296       pevent1                         = &OSEventTbl[ix];
000034  eb000040          ADD      r0,r0,r0,LSL #1
000038  eb0200c0          ADD      r0,r2,r0,LSL #3
;;;1297       pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
;;;1298       pevent1->OSEventPtr             = (OS_EVENT *)0;
;;;1299   #if OS_EVENT_NAME_EN > 0u
;;;1300       pevent1->OSEventName            = (INT8U *)(void *)"?"; /* Unknown name                            */
00003c  a104              ADR      r1,|L16.80|
00003e  7003              STRB     r3,[r0,#0]            ;1297
;;;1301   #endif
;;;1302       OSEventFreeList                 = &OSEventTbl[0];
000040  6043              STR      r3,[r0,#4]
000042  6141              STR      r1,[r0,#0x14]
000044  4803              LDR      r0,|L16.84|
000046  6102              STR      r2,[r0,#0x10]  ; OSEventFreeList
;;;1303   #else
;;;1304       OSEventFreeList                 = &OSEventTbl[0];       /* Only have ONE event control block       */
;;;1305       OSEventFreeList->OSEventType    = OS_EVENT_TYPE_UNUSED;
;;;1306       OSEventFreeList->OSEventPtr     = (OS_EVENT *)0;
;;;1307   #if OS_EVENT_NAME_EN > 0u
;;;1308       OSEventFreeList->OSEventName    = (INT8U *)"?";         /* Unknown name                            */
;;;1309   #endif
;;;1310   #endif
;;;1311   #endif
;;;1312   }
000048  bd10              POP      {r4,pc}
;;;1313   /*$PAGE*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L16.76|
                          DCD      ||.bss||
                  |L16.80|
000050  3f00              DCB      "?",0
000052  00                DCB      0
000053  00                DCB      0
                  |L16.84|
                          DCD      ||.data||

                          AREA ||i.OS_InitTCBList||, CODE, READONLY, ALIGN=2

                  OS_InitTCBList PROC
;;;1521   
;;;1522   static  void  OS_InitTCBList (void)
000000  b500              PUSH     {lr}
;;;1523   {
;;;1524       INT8U    ix;
;;;1525       INT8U    ix_next;
;;;1526       OS_TCB  *ptcb1;
;;;1527       OS_TCB  *ptcb2;
;;;1528   
;;;1529   
;;;1530       OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
000002  f44f61c6          MOV      r1,#0x630
000006  4811              LDR      r0,|L17.76|
000008  f7fffffe          BL       OS_MemClr
;;;1531       OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
00000c  f44f7180          MOV      r1,#0x100
000010  480f              LDR      r0,|L17.80|
000012  f7fffffe          BL       OS_MemClr
000016  4b0d              LDR      r3,|L17.76|
;;;1532       for (ix = 0u; ix < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1u); ix++) {    /* Init. list of free TCBs     */
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;1533           ix_next =  ix + 1u;
00001a  1c41              ADDS     r1,r0,#1
00001c  460a              MOV      r2,r1
00001e  b2c9              UXTB     r1,r1
;;;1534           ptcb1   = &OSTCBTbl[ix];
000020  eb0000c0          ADD      r0,r0,r0,LSL #3
000024  eb0300c0          ADD      r0,r3,r0,LSL #3
;;;1535           ptcb2   = &OSTCBTbl[ix_next];
000028  eb0101c1          ADD      r1,r1,r1,LSL #3
00002c  eb0301c1          ADD      r1,r3,r1,LSL #3
000030  6141              STR      r1,[r0,#0x14]         ;1532
000032  b2d0              UXTB     r0,r2                 ;1532
000034  2815              CMP      r0,#0x15              ;1532
000036  d3f0              BCC      |L17.26|
;;;1536           ptcb1->OSTCBNext = ptcb2;
;;;1537   #if OS_TASK_NAME_EN > 0u
;;;1538           ptcb1->OSTCBTaskName = (INT8U *)(void *)"?";             /* Unknown name                       */
;;;1539   #endif
;;;1540       }
;;;1541       ptcb1                   = &OSTCBTbl[ix];
000038  eb0000c0          ADD      r0,r0,r0,LSL #3
00003c  eb0300c0          ADD      r0,r3,r0,LSL #3
;;;1542       ptcb1->OSTCBNext        = (OS_TCB *)0;                       /* Last OS_TCB                        */
000040  2100              MOVS     r1,#0
;;;1543   #if OS_TASK_NAME_EN > 0u
;;;1544       ptcb1->OSTCBTaskName    = (INT8U *)(void *)"?";              /* Unknown name                       */
;;;1545   #endif
;;;1546       OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
000042  6141              STR      r1,[r0,#0x14]
000044  4803              LDR      r0,|L17.84|
;;;1547       OSTCBFreeList           = &OSTCBTbl[0];
000046  6243              STR      r3,[r0,#0x24]  ; OSTCBFreeList
000048  62c1              STR      r1,[r0,#0x2c]  ; OSTCBList
;;;1548   }
00004a  bd00              POP      {pc}
;;;1549   /*$PAGE*/
                          ENDP

                  |L17.76|
                          DCD      ||.bss||+0x5f0
                  |L17.80|
                          DCD      ||.bss||+0x4f0
                  |L17.84|
                          DCD      ||.data||

                          AREA ||i.OS_MemClr||, CODE, READONLY, ALIGN=1

                  OS_MemClr PROC
;;;1569   
;;;1570   void  OS_MemClr (INT8U  *pdest,
000000  2200              MOVS     r2,#0
;;;1571                    INT16U  size)
;;;1572   {
;;;1573       while (size > 0u) {
;;;1574           *pdest++ = (INT8U)0;
;;;1575           size--;
000002  e003              B        |L18.12|
                  |L18.4|
000004  1e49              SUBS     r1,r1,#1
000006  f8002b01          STRB     r2,[r0],#1            ;1574
00000a  b289              UXTH     r1,r1
                  |L18.12|
00000c  2900              CMP      r1,#0                 ;1573
00000e  d1f9              BNE      |L18.4|
;;;1576       }
;;;1577   }
000010  4770              BX       lr
;;;1578   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_MemCopy||, CODE, READONLY, ALIGN=1

                  OS_MemCopy PROC
;;;1602   
;;;1603   void  OS_MemCopy (INT8U  *pdest,
000000  e005              B        |L19.14|
                  |L19.2|
;;;1604                     INT8U  *psrc,
;;;1605                     INT16U  size)
;;;1606   {
;;;1607       while (size > 0u) {
;;;1608           *pdest++ = *psrc++;
000002  f8113b01          LDRB     r3,[r1],#1
;;;1609           size--;
000006  1e52              SUBS     r2,r2,#1
000008  f8003b01          STRB     r3,[r0],#1            ;1608
00000c  b292              UXTH     r2,r2
                  |L19.14|
00000e  2a00              CMP      r2,#0                 ;1607
000010  d1f7              BNE      |L19.2|
;;;1610       }
;;;1611   }
000012  4770              BX       lr
;;;1612   /*$PAGE*/
                          ENDP


                          AREA ||i.OS_Sched||, CODE, READONLY, ALIGN=2

                  OS_Sched PROC
;;;1629   
;;;1630   void  OS_Sched (void)
000000  b570              PUSH     {r4-r6,lr}
;;;1631   {
;;;1632   #if OS_CRITICAL_METHOD == 3u                           /* Allocate storage for CPU status register     */
;;;1633       OS_CPU_SR  cpu_sr = 0u;
;;;1634   #endif
;;;1635   
;;;1636   
;;;1637   
;;;1638       OS_ENTER_CRITICAL();
000002  f7fffffe          BL       OS_CPU_SR_Save
;;;1639       if (OSIntNesting == 0u) {                          /* Schedule only if all ISRs done and ...       */
000006  4c0e              LDR      r4,|L20.64|
000008  4605              MOV      r5,r0                 ;1638
00000a  78a0              LDRB     r0,[r4,#2]  ; OSIntNesting
00000c  b998              CBNZ     r0,|L20.54|
;;;1640           if (OSLockNesting == 0u) {                     /* ... scheduler is not locked                  */
00000e  78e0              LDRB     r0,[r4,#3]  ; OSLockNesting
000010  b988              CBNZ     r0,|L20.54|
;;;1641               OS_SchedNew();
000012  f7fffffe          BL       OS_SchedNew
;;;1642               OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
000016  480b              LDR      r0,|L20.68|
000018  7962              LDRB     r2,[r4,#5]  ; OSPrioHighRdy
00001a  f8501022          LDR      r1,[r0,r2,LSL #2]
;;;1643               if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
00001e  62a1              STR      r1,[r4,#0x28]  ; OSTCBHighRdy
000020  7920              LDRB     r0,[r4,#4]  ; OSPrioCur
000022  4282              CMP      r2,r0
000024  d007              BEQ      |L20.54|
;;;1644   #if OS_TASK_PROFILE_EN > 0u
;;;1645                   OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
000026  6b08              LDR      r0,[r1,#0x30]
000028  1c40              ADDS     r0,r0,#1
;;;1646   #endif
;;;1647                   OSCtxSwCtr++;                          /* Increment context switch counter             */
00002a  6308              STR      r0,[r1,#0x30]
00002c  68e0              LDR      r0,[r4,#0xc]  ; OSCtxSwCtr
00002e  1c40              ADDS     r0,r0,#1
;;;1648                   OS_TASK_SW();                          /* Perform a context switch                     */
000030  60e0              STR      r0,[r4,#0xc]  ; OSCtxSwCtr
000032  f7fffffe          BL       OSCtxSw
                  |L20.54|
;;;1649               }
;;;1650           }
;;;1651       }
;;;1652       OS_EXIT_CRITICAL();
000036  4628              MOV      r0,r5
000038  e8bd4070          POP      {r4-r6,lr}
00003c  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;1653   }
;;;1654   
                          ENDP

                  |L20.64|
                          DCD      ||.data||
                  |L20.68|
                          DCD      ||.bss||+0x4f0

                          AREA ||i.OS_SchedNew||, CODE, READONLY, ALIGN=2

                  OS_SchedNew PROC
;;;1671   
;;;1672   static  void  OS_SchedNew (void)
000000  4a06              LDR      r2,|L21.28|
;;;1673   {
;;;1674   #if OS_LOWEST_PRIO <= 63u                        /* See if we support up to 64 tasks                   */
;;;1675       INT8U   y;
;;;1676   
;;;1677   
;;;1678       y             = OSUnMapTbl[OSRdyGrp];
000002  4905              LDR      r1,|L21.24|
;;;1679       OSPrioHighRdy = (INT8U)((y << 3u) + OSUnMapTbl[OSRdyTbl[y]]);
000004  f1020334          ADD      r3,r2,#0x34
000008  7990              LDRB     r0,[r2,#6]            ;1678  ; OSRdyGrp
00000a  5c08              LDRB     r0,[r1,r0]            ;1678
00000c  5c1b              LDRB     r3,[r3,r0]
00000e  5cc9              LDRB     r1,[r1,r3]
000010  eb0100c0          ADD      r0,r1,r0,LSL #3
000014  7150              STRB     r0,[r2,#5]
;;;1680   #else                                            /* We support up to 256 tasks                         */
;;;1681       INT8U     y;
;;;1682       OS_PRIO  *ptbl;
;;;1683   
;;;1684   
;;;1685       if ((OSRdyGrp & 0xFFu) != 0u) {
;;;1686           y = OSUnMapTbl[OSRdyGrp & 0xFFu];
;;;1687       } else {
;;;1688           y = OSUnMapTbl[(OS_PRIO)(OSRdyGrp >> 8u) & 0xFFu] + 8u;
;;;1689       }
;;;1690       ptbl = &OSRdyTbl[y];
;;;1691       if ((*ptbl & 0xFFu) != 0u) {
;;;1692           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(*ptbl & 0xFFu)]);
;;;1693       } else {
;;;1694           OSPrioHighRdy = (INT8U)((y << 4u) + OSUnMapTbl[(OS_PRIO)(*ptbl >> 8u) & 0xFFu] + 8u);
;;;1695       }
;;;1696   #endif
;;;1697   }
000016  4770              BX       lr
;;;1698   
                          ENDP

                  |L21.24|
                          DCD      ||.constdata||
                  |L21.28|
                          DCD      ||.data||

                          AREA ||i.OS_StrLen||, CODE, READONLY, ALIGN=1

                  OS_StrLen PROC
;;;1716   #if (OS_EVENT_NAME_EN > 0u) || (OS_FLAG_NAME_EN > 0u) || (OS_MEM_NAME_EN > 0u) || (OS_TASK_NAME_EN > 0u) || (OS_TMR_CFG_NAME_EN > 0u)
;;;1717   INT8U  OS_StrLen (INT8U *psrc)
000000  4601              MOV      r1,r0
;;;1718   {
;;;1719       INT8U  len;
;;;1720   
;;;1721   
;;;1722       len = 0u;
000002  2000              MOVS     r0,#0
;;;1723       while (*psrc != OS_ASCII_NUL) {
000004  e002              B        |L22.12|
                  |L22.6|
;;;1724           psrc++;
000006  1c49              ADDS     r1,r1,#1
;;;1725           len++;
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
                  |L22.12|
00000c  780a              LDRB     r2,[r1,#0]            ;1723
00000e  2a00              CMP      r2,#0                 ;1723
000010  d1f9              BNE      |L22.6|
;;;1726       }
;;;1727       return (len);
;;;1728   }
000012  4770              BX       lr
;;;1729   #endif
                          ENDP


                          AREA ||i.OS_TCBInit||, CODE, READONLY, ALIGN=2

                  OS_TCBInit PROC
;;;1916   
;;;1917   INT8U  OS_TCBInit (INT8U    prio,
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1918                      OS_STK  *ptos,
;;;1919                      OS_STK  *pbos,
;;;1920                      INT16U   id,
;;;1921                      INT32U   stk_size,
;;;1922                      void    *pext,
;;;1923                      INT16U   opt)
;;;1924   {
000004  4605              MOV      r5,r0
000006  e9ddba0e          LDRD     r11,r10,[sp,#0x38]
00000a  460e              MOV      r6,r1
00000c  4690              MOV      r8,r2
00000e  4699              MOV      r9,r3
;;;1925       OS_TCB    *ptcb;
;;;1926   #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;1927       OS_CPU_SR  cpu_sr = 0u;
;;;1928   #endif
;;;1929   #if OS_TASK_REG_TBL_SIZE > 0u
;;;1930       INT8U      i;
;;;1931   #endif
;;;1932   
;;;1933   
;;;1934       OS_ENTER_CRITICAL();
000010  f7fffffe          BL       OS_CPU_SR_Save
;;;1935       ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
000014  4f34              LDR      r7,|L23.232|
;;;1936       if (ptcb != (OS_TCB *)0) {
000016  6a7c              LDR      r4,[r7,#0x24]  ; OSTCBFreeList
000018  b3ec              CBZ      r4,|L23.150|
00001a  f1040410          ADD      r4,r4,#0x10
;;;1937           OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
00001e  6861              LDR      r1,[r4,#4]
;;;1938           OS_EXIT_CRITICAL();
000020  6279              STR      r1,[r7,#0x24]  ; OSTCBFreeList
000022  f7fffffe          BL       OS_CPU_SR_Restore
;;;1939           ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
000026  f8446c10          STR      r6,[r4,#-0x10]
;;;1940           ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
00002a  76a5              STRB     r5,[r4,#0x1a]
;;;1941           ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
00002c  2600              MOVS     r6,#0
00002e  7626              STRB     r6,[r4,#0x18]
;;;1942           ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
000030  7666              STRB     r6,[r4,#0x19]
;;;1943           ptcb->OSTCBDly           = 0u;                     /* Task is not delayed                      */
;;;1944   
;;;1945   #if OS_TASK_CREATE_EXT_EN > 0u
;;;1946           ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
000032  6166              STR      r6,[r4,#0x14]
000034  f1a40008          SUB      r0,r4,#8
000038  f844ac0c          STR      r10,[r4,#-0xc]
00003c  e8a00900          STM      r0!,{r8,r11}
;;;1947           ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
;;;1948           ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
;;;1949           ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
000040  9810              LDR      r0,[sp,#0x40]
000042  8020              STRH     r0,[r4,#0]
;;;1950           ptcb->OSTCBId            = id;                     /* Store task ID                            */
000044  f8a49002          STRH     r9,[r4,#2]
;;;1951   #else
;;;1952           pext                     = pext;                   /* Prevent compiler warning if not used     */
;;;1953           stk_size                 = stk_size;
;;;1954           pbos                     = pbos;
;;;1955           opt                      = opt;
;;;1956           id                       = id;
;;;1957   #endif
;;;1958   
;;;1959   #if OS_TASK_DEL_EN > 0u
;;;1960           ptcb->OSTCBDelReq        = OS_ERR_NONE;
;;;1961   #endif
;;;1962   
;;;1963   #if OS_LOWEST_PRIO <= 63u                                         /* Pre-compute X, Y                  */
;;;1964           ptcb->OSTCBY             = (INT8U)(prio >> 3u);
000048  08e9              LSRS     r1,r5,#3
00004a  7721              STRB     r1,[r4,#0x1c]
;;;1965           ptcb->OSTCBX             = (INT8U)(prio & 0x07u);
00004c  f0050007          AND      r0,r5,#7
;;;1966   #else                                                             /* Pre-compute X, Y                  */
;;;1967           ptcb->OSTCBY             = (INT8U)((INT8U)(prio >> 4u) & 0xFFu);
;;;1968           ptcb->OSTCBX             = (INT8U) (prio & 0x0Fu);
;;;1969   #endif
;;;1970                                                                     /* Pre-compute BitX and BitY         */
;;;1971           ptcb->OSTCBBitY          = (OS_PRIO)(1uL << ptcb->OSTCBY);
000050  2201              MOVS     r2,#1
000052  fa02f101          LSL      r1,r2,r1
000056  76e0              STRB     r0,[r4,#0x1b]         ;1965
;;;1972           ptcb->OSTCBBitX          = (OS_PRIO)(1uL << ptcb->OSTCBX);
000058  4082              LSLS     r2,r2,r0
00005a  77a1              STRB     r1,[r4,#0x1e]         ;1971
00005c  7762              STRB     r2,[r4,#0x1d]
;;;1973   
;;;1974   #if (OS_EVENT_EN)
;;;1975           ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
;;;1976   #if (OS_EVENT_MULTI_EN > 0u)
;;;1977           ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
;;;1978   #endif
;;;1979   #endif
;;;1980   
;;;1981   #if (OS_FLAG_EN > 0u) && (OS_MAX_FLAGS > 0u) && (OS_TASK_DEL_EN > 0u)
;;;1982           ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
;;;1983   #endif
;;;1984   
;;;1985   #if (OS_MBOX_EN > 0u) || ((OS_Q_EN > 0u) && (OS_MAX_QS > 0u))
;;;1986           ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
00005e  60e6              STR      r6,[r4,#0xc]
;;;1987   #endif
;;;1988   
;;;1989   #if OS_TASK_PROFILE_EN > 0u
;;;1990           ptcb->OSTCBCtxSwCtr    = 0uL;                      /* Initialize profiling variables           */
000060  6126              STR      r6,[r4,#0x10]
;;;1991           ptcb->OSTCBCyclesStart = 0uL;
000062  6226              STR      r6,[r4,#0x20]
;;;1992           ptcb->OSTCBCyclesTot   = 0uL;
000064  62a6              STR      r6,[r4,#0x28]
;;;1993           ptcb->OSTCBStkBase     = (OS_STK *)0;
000066  6266              STR      r6,[r4,#0x24]
;;;1994           ptcb->OSTCBStkUsed     = 0uL;
000068  62e6              STR      r6,[r4,#0x2c]
00006a  6326              STR      r6,[r4,#0x30]
00006c  f1a40410          SUB      r4,r4,#0x10
;;;1995   #endif
;;;1996   
;;;1997   #if OS_TASK_NAME_EN > 0u
;;;1998           ptcb->OSTCBTaskName    = (INT8U *)(void *)"?";
;;;1999   #endif
;;;2000   
;;;2001   #if OS_TASK_REG_TBL_SIZE > 0u                              /* Initialize the task variables            */
;;;2002           for (i = 0u; i < OS_TASK_REG_TBL_SIZE; i++) {
000070  4630              MOV      r0,r6
                  |L23.114|
;;;2003               ptcb->OSTCBRegTbl[i] = 0u;
000072  eb040180          ADD      r1,r4,r0,LSL #2
000076  1c40              ADDS     r0,r0,#1              ;2002
000078  644e              STR      r6,[r1,#0x44]         ;2002
00007a  f01000ff          ANDS     r0,r0,#0xff           ;2002
00007e  d0f8              BEQ      |L23.114|
;;;2004           }
;;;2005   #endif
;;;2006   
;;;2007           OSTCBInitHook(ptcb);
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       OSTCBInitHook
;;;2008   
;;;2009           OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       OSTaskCreateHook
;;;2010   
;;;2011           OS_ENTER_CRITICAL();
00008c  f7fffffe          BL       OS_CPU_SR_Save
000090  4601              MOV      r1,r0
;;;2012           OSTCBPrioTbl[prio] = ptcb;
000092  4816              LDR      r0,|L23.236|
000094  e000              B        |L23.152|
                  |L23.150|
000096  e022              B        |L23.222|
                  |L23.152|
000098  f8404025          STR      r4,[r0,r5,LSL #2]
;;;2013           ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
00009c  6af8              LDR      r0,[r7,#0x2c]  ; OSTCBList
00009e  e9c40605          STRD     r0,r6,[r4,#0x14]
;;;2014           ptcb->OSTCBPrev    = (OS_TCB *)0;
;;;2015           if (OSTCBList != (OS_TCB *)0) {
0000a2  b100              CBZ      r0,|L23.166|
;;;2016               OSTCBList->OSTCBPrev = ptcb;
0000a4  6184              STR      r4,[r0,#0x18]
                  |L23.166|
;;;2017           }
;;;2018           OSTCBList               = ptcb;
0000a6  62fc              STR      r4,[r7,#0x2c]  ; OSTCBList
0000a8  f104042c          ADD      r4,r4,#0x2c
;;;2019           OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
0000ac  79ba              LDRB     r2,[r7,#6]  ; OSRdyGrp
0000ae  78a0              LDRB     r0,[r4,#2]
;;;2020           OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
0000b0  4b0d              LDR      r3,|L23.232|
0000b2  ea400002          ORR      r0,r0,r2              ;2019
0000b6  71b8              STRB     r0,[r7,#6]            ;2019
0000b8  7820              LDRB     r0,[r4,#0]
0000ba  f1030334          ADD      r3,r3,#0x34
0000be  7864              LDRB     r4,[r4,#1]
0000c0  5c1a              LDRB     r2,[r3,r0]
0000c2  ea420204          ORR      r2,r2,r4
0000c6  541a              STRB     r2,[r3,r0]
;;;2021           OSTaskCtr++;                                       /* Increment the #tasks counter             */
0000c8  7a38              LDRB     r0,[r7,#8]  ; OSTaskCtr
0000ca  f1000001          ADD      r0,r0,#1
0000ce  7238              STRB     r0,[r7,#8]
;;;2022           OS_EXIT_CRITICAL();
0000d0  4608              MOV      r0,r1
0000d2  f7fffffe          BL       OS_CPU_SR_Restore
;;;2023           return (OS_ERR_NONE);
0000d6  2000              MOVS     r0,#0
                  |L23.216|
;;;2024       }
;;;2025       OS_EXIT_CRITICAL();
;;;2026       return (OS_ERR_TASK_NO_MORE_TCB);
;;;2027   }
0000d8  b004              ADD      sp,sp,#0x10
0000da  e8bd9ff0          POP      {r4-r12,pc}
                  |L23.222|
0000de  f7fffffe          BL       OS_CPU_SR_Restore
0000e2  2042              MOVS     r0,#0x42              ;2026
0000e4  e7f8              B        |L23.216|
;;;2028   	 	   	  		 			 	    		   		 		 	 	 			 	    		   	 			 	  	 		 				 		  			 		 					 	  	  		      		  	   		      		  	 		 	      		   		 		  	 		 	      		  		  		  
                          ENDP

0000e6  0000              DCW      0x0000
                  |L23.232|
                          DCD      ||.data||
                  |L23.236|
                          DCD      ||.bss||+0x4f0

                          AREA ||i.OS_TaskIdle||, CODE, READONLY, ALIGN=2

                  OS_TaskIdle PROC
;;;1751   
;;;1752   void  OS_TaskIdle (void *p_arg)
000000  4c05              LDR      r4,|L24.24|
                  |L24.2|
;;;1753   {
;;;1754   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1755       OS_CPU_SR  cpu_sr = 0u;
;;;1756   #endif
;;;1757   
;;;1758   
;;;1759   
;;;1760       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
;;;1761       for (;;) {
;;;1762           OS_ENTER_CRITICAL();
000002  f7fffffe          BL       OS_CPU_SR_Save
;;;1763           OSIdleCtr++;
000006  69e1              LDR      r1,[r4,#0x1c]  ; OSIdleCtr
000008  1c49              ADDS     r1,r1,#1
00000a  61e1              STR      r1,[r4,#0x1c]  ; OSIdleCtr
;;;1764           OS_EXIT_CRITICAL();
00000c  f7fffffe          BL       OS_CPU_SR_Restore
;;;1765           OSTaskIdleHook();                        /* Call user definable HOOK                           */
000010  f7fffffe          BL       OSTaskIdleHook
000014  e7f5              B        |L24.2|
;;;1766       }
;;;1767   }
;;;1768   /*$PAGE*/
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      ||.data||

                          AREA ||i.OS_TaskStat||, CODE, READONLY, ALIGN=2

                  OS_TaskStat PROC
;;;1793   #if OS_TASK_STAT_EN > 0u
;;;1794   void  OS_TaskStat (void *p_arg)
000000  4c14              LDR      r4,|L25.84|
;;;1795   {
;;;1796   #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;1797       OS_CPU_SR  cpu_sr = 0u;
;;;1798   #endif
;;;1799   
;;;1800   
;;;1801   
;;;1802       p_arg = p_arg;                               /* Prevent compiler warning for not using 'p_arg'     */
;;;1803       while (OSStatRdy == OS_FALSE) {
000002  e002              B        |L25.10|
                  |L25.4|
;;;1804           OSTimeDly(2u * OS_TICKS_PER_SEC / 10u);  /* Wait until statistic task is ready                 */
000004  20c8              MOVS     r0,#0xc8
000006  f7fffffe          BL       OSTimeDly
                  |L25.10|
00000a  7860              LDRB     r0,[r4,#1]            ;1803  ; OSStatRdy
00000c  2800              CMP      r0,#0                 ;1803
00000e  d0f9              BEQ      |L25.4|
;;;1805       }
;;;1806       OSIdleCtrMax /= 100uL;
000010  2164              MOVS     r1,#0x64
000012  6960              LDR      r0,[r4,#0x14]  ; OSIdleCtrMax
000014  2500              MOVS     r5,#0                 ;1797
000016  fbb0f0f1          UDIV     r0,r0,r1
;;;1807       if (OSIdleCtrMax == 0uL) {
00001a  6160              STR      r0,[r4,#0x14]  ; OSIdleCtrMax
00001c  b918              CBNZ     r0,|L25.38|
;;;1808           OSCPUUsage = 0u;
00001e  7025              STRB     r5,[r4,#0]
;;;1809   #if OS_TASK_SUSPEND_EN > 0u
;;;1810           (void)OSTaskSuspend(OS_PRIO_SELF);
000020  20ff              MOVS     r0,#0xff
000022  f7fffffe          BL       OSTaskSuspend
                  |L25.38|
;;;1811   #else
;;;1812           for (;;) {
;;;1813               OSTimeDly(OS_TICKS_PER_SEC);
;;;1814           }
;;;1815   #endif
;;;1816       }
;;;1817       for (;;) {
;;;1818           OS_ENTER_CRITICAL();
000026  f7fffffe          BL       OS_CPU_SR_Save
;;;1819           OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
00002a  69e1              LDR      r1,[r4,#0x1c]  ; OSIdleCtr
;;;1820           OSIdleCtr    = 0uL;                      /* Reset the idle counter for the next second         */
00002c  e9c41506          STRD     r1,r5,[r4,#0x18]
;;;1821           OS_EXIT_CRITICAL();
000030  f7fffffe          BL       OS_CPU_SR_Restore
000034  e9d41005          LDRD     r1,r0,[r4,#0x14]
;;;1822           OSCPUUsage   = (INT8U)(100uL - OSIdleCtrRun / OSIdleCtrMax);
000038  fbb0f0f1          UDIV     r0,r0,r1
00003c  f1c00064          RSB      r0,r0,#0x64
000040  7020              STRB     r0,[r4,#0]
;;;1823           OSTaskStatHook();                        /* Invoke user definable hook                         */
000042  f7fffffe          BL       OSTaskStatHook
;;;1824   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1825           OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
000046  f7fffffe          BL       OS_TaskStatStkChk
;;;1826   #endif
;;;1827           OSTimeDly(OS_TICKS_PER_SEC / 10u);       /* Accumulate OSIdleCtr for the next 1/10 second      */
00004a  2064              MOVS     r0,#0x64
00004c  f7fffffe          BL       OSTimeDly
000050  e7e9              B        |L25.38|
;;;1828       }
;;;1829   }
;;;1830   #endif
                          ENDP

000052  0000              DCW      0x0000
                  |L25.84|
                          DCD      ||.data||

                          AREA ||i.OS_TaskStatStkChk||, CODE, READONLY, ALIGN=2

                  OS_TaskStatStkChk PROC
;;;1844   #if (OS_TASK_STAT_STK_CHK_EN > 0u) && (OS_TASK_CREATE_EXT_EN > 0u)
;;;1845   void  OS_TaskStatStkChk (void)
000000  b57c              PUSH     {r2-r6,lr}
;;;1846   {
;;;1847       OS_TCB      *ptcb;
;;;1848       OS_STK_DATA  stk_data;
;;;1849       INT8U        err;
;;;1850       INT8U        prio;
;;;1851   
;;;1852   
;;;1853       for (prio = 0u; prio <= OS_TASK_IDLE_PRIO; prio++) {
;;;1854           err = OSTaskStkChk(prio, &stk_data);
;;;1855           if (err == OS_ERR_NONE) {
;;;1856               ptcb = OSTCBPrioTbl[prio];
000002  4d0c              LDR      r5,|L26.52|
000004  2400              MOVS     r4,#0                 ;1853
                  |L26.6|
000006  4669              MOV      r1,sp                 ;1854
000008  4620              MOV      r0,r4                 ;1854
00000a  f7fffffe          BL       OSTaskStkChk
00000e  b958              CBNZ     r0,|L26.40|
000010  f8551024          LDR      r1,[r5,r4,LSL #2]
;;;1857               if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
000014  b141              CBZ      r1,|L26.40|
;;;1858                   if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
000016  2901              CMP      r1,#1
000018  d006              BEQ      |L26.40|
00001a  e9d10202          LDRD     r0,r2,[r1,#8]
;;;1859   #if OS_TASK_PROFILE_EN > 0u
;;;1860                       #if OS_STK_GROWTH == 1u
;;;1861                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
00001e  eb000082          ADD      r0,r0,r2,LSL #2
;;;1862                       #else
;;;1863                       ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
;;;1864                       #endif
;;;1865                       ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
000022  63c8              STR      r0,[r1,#0x3c]
000024  9801              LDR      r0,[sp,#4]
000026  6408              STR      r0,[r1,#0x40]
                  |L26.40|
000028  1c64              ADDS     r4,r4,#1              ;1853
00002a  b2e4              UXTB     r4,r4                 ;1853
00002c  2c3f              CMP      r4,#0x3f              ;1853
00002e  d9ea              BLS      |L26.6|
;;;1866   #endif
;;;1867                   }
;;;1868               }
;;;1869           }
;;;1870       }
;;;1871   }
000030  bd7c              POP      {r2-r6,pc}
;;;1872   #endif
                          ENDP

000032  0000              DCW      0x0000
                  |L26.52|
                          DCD      ||.bss||+0x4f0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  OSEventTbl
                          %        240
                  OSTaskStatStk
                          %        512
                  OSTaskIdleStk
                          %        512
                  OSTCBPrioTbl
                          %        256
                  OSTCBTbl
                          %        1584

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  OSUnMapTbl
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  OSCPUUsage
000000  00                DCB      0x00
                  OSStatRdy
000001  00                DCB      0x00
                  OSIntNesting
000002  00                DCB      0x00
                  OSLockNesting
000003  00                DCB      0x00
                  OSPrioCur
000004  00                DCB      0x00
                  OSPrioHighRdy
000005  00                DCB      0x00
                  OSRdyGrp
000006  00                DCB      0x00
                  OSRunning
000007  00                DCB      0x00
                  OSTaskCtr
000008  00                DCB      0x00
                  OSTickStepState
000009  000000            DCB      0x00,0x00,0x00
                  OSCtxSwCtr
                          DCD      0x00000000
                  OSEventFreeList
                          DCD      0x00000000
                  OSIdleCtrMax
                          DCD      0x00000000
                  OSIdleCtrRun
                          DCD      0x00000000
                  OSIdleCtr
                          DCD      0x00000000
                  OSTCBCur
                          DCD      0x00000000
                  OSTCBFreeList
                          DCD      0x00000000
                  OSTCBHighRdy
                          DCD      0x00000000
                  OSTCBList
                          DCD      0x00000000
                  OSTime
                          DCD      0x00000000
                  OSRdyTbl
                          %        8
