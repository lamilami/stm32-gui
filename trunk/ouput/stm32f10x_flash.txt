; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_flash.o --depend=.\ouput\stm32f10x_flash.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_flash.crf Source\FWLib\src\stm32f10x_flash.c]
                          THUMB

                          AREA ||i.FLASH_BootConfig||, CODE, READONLY, ALIGN=2

                  FLASH_BootConfig PROC
;;;1170     */
;;;1171   FLASH_Status FLASH_BootConfig(uint16_t FLASH_BOOT)
000000  b570              PUSH     {r4-r6,lr}
;;;1172   { 
;;;1173     FLASH_Status status = FLASH_COMPLETE; 
;;;1174     assert_param(IS_FLASH_BOOT(FLASH_BOOT));
;;;1175     /* Authorize the small information block programming */
;;;1176     FLASH->OPTKEYR = FLASH_KEY1;
000002  4c14              LDR      r4,|L1.84|
000004  4605              MOV      r5,r0                 ;1172
000006  4812              LDR      r0,|L1.80|
000008  60a0              STR      r0,[r4,#8]
;;;1177     FLASH->OPTKEYR = FLASH_KEY2;
00000a  4813              LDR      r0,|L1.88|
00000c  60a0              STR      r0,[r4,#8]
;;;1178     
;;;1179     /* Wait for last operation to be completed */
;;;1180     status = FLASH_WaitForLastOperation(ProgramTimeout);
00000e  f44f5600          MOV      r6,#0x2000
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1181     
;;;1182     if(status == FLASH_COMPLETE)
000018  2804              CMP      r0,#4
00001a  d115              BNE      |L1.72|
;;;1183     {  
;;;1184       /* Enable the Option Bytes Programming operation */
;;;1185       FLASH->CR |= CR_OPTPG_Set; 
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400010          ORR      r0,r0,#0x10
000022  6120              STR      r0,[r4,#0x10]
;;;1186   
;;;1187       if(FLASH_BOOT == FLASH_BOOT_Bank1)
;;;1188       {
;;;1189         OB->USER |= OB_USER_BFB2;
000024  480d              LDR      r0,|L1.92|
;;;1190       }
;;;1191       else
;;;1192       {
;;;1193         OB->USER &= (uint16_t)(~(uint16_t)(OB_USER_BFB2));
000026  f8b01802          LDRH     r1,[r0,#0x802]
00002a  b175              CBZ      r5,|L1.74|
00002c  f0210108          BIC      r1,r1,#8
                  |L1.48|
000030  f8a01802          STRH     r1,[r0,#0x802]
;;;1194       }
;;;1195       /* Wait for last operation to be completed */
;;;1196       status = FLASH_WaitForLastOperation(ProgramTimeout);
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1197       if(status != FLASH_TIMEOUT)
00003a  2805              CMP      r0,#5
00003c  d004              BEQ      |L1.72|
;;;1198       {
;;;1199         /* if the program operation is completed, disable the OPTPG Bit */
;;;1200         FLASH->CR &= CR_OPTPG_Reset;
00003e  6921              LDR      r1,[r4,#0x10]
000040  f64172ef          MOV      r2,#0x1fef
000044  4011              ANDS     r1,r1,r2
000046  6121              STR      r1,[r4,#0x10]
                  |L1.72|
;;;1201       }
;;;1202     }    
;;;1203     /* Return the Option Byte program Status */
;;;1204     return status;
;;;1205   }
000048  bd70              POP      {r4-r6,pc}
                  |L1.74|
00004a  f0410108          ORR      r1,r1,#8              ;1189
00004e  e7ef              B        |L1.48|
;;;1206   #endif /* STM32F10X_XL */
                          ENDP

                  |L1.80|
                          DCD      0x45670123
                  |L1.84|
                          DCD      0x40022000
                  |L1.88|
                          DCD      0xcdef89ab
                  |L1.92|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_ClearFlag||, CODE, READONLY, ALIGN=2

                  FLASH_ClearFlag PROC
;;;1441     */
;;;1442   void FLASH_ClearFlag(uint32_t FLASH_FLAG)
000000  4903              LDR      r1,|L2.16|
;;;1443   {
;;;1444   #ifdef STM32F10X_XL
;;;1445     /* Check the parameters */
;;;1446     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1447   
;;;1448     if((FLASH_FLAG & 0x80000000) != 0x0)
000002  2800              CMP      r0,#0
000004  da01              BGE      |L2.10|
;;;1449     {
;;;1450       /* Clear the flags */
;;;1451       FLASH->SR2 = FLASH_FLAG;
000006  64c8              STR      r0,[r1,#0x4c]
;;;1452     }
;;;1453     else
;;;1454     {
;;;1455       /* Clear the flags */
;;;1456       FLASH->SR = FLASH_FLAG;
;;;1457     }  
;;;1458   
;;;1459   #else
;;;1460     /* Check the parameters */
;;;1461     assert_param(IS_FLASH_CLEAR_FLAG(FLASH_FLAG)) ;
;;;1462     
;;;1463     /* Clear the flags */
;;;1464     FLASH->SR = FLASH_FLAG;
;;;1465   #endif /* STM32F10X_XL */
;;;1466   }
000008  4770              BX       lr
                  |L2.10|
00000a  60c8              STR      r0,[r1,#0xc]          ;1456
00000c  4770              BX       lr
;;;1467   
                          ENDP

00000e  0000              DCW      0x0000
                  |L2.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_EnableWriteProtection||, CODE, READONLY, ALIGN=2

                  FLASH_EnableWriteProtection PROC
;;;973      */
;;;974    FLASH_Status FLASH_EnableWriteProtection(uint32_t FLASH_Pages)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;975    {
;;;976      uint16_t WRP0_Data = 0xFFFF, WRP1_Data = 0xFFFF, WRP2_Data = 0xFFFF, WRP3_Data = 0xFFFF;
;;;977      
;;;978      FLASH_Status status = FLASH_COMPLETE;
;;;979      
;;;980      /* Check the parameters */
;;;981      assert_param(IS_FLASH_WRPROT_PAGE(FLASH_Pages));
;;;982      
;;;983      FLASH_Pages = (uint32_t)(~FLASH_Pages);
000004  43c0              MVNS     r0,r0
;;;984      WRP0_Data = (uint16_t)(FLASH_Pages & WRP0_Mask);
000006  b2c4              UXTB     r4,r0
;;;985      WRP1_Data = (uint16_t)((FLASH_Pages & WRP1_Mask) >> 8);
000008  f3c02507          UBFX     r5,r0,#8,#8
;;;986      WRP2_Data = (uint16_t)((FLASH_Pages & WRP2_Mask) >> 16);
00000c  f3c04607          UBFX     r6,r0,#16,#8
;;;987      WRP3_Data = (uint16_t)((FLASH_Pages & WRP3_Mask) >> 24);
000010  0e07              LSRS     r7,r0,#24
;;;988      
;;;989      /* Wait for last operation to be completed */
;;;990      status = FLASH_WaitForLastOperation(ProgramTimeout);
000012  f44f5a00          MOV      r10,#0x2000
000016  4650              MOV      r0,r10
000018  f7fffffe          BL       FLASH_WaitForLastOperation
;;;991      
;;;992      if(status == FLASH_COMPLETE)
00001c  2804              CMP      r0,#4
00001e  d13a              BNE      |L3.150|
;;;993      {
;;;994        /* Authorizes the small information block programming */
;;;995        FLASH->OPTKEYR = FLASH_KEY1;
000020  f8df907c          LDR      r9,|L3.160|
000024  4a1d              LDR      r2,|L3.156|
000026  f8c92008          STR      r2,[r9,#8]
;;;996        FLASH->OPTKEYR = FLASH_KEY2;
00002a  4a1e              LDR      r2,|L3.164|
00002c  f8c92008          STR      r2,[r9,#8]
;;;997        FLASH->CR |= CR_OPTPG_Set;
000030  f8d92010          LDR      r2,[r9,#0x10]
000034  f0420210          ORR      r2,r2,#0x10
000038  f8c92010          STR      r2,[r9,#0x10]
;;;998        if(WRP0_Data != 0xFF)
;;;999        {
;;;1000         OB->WRP0 = WRP0_Data;
00003c  f8df8068          LDR      r8,|L3.168|
000040  2cff              CMP      r4,#0xff              ;998
000042  d006              BEQ      |L3.82|
000044  f8a84808          STRH     r4,[r8,#0x808]
;;;1001         
;;;1002         /* Wait for last operation to be completed */
;;;1003         status = FLASH_WaitForLastOperation(ProgramTimeout);
000048  4650              MOV      r0,r10
00004a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1004       }
;;;1005       if((status == FLASH_COMPLETE) && (WRP1_Data != 0xFF))
00004e  2804              CMP      r0,#4
000050  d118              BNE      |L3.132|
                  |L3.82|
000052  2dff              CMP      r5,#0xff
000054  d006              BEQ      |L3.100|
;;;1006       {
;;;1007         OB->WRP1 = WRP1_Data;
000056  f8a8580a          STRH     r5,[r8,#0x80a]
;;;1008         
;;;1009         /* Wait for last operation to be completed */
;;;1010         status = FLASH_WaitForLastOperation(ProgramTimeout);
00005a  4650              MOV      r0,r10
00005c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1011       }
;;;1012       if((status == FLASH_COMPLETE) && (WRP2_Data != 0xFF))
000060  2804              CMP      r0,#4
000062  d10f              BNE      |L3.132|
                  |L3.100|
000064  2eff              CMP      r6,#0xff
000066  d006              BEQ      |L3.118|
;;;1013       {
;;;1014         OB->WRP2 = WRP2_Data;
000068  f8a8680c          STRH     r6,[r8,#0x80c]
;;;1015         
;;;1016         /* Wait for last operation to be completed */
;;;1017         status = FLASH_WaitForLastOperation(ProgramTimeout);
00006c  4650              MOV      r0,r10
00006e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1018       }
;;;1019       
;;;1020       if((status == FLASH_COMPLETE)&& (WRP3_Data != 0xFF))
000072  2804              CMP      r0,#4
000074  d106              BNE      |L3.132|
                  |L3.118|
000076  2fff              CMP      r7,#0xff
000078  d006              BEQ      |L3.136|
;;;1021       {
;;;1022         OB->WRP3 = WRP3_Data;
00007a  f8a8780e          STRH     r7,[r8,#0x80e]
;;;1023        
;;;1024         /* Wait for last operation to be completed */
;;;1025         status = FLASH_WaitForLastOperation(ProgramTimeout);
00007e  4650              MOV      r0,r10
000080  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L3.132|
;;;1026       }
;;;1027             
;;;1028       if(status != FLASH_TIMEOUT)
000084  2805              CMP      r0,#5
000086  d006              BEQ      |L3.150|
                  |L3.136|
;;;1029       {
;;;1030         /* if the program operation is completed, disable the OPTPG Bit */
;;;1031         FLASH->CR &= CR_OPTPG_Reset;
000088  f8d92010          LDR      r2,[r9,#0x10]
00008c  f64173ef          MOV      r3,#0x1fef
000090  401a              ANDS     r2,r2,r3
000092  f8c92010          STR      r2,[r9,#0x10]
                  |L3.150|
;;;1032       }
;;;1033     } 
;;;1034     /* Return the write protection operation Status */
;;;1035     return status;       
;;;1036   }
000096  e8bd87f0          POP      {r4-r10,pc}
;;;1037   
                          ENDP

00009a  0000              DCW      0x0000
                  |L3.156|
                          DCD      0x45670123
                  |L3.160|
                          DCD      0x40022000
                  |L3.164|
                          DCD      0xcdef89ab
                  |L3.168|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_EraseAllBank1Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank1Pages PROC
;;;553      */
;;;554    FLASH_Status FLASH_EraseAllBank1Pages(void)
000000  b530              PUSH     {r4,r5,lr}
;;;555    {
;;;556      FLASH_Status status = FLASH_COMPLETE;
;;;557      /* Wait for last operation to be completed */
;;;558      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000002  f44f2530          MOV      r5,#0xb0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;559      
;;;560      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d110              BNE      |L4.50|
;;;561      {
;;;562        /* if the previous operation is completed, proceed to erase all pages */
;;;563         FLASH->CR |= CR_MER_Set;
000010  4c08              LDR      r4,|L4.52|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;564         FLASH->CR |= CR_STRT_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;565        
;;;566        /* Wait for last operation to be completed */
;;;567        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;568        
;;;569        /* Disable the MER Bit */
;;;570        FLASH->CR &= CR_MER_Reset;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f64172fb          MOV      r2,#0x1ffb
00002e  4011              ANDS     r1,r1,r2
000030  6121              STR      r1,[r4,#0x10]
                  |L4.50|
;;;571      }    
;;;572      /* Return the Erase Status */
;;;573      return status;
;;;574    }
000032  bd30              POP      {r4,r5,pc}
;;;575    
                          ENDP

                  |L4.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllBank2Pages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllBank2Pages PROC
;;;583      */
;;;584    FLASH_Status FLASH_EraseAllBank2Pages(void)
000000  b530              PUSH     {r4,r5,lr}
;;;585    {
;;;586      FLASH_Status status = FLASH_COMPLETE;
;;;587      /* Wait for last operation to be completed */
;;;588      status = FLASH_WaitForLastBank2Operation(EraseTimeout);
000002  f44f2530          MOV      r5,#0xb0000
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       FLASH_WaitForLastBank2Operation
;;;589      
;;;590      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d110              BNE      |L5.50|
;;;591      {
;;;592        /* if the previous operation is completed, proceed to erase all pages */
;;;593         FLASH->CR2 |= CR_MER_Set;
000010  4c08              LDR      r4,|L5.52|
000012  6d20              LDR      r0,[r4,#0x50]
000014  f0400004          ORR      r0,r0,#4
000018  6520              STR      r0,[r4,#0x50]
;;;594         FLASH->CR2 |= CR_STRT_Set;
00001a  6d20              LDR      r0,[r4,#0x50]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6520              STR      r0,[r4,#0x50]
;;;595        
;;;596        /* Wait for last operation to be completed */
;;;597        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       FLASH_WaitForLastBank2Operation
;;;598    
;;;599        /* Disable the MER Bit */
;;;600        FLASH->CR2 &= CR_MER_Reset;
000028  6d21              LDR      r1,[r4,#0x50]
00002a  f64172fb          MOV      r2,#0x1ffb
00002e  4011              ANDS     r1,r1,r2
000030  6521              STR      r1,[r4,#0x50]
                  |L5.50|
;;;601      }    
;;;602      /* Return the Erase Status */
;;;603      return status;
;;;604    }
000032  bd30              POP      {r4,r5,pc}
;;;605    #endif /* STM32F10X_XL */
                          ENDP

                  |L5.52|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseAllPages||, CODE, READONLY, ALIGN=2

                  FLASH_EraseAllPages PROC
;;;490      */
;;;491    FLASH_Status FLASH_EraseAllPages(void)
000000  b570              PUSH     {r4-r6,lr}
;;;492    {
;;;493      FLASH_Status status = FLASH_COMPLETE;
;;;494    
;;;495    #ifdef STM32F10X_XL
;;;496      /* Wait for last operation to be completed */
;;;497      status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000002  f44f2630          MOV      r6,#0xb0000
000006  4630              MOV      r0,r6
000008  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;498      
;;;499      if(status == FLASH_COMPLETE)
00000c  2804              CMP      r0,#4
00000e  d120              BNE      |L6.82|
;;;500      {
;;;501        /* if the previous operation is completed, proceed to erase all pages */
;;;502         FLASH->CR |= CR_MER_Set;
000010  4c10              LDR      r4,|L6.84|
000012  6920              LDR      r0,[r4,#0x10]
000014  f0400004          ORR      r0,r0,#4
000018  6120              STR      r0,[r4,#0x10]
;;;503         FLASH->CR |= CR_STRT_Set;
00001a  6920              LDR      r0,[r4,#0x10]
00001c  f0400040          ORR      r0,r0,#0x40
000020  6120              STR      r0,[r4,#0x10]
;;;504        
;;;505        /* Wait for last operation to be completed */
;;;506        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       FLASH_WaitForLastBank1Operation
;;;507        
;;;508        /* Disable the MER Bit */
;;;509        FLASH->CR &= CR_MER_Reset;
000028  6921              LDR      r1,[r4,#0x10]
00002a  f64175fb          MOV      r5,#0x1ffb
00002e  4029              ANDS     r1,r1,r5
000030  6121              STR      r1,[r4,#0x10]
;;;510      }    
;;;511      if(status == FLASH_COMPLETE)
000032  2804              CMP      r0,#4
000034  d10d              BNE      |L6.82|
;;;512      {
;;;513        /* if the previous operation is completed, proceed to erase all pages */
;;;514         FLASH->CR2 |= CR_MER_Set;
000036  6d20              LDR      r0,[r4,#0x50]
000038  f0400004          ORR      r0,r0,#4
00003c  6520              STR      r0,[r4,#0x50]
;;;515         FLASH->CR2 |= CR_STRT_Set;
00003e  6d20              LDR      r0,[r4,#0x50]
000040  f0400040          ORR      r0,r0,#0x40
000044  6520              STR      r0,[r4,#0x50]
;;;516        
;;;517        /* Wait for last operation to be completed */
;;;518        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       FLASH_WaitForLastBank2Operation
;;;519        
;;;520        /* Disable the MER Bit */
;;;521        FLASH->CR2 &= CR_MER_Reset;
00004c  6d21              LDR      r1,[r4,#0x50]
00004e  4029              ANDS     r1,r1,r5
000050  6521              STR      r1,[r4,#0x50]
                  |L6.82|
;;;522      }
;;;523    #else
;;;524      /* Wait for last operation to be completed */
;;;525      status = FLASH_WaitForLastOperation(EraseTimeout);
;;;526      if(status == FLASH_COMPLETE)
;;;527      {
;;;528        /* if the previous operation is completed, proceed to erase all pages */
;;;529         FLASH->CR |= CR_MER_Set;
;;;530         FLASH->CR |= CR_STRT_Set;
;;;531        
;;;532        /* Wait for last operation to be completed */
;;;533        status = FLASH_WaitForLastOperation(EraseTimeout);
;;;534    
;;;535        /* Disable the MER Bit */
;;;536        FLASH->CR &= CR_MER_Reset;
;;;537      }
;;;538    #endif /* STM32F10X_XL */
;;;539    
;;;540      /* Return the Erase Status */
;;;541      return status;
;;;542    }
000052  bd70              POP      {r4-r6,pc}
;;;543    
                          ENDP

                  |L6.84|
                          DCD      0x40022000

                          AREA ||i.FLASH_EraseOptionBytes||, CODE, READONLY, ALIGN=2

                  FLASH_EraseOptionBytes PROC
;;;614      */
;;;615    FLASH_Status FLASH_EraseOptionBytes(void)
000000  b570              PUSH     {r4-r6,lr}
;;;616    {
;;;617      uint16_t rdptmp = RDP_Key;
000002  25a5              MOVS     r5,#0xa5
;;;618    
;;;619      FLASH_Status status = FLASH_COMPLETE;
;;;620    
;;;621      /* Get the actual read protection Option Byte value */ 
;;;622      if(FLASH_GetReadOutProtectionStatus() != RESET)
000004  f7fffffe          BL       FLASH_GetReadOutProtectionStatus
000008  b100              CBZ      r0,|L7.12|
;;;623      {
;;;624        rdptmp = 0x00;  
00000a  2500              MOVS     r5,#0
                  |L7.12|
;;;625      }
;;;626    
;;;627      /* Wait for last operation to be completed */
;;;628      status = FLASH_WaitForLastOperation(EraseTimeout);
00000c  f44f2630          MOV      r6,#0xb0000
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       FLASH_WaitForLastOperation
;;;629      if(status == FLASH_COMPLETE)
000016  2804              CMP      r0,#4
000018  d127              BNE      |L7.106|
;;;630      {
;;;631        /* Authorize the small information block programming */
;;;632        FLASH->OPTKEYR = FLASH_KEY1;
00001a  4c15              LDR      r4,|L7.112|
00001c  4813              LDR      r0,|L7.108|
00001e  60a0              STR      r0,[r4,#8]
;;;633        FLASH->OPTKEYR = FLASH_KEY2;
000020  4814              LDR      r0,|L7.116|
000022  60a0              STR      r0,[r4,#8]
;;;634        
;;;635        /* if the previous operation is completed, proceed to erase the option bytes */
;;;636        FLASH->CR |= CR_OPTER_Set;
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400020          ORR      r0,r0,#0x20
00002a  6120              STR      r0,[r4,#0x10]
;;;637        FLASH->CR |= CR_STRT_Set;
00002c  6920              LDR      r0,[r4,#0x10]
00002e  f0400040          ORR      r0,r0,#0x40
000032  6120              STR      r0,[r4,#0x10]
;;;638        /* Wait for last operation to be completed */
;;;639        status = FLASH_WaitForLastOperation(EraseTimeout);
000034  4630              MOV      r0,r6
000036  f7fffffe          BL       FLASH_WaitForLastOperation
;;;640        
;;;641        if(status == FLASH_COMPLETE)
;;;642        {
;;;643          /* if the erase operation is completed, disable the OPTER Bit */
;;;644          FLASH->CR &= CR_OPTER_Reset;
;;;645           
;;;646          /* Enable the Option Bytes Programming operation */
;;;647          FLASH->CR |= CR_OPTPG_Set;
;;;648          /* Restore the last read protection Option Byte value */
;;;649          OB->RDP = (uint16_t)rdptmp; 
;;;650          /* Wait for last operation to be completed */
;;;651          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;652     
;;;653          if(status != FLASH_TIMEOUT)
;;;654          {
;;;655            /* if the program operation is completed, disable the OPTPG Bit */
;;;656            FLASH->CR &= CR_OPTPG_Reset;
00003a  f64176ef          MOV      r6,#0x1fef
00003e  2804              CMP      r0,#4                 ;641
000040  d10e              BNE      |L7.96|
000042  6920              LDR      r0,[r4,#0x10]         ;644
000044  f64171df          MOV      r1,#0x1fdf            ;644
000048  4008              ANDS     r0,r0,r1              ;644
00004a  6120              STR      r0,[r4,#0x10]         ;644
00004c  6920              LDR      r0,[r4,#0x10]         ;647
00004e  f0400010          ORR      r0,r0,#0x10           ;647
000052  6120              STR      r0,[r4,#0x10]         ;647
000054  4808              LDR      r0,|L7.120|
000056  8005              STRH     r5,[r0,#0]            ;649
000058  f44f5000          MOV      r0,#0x2000            ;651
00005c  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L7.96|
;;;657          }
;;;658        }
;;;659        else
;;;660        {
;;;661          if (status != FLASH_TIMEOUT)
000060  2805              CMP      r0,#5
000062  d002              BEQ      |L7.106|
000064  6921              LDR      r1,[r4,#0x10]         ;656
000066  4031              ANDS     r1,r1,r6              ;656
000068  6121              STR      r1,[r4,#0x10]         ;656
                  |L7.106|
;;;662          {
;;;663            /* Disable the OPTPG Bit */
;;;664            FLASH->CR &= CR_OPTPG_Reset;
;;;665          }
;;;666        }  
;;;667      }
;;;668      /* Return the erase status */
;;;669      return status;
;;;670    }
00006a  bd70              POP      {r4-r6,pc}
;;;671    
                          ENDP

                  |L7.108|
                          DCD      0x45670123
                  |L7.112|
                          DCD      0x40022000
                  |L7.116|
                          DCD      0xcdef89ab
                  |L7.120|
                          DCD      0x1ffff800

                          AREA ||i.FLASH_ErasePage||, CODE, READONLY, ALIGN=2

                  FLASH_ErasePage PROC
;;;417      */
;;;418    FLASH_Status FLASH_ErasePage(uint32_t Page_Address)
000000  b5f0              PUSH     {r4-r7,lr}
;;;419    {
000002  4605              MOV      r5,r0
;;;420      FLASH_Status status = FLASH_COMPLETE;
;;;421      /* Check the parameters */
;;;422      assert_param(IS_FLASH_ADDRESS(Page_Address));
;;;423    
;;;424    #ifdef STM32F10X_XL
;;;425      if(Page_Address < FLASH_BANK1_END_ADDRESS)  
000004  4818              LDR      r0,|L8.104|
;;;426      {
;;;427        /* Wait for last operation to be completed */
;;;428        status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;429        if(status == FLASH_COMPLETE)
;;;430        { 
;;;431          /* if the previous operation is completed, proceed to erase the page */
;;;432          FLASH->CR|= CR_PER_Set;
000006  4c19              LDR      r4,|L8.108|
000008  f44f2730          MOV      r7,#0xb0000           ;428
00000c  4285              CMP      r5,r0                 ;425
;;;433          FLASH->AR = Page_Address; 
;;;434          FLASH->CR|= CR_STRT_Set;
;;;435        
;;;436          /* Wait for last operation to be completed */
;;;437          status = FLASH_WaitForLastBank1Operation(EraseTimeout);
;;;438    
;;;439          /* Disable the PER Bit */
;;;440          FLASH->CR &= CR_PER_Reset;
00000e  f64176fd          MOV      r6,#0x1ffd
;;;441        }
;;;442      }
;;;443      else
;;;444      {
;;;445        /* Wait for last operation to be completed */
;;;446        status = FLASH_WaitForLastBank2Operation(EraseTimeout);
000012  4638              MOV      r0,r7
000014  d213              BCS      |L8.62|
000016  f7fffffe          BL       FLASH_WaitForLastBank1Operation
00001a  2804              CMP      r0,#4                 ;429
00001c  d10e              BNE      |L8.60|
00001e  6920              LDR      r0,[r4,#0x10]         ;432
000020  f0400002          ORR      r0,r0,#2              ;432
000024  6120              STR      r0,[r4,#0x10]         ;432
000026  6165              STR      r5,[r4,#0x14]         ;433
000028  6920              LDR      r0,[r4,#0x10]         ;434
00002a  f0400040          ORR      r0,r0,#0x40           ;434
00002e  6120              STR      r0,[r4,#0x10]         ;434
000030  4638              MOV      r0,r7                 ;437
000032  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000036  6921              LDR      r1,[r4,#0x10]         ;440
000038  4031              ANDS     r1,r1,r6              ;440
00003a  6121              STR      r1,[r4,#0x10]         ;440
                  |L8.60|
;;;447        if(status == FLASH_COMPLETE)
;;;448        { 
;;;449          /* if the previous operation is completed, proceed to erase the page */
;;;450          FLASH->CR2|= CR_PER_Set;
;;;451          FLASH->AR2 = Page_Address; 
;;;452          FLASH->CR2|= CR_STRT_Set;
;;;453        
;;;454          /* Wait for last operation to be completed */
;;;455          status = FLASH_WaitForLastBank2Operation(EraseTimeout);
;;;456          
;;;457          /* Disable the PER Bit */
;;;458          FLASH->CR2 &= CR_PER_Reset;
;;;459        }
;;;460      }
;;;461    #else
;;;462      /* Wait for last operation to be completed */
;;;463      status = FLASH_WaitForLastOperation(EraseTimeout);
;;;464      
;;;465      if(status == FLASH_COMPLETE)
;;;466      { 
;;;467        /* if the previous operation is completed, proceed to erase the page */
;;;468        FLASH->CR|= CR_PER_Set;
;;;469        FLASH->AR = Page_Address; 
;;;470        FLASH->CR|= CR_STRT_Set;
;;;471        
;;;472        /* Wait for last operation to be completed */
;;;473        status = FLASH_WaitForLastOperation(EraseTimeout);
;;;474        
;;;475        /* Disable the PER Bit */
;;;476        FLASH->CR &= CR_PER_Reset;
;;;477      }
;;;478    #endif /* STM32F10X_XL */
;;;479    
;;;480      /* Return the Erase Status */
;;;481      return status;
;;;482    }
00003c  bdf0              POP      {r4-r7,pc}
                  |L8.62|
00003e  f7fffffe          BL       FLASH_WaitForLastBank2Operation
000042  2804              CMP      r0,#4                 ;447
000044  d1fa              BNE      |L8.60|
000046  6d20              LDR      r0,[r4,#0x50]         ;450
000048  f0400002          ORR      r0,r0,#2              ;450
00004c  6520              STR      r0,[r4,#0x50]         ;450
00004e  6565              STR      r5,[r4,#0x54]         ;451
000050  6d20              LDR      r0,[r4,#0x50]         ;452
000052  f0400040          ORR      r0,r0,#0x40           ;452
000056  6520              STR      r0,[r4,#0x50]         ;452
000058  4638              MOV      r0,r7                 ;455
00005a  f7fffffe          BL       FLASH_WaitForLastBank2Operation
00005e  6d21              LDR      r1,[r4,#0x50]         ;458
000060  4031              ANDS     r1,r1,r6              ;458
000062  6521              STR      r1,[r4,#0x50]         ;458
000064  bdf0              POP      {r4-r7,pc}
;;;483    
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      0x0807ffff
                  |L8.108|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank1Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank1Status PROC
;;;1513     */
;;;1514   FLASH_Status FLASH_GetBank1Status(void)
000000  4908              LDR      r1,|L9.36|
;;;1515   {
;;;1516     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1517     
;;;1518     if((FLASH->SR & FLASH_FLAG_BANK1_BSY) == FLASH_FLAG_BSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L9.14|
;;;1519     {
;;;1520       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1521     }
;;;1522     else 
;;;1523     {  
;;;1524       if((FLASH->SR & FLASH_FLAG_BANK1_PGERR) != 0)
;;;1525       { 
;;;1526         flashstatus = FLASH_ERROR_PG;
;;;1527       }
;;;1528       else 
;;;1529       {
;;;1530         if((FLASH->SR & FLASH_FLAG_BANK1_WRPRTERR) != 0 )
;;;1531         {
;;;1532           flashstatus = FLASH_ERROR_WRP;
;;;1533         }
;;;1534         else
;;;1535         {
;;;1536           flashstatus = FLASH_COMPLETE;
;;;1537         }
;;;1538       }
;;;1539     }
;;;1540     /* Return the Flash Status */
;;;1541     return flashstatus;
;;;1542   }
00000c  4770              BX       lr
                  |L9.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1524
000010  0752              LSLS     r2,r2,#29             ;1524
000012  d501              BPL      |L9.24|
000014  2002              MOVS     r0,#2                 ;1526
                  |L9.22|
000016  4770              BX       lr
                  |L9.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1530
00001a  06c9              LSLS     r1,r1,#27             ;1530
00001c  d5fb              BPL      |L9.22|
00001e  2003              MOVS     r0,#3                 ;1532
000020  4770              BX       lr
;;;1543   
                          ENDP

000022  0000              DCW      0x0000
                  |L9.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetBank2Status||, CODE, READONLY, ALIGN=2

                  FLASH_GetBank2Status PROC
;;;1551     */
;;;1552   FLASH_Status FLASH_GetBank2Status(void)
000000  4908              LDR      r1,|L10.36|
;;;1553   {
;;;1554     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1555     
;;;1556     if((FLASH->SR2 & (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) 
000004  6cca              LDR      r2,[r1,#0x4c]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L10.14|
;;;1557     {
;;;1558       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1559     }
;;;1560     else 
;;;1561     {  
;;;1562       if((FLASH->SR2 & (FLASH_FLAG_BANK2_PGERR & 0x7FFFFFFF)) != 0)
;;;1563       { 
;;;1564         flashstatus = FLASH_ERROR_PG;
;;;1565       }
;;;1566       else 
;;;1567       {
;;;1568         if((FLASH->SR2 & (FLASH_FLAG_BANK2_WRPRTERR & 0x7FFFFFFF)) != 0 )
;;;1569         {
;;;1570           flashstatus = FLASH_ERROR_WRP;
;;;1571         }
;;;1572         else
;;;1573         {
;;;1574           flashstatus = FLASH_COMPLETE;
;;;1575         }
;;;1576       }
;;;1577     }
;;;1578     /* Return the Flash Status */
;;;1579     return flashstatus;
;;;1580   }
00000c  4770              BX       lr
                  |L10.14|
00000e  6cca              LDR      r2,[r1,#0x4c]         ;1562
000010  0752              LSLS     r2,r2,#29             ;1562
000012  d501              BPL      |L10.24|
000014  2002              MOVS     r0,#2                 ;1564
                  |L10.22|
000016  4770              BX       lr
                  |L10.24|
000018  6cc9              LDR      r1,[r1,#0x4c]         ;1568
00001a  06c9              LSLS     r1,r1,#27             ;1568
00001c  d5fb              BPL      |L10.22|
00001e  2003              MOVS     r0,#3                 ;1570
000020  4770              BX       lr
;;;1581   #endif /* STM32F10X_XL */
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetFlagStatus PROC
;;;1355     */
;;;1356   FlagStatus FLASH_GetFlagStatus(uint32_t FLASH_FLAG)
000000  4601              MOV      r1,r0
;;;1357   {
;;;1358     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1359   
;;;1360   #ifdef STM32F10X_XL
;;;1361     /* Check the parameters */
;;;1362     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1363     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1364     {
;;;1365       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
000004  4a07              LDR      r2,|L11.36|
000006  2901              CMP      r1,#1                 ;1363
000008  d003              BEQ      |L11.18|
;;;1366       {
;;;1367         bitstatus = SET;
;;;1368       }
;;;1369       else
;;;1370       {
;;;1371         bitstatus = RESET;
;;;1372       }
;;;1373     }
;;;1374     else
;;;1375     {
;;;1376       if((FLASH_FLAG & 0x80000000) != 0x0)
00000a  2900              CMP      r1,#0
00000c  da06              BGE      |L11.28|
;;;1377       {
;;;1378         if((FLASH->SR2 & FLASH_FLAG) != (uint32_t)RESET)
00000e  6cd2              LDR      r2,[r2,#0x4c]
000010  e005              B        |L11.30|
                  |L11.18|
000012  69d1              LDR      r1,[r2,#0x1c]         ;1365
000014  07c9              LSLS     r1,r1,#31             ;1365
000016  d000              BEQ      |L11.26|
                  |L11.24|
000018  2001              MOVS     r0,#1                 ;1367
                  |L11.26|
;;;1379         {
;;;1380           bitstatus = SET;
;;;1381         }
;;;1382         else
;;;1383         {
;;;1384           bitstatus = RESET;
;;;1385         }
;;;1386       }
;;;1387       else
;;;1388       {
;;;1389         if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1390         {
;;;1391           bitstatus = SET;
;;;1392         }
;;;1393         else
;;;1394         {
;;;1395           bitstatus = RESET;
;;;1396         }
;;;1397       }
;;;1398     }
;;;1399   #else
;;;1400     /* Check the parameters */
;;;1401     assert_param(IS_FLASH_GET_FLAG(FLASH_FLAG)) ;
;;;1402     if(FLASH_FLAG == FLASH_FLAG_OPTERR) 
;;;1403     {
;;;1404       if((FLASH->OBR & FLASH_FLAG_OPTERR) != (uint32_t)RESET)
;;;1405       {
;;;1406         bitstatus = SET;
;;;1407       }
;;;1408       else
;;;1409       {
;;;1410         bitstatus = RESET;
;;;1411       }
;;;1412     }
;;;1413     else
;;;1414     {
;;;1415      if((FLASH->SR & FLASH_FLAG) != (uint32_t)RESET)
;;;1416       {
;;;1417         bitstatus = SET;
;;;1418       }
;;;1419       else
;;;1420       {
;;;1421         bitstatus = RESET;
;;;1422       }
;;;1423     }
;;;1424   #endif /* STM32F10X_XL */
;;;1425   
;;;1426     /* Return the new state of FLASH_FLAG (SET or RESET) */
;;;1427     return bitstatus;
;;;1428   }
00001a  4770              BX       lr
                  |L11.28|
00001c  68d2              LDR      r2,[r2,#0xc]          ;1389
                  |L11.30|
00001e  420a              TST      r2,r1                 ;1378
000020  d1fa              BNE      |L11.24|
000022  4770              BX       lr
;;;1429   
                          ENDP

                  |L11.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetPrefetchBufferStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetPrefetchBufferStatus PROC
;;;1258     */
;;;1259   FlagStatus FLASH_GetPrefetchBufferStatus(void)
000000  4903              LDR      r1,|L12.16|
;;;1260   {
;;;1261     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1262     
;;;1263     if ((FLASH->ACR & ACR_PRFTBS_Mask) != (uint32_t)RESET)
000004  6809              LDR      r1,[r1,#0]
000006  0689              LSLS     r1,r1,#26
000008  d500              BPL      |L12.12|
;;;1264     {
;;;1265       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L12.12|
;;;1266     }
;;;1267     else
;;;1268     {
;;;1269       bitstatus = RESET;
;;;1270     }
;;;1271     /* Return the new state of FLASH Prefetch Buffer Status (SET or RESET) */
;;;1272     return bitstatus; 
;;;1273   }
00000c  4770              BX       lr
;;;1274   
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetReadOutProtectionStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetReadOutProtectionStatus PROC
;;;1238     */
;;;1239   FlagStatus FLASH_GetReadOutProtectionStatus(void)
000000  4903              LDR      r1,|L13.16|
;;;1240   {
;;;1241     FlagStatus readoutstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1242     if ((FLASH->OBR & RDPRT_Mask) != (uint32_t)RESET)
000004  69c9              LDR      r1,[r1,#0x1c]
000006  0789              LSLS     r1,r1,#30
000008  d500              BPL      |L13.12|
;;;1243     {
;;;1244       readoutstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L13.12|
;;;1245     }
;;;1246     else
;;;1247     {
;;;1248       readoutstatus = RESET;
;;;1249     }
;;;1250     return readoutstatus;
;;;1251   }
00000c  4770              BX       lr
;;;1252   
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetStatus||, CODE, READONLY, ALIGN=2

                  FLASH_GetStatus PROC
;;;1475     */
;;;1476   FLASH_Status FLASH_GetStatus(void)
000000  4908              LDR      r1,|L14.36|
;;;1477   {
;;;1478     FLASH_Status flashstatus = FLASH_COMPLETE;
000002  2004              MOVS     r0,#4
;;;1479     
;;;1480     if((FLASH->SR & FLASH_FLAG_BSY) == FLASH_FLAG_BSY) 
000004  68ca              LDR      r2,[r1,#0xc]
000006  07d2              LSLS     r2,r2,#31
000008  d001              BEQ      |L14.14|
;;;1481     {
;;;1482       flashstatus = FLASH_BUSY;
00000a  2001              MOVS     r0,#1
;;;1483     }
;;;1484     else 
;;;1485     {  
;;;1486       if((FLASH->SR & FLASH_FLAG_PGERR) != 0)
;;;1487       { 
;;;1488         flashstatus = FLASH_ERROR_PG;
;;;1489       }
;;;1490       else 
;;;1491       {
;;;1492         if((FLASH->SR & FLASH_FLAG_WRPRTERR) != 0 )
;;;1493         {
;;;1494           flashstatus = FLASH_ERROR_WRP;
;;;1495         }
;;;1496         else
;;;1497         {
;;;1498           flashstatus = FLASH_COMPLETE;
;;;1499         }
;;;1500       }
;;;1501     }
;;;1502     /* Return the Flash Status */
;;;1503     return flashstatus;
;;;1504   }
00000c  4770              BX       lr
                  |L14.14|
00000e  68ca              LDR      r2,[r1,#0xc]          ;1486
000010  0752              LSLS     r2,r2,#29             ;1486
000012  d501              BPL      |L14.24|
000014  2002              MOVS     r0,#2                 ;1488
                  |L14.22|
000016  4770              BX       lr
                  |L14.24|
000018  68c9              LDR      r1,[r1,#0xc]          ;1492
00001a  06c9              LSLS     r1,r1,#27             ;1492
00001c  d5fb              BPL      |L14.22|
00001e  2003              MOVS     r0,#3                 ;1494
000020  4770              BX       lr
;;;1505   
                          ENDP

000022  0000              DCW      0x0000
                  |L14.36|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetUserOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetUserOptionByte PROC
;;;1214     */
;;;1215   uint32_t FLASH_GetUserOptionByte(void)
000000  4801              LDR      r0,|L15.8|
;;;1216   {
;;;1217     /* Return the User Option Byte */
;;;1218     return (uint32_t)(FLASH->OBR >> 2);
000002  69c0              LDR      r0,[r0,#0x1c]
000004  0880              LSRS     r0,r0,#2
;;;1219   }
000006  4770              BX       lr
;;;1220   
                          ENDP

                  |L15.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_GetWriteProtectionOptionByte||, CODE, READONLY, ALIGN=2

                  FLASH_GetWriteProtectionOptionByte PROC
;;;1226     */
;;;1227   uint32_t FLASH_GetWriteProtectionOptionByte(void)
000000  4801              LDR      r0,|L16.8|
;;;1228   {
;;;1229     /* Return the Falsh write protection Register value */
;;;1230     return (uint32_t)(FLASH->WRPR);
000002  6a00              LDR      r0,[r0,#0x20]
;;;1231   }
000004  4770              BX       lr
;;;1232   
                          ENDP

000006  0000              DCW      0x0000
                  |L16.8|
                          DCD      0x40022000

                          AREA ||i.FLASH_HalfCycleAccessCmd||, CODE, READONLY, ALIGN=2

                  FLASH_HalfCycleAccessCmd PROC
;;;279      */
;;;280    void FLASH_HalfCycleAccessCmd(uint32_t FLASH_HalfCycleAccess)
000000  4904              LDR      r1,|L17.20|
;;;281    {
;;;282      /* Check the parameters */
;;;283      assert_param(IS_FLASH_HALFCYCLEACCESS_STATE(FLASH_HalfCycleAccess));
;;;284      
;;;285      /* Enable or disable the Half cycle access */
;;;286      FLASH->ACR &= ACR_HLFCYA_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220208          BIC      r2,r2,#8
000008  600a              STR      r2,[r1,#0]
;;;287      FLASH->ACR |= FLASH_HalfCycleAccess;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;288    }
000010  4770              BX       lr
;;;289    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ITConfig||, CODE, READONLY, ALIGN=2

                  FLASH_ITConfig PROC
;;;1288     */
;;;1289   void FLASH_ITConfig(uint32_t FLASH_IT, FunctionalState NewState)
000000  4a0a              LDR      r2,|L18.44|
;;;1290   {
;;;1291   #ifdef STM32F10X_XL
;;;1292     /* Check the parameters */
;;;1293     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1294     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1295   
;;;1296     if((FLASH_IT & 0x80000000) != 0x0)
000002  2800              CMP      r0,#0
000004  da09              BGE      |L18.26|
;;;1297     {
;;;1298       if(NewState != DISABLE)
000006  2900              CMP      r1,#0
;;;1299       {
;;;1300         /* Enable the interrupt sources */
;;;1301         FLASH->CR2 |= (FLASH_IT & 0x7FFFFFFF);
;;;1302       }
;;;1303       else
;;;1304       {
;;;1305         /* Disable the interrupt sources */
;;;1306         FLASH->CR2 &= ~(uint32_t)(FLASH_IT & 0x7FFFFFFF);
000008  6d11              LDR      r1,[r2,#0x50]
00000a  f0204000          BIC      r0,r0,#0x80000000     ;1301
00000e  d001              BEQ      |L18.20|
000010  4301              ORRS     r1,r1,r0              ;1301
000012  e000              B        |L18.22|
                  |L18.20|
000014  4381              BICS     r1,r1,r0
                  |L18.22|
000016  6511              STR      r1,[r2,#0x50]
;;;1307       }
;;;1308     }
;;;1309     else
;;;1310     {
;;;1311       if(NewState != DISABLE)
;;;1312       {
;;;1313         /* Enable the interrupt sources */
;;;1314         FLASH->CR |= FLASH_IT;
;;;1315       }
;;;1316       else
;;;1317       {
;;;1318         /* Disable the interrupt sources */
;;;1319         FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1320       }
;;;1321     }
;;;1322   #else
;;;1323     /* Check the parameters */
;;;1324     assert_param(IS_FLASH_IT(FLASH_IT)); 
;;;1325     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1326   
;;;1327     if(NewState != DISABLE)
;;;1328     {
;;;1329       /* Enable the interrupt sources */
;;;1330       FLASH->CR |= FLASH_IT;
;;;1331     }
;;;1332     else
;;;1333     {
;;;1334       /* Disable the interrupt sources */
;;;1335       FLASH->CR &= ~(uint32_t)FLASH_IT;
;;;1336     }
;;;1337   #endif /* STM32F10X_XL */
;;;1338   }
000018  4770              BX       lr
                  |L18.26|
00001a  2900              CMP      r1,#0                 ;1311
00001c  6911              LDR      r1,[r2,#0x10]         ;1319
00001e  d001              BEQ      |L18.36|
000020  4301              ORRS     r1,r1,r0              ;1314
000022  e000              B        |L18.38|
                  |L18.36|
000024  4381              BICS     r1,r1,r0              ;1319
                  |L18.38|
000026  6111              STR      r1,[r2,#0x10]         ;1319
000028  4770              BX       lr
;;;1339   
                          ENDP

00002a  0000              DCW      0x0000
                  |L18.44|
                          DCD      0x40022000

                          AREA ||i.FLASH_Lock||, CODE, READONLY, ALIGN=2

                  FLASH_Lock PROC
;;;370      */
;;;371    void FLASH_Lock(void)
000000  4804              LDR      r0,|L19.20|
;;;372    {
;;;373      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;374      FLASH->CR |= CR_LOCK_Set;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;375    
;;;376    #ifdef STM32F10X_XL
;;;377      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;378      FLASH->CR2 |= CR_LOCK_Set;
00000a  6d01              LDR      r1,[r0,#0x50]
00000c  f0410180          ORR      r1,r1,#0x80
000010  6501              STR      r1,[r0,#0x50]
;;;379    #endif /* STM32F10X_XL */
;;;380    }
000012  4770              BX       lr
;;;381    
                          ENDP

                  |L19.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank1 PROC
;;;390      */
;;;391    void FLASH_LockBank1(void)
000000  4802              LDR      r0,|L20.12|
;;;392    {
;;;393      /* Set the Lock Bit to lock the FPEC and the CR of  Bank1 */
;;;394      FLASH->CR |= CR_LOCK_Set;
000002  6901              LDR      r1,[r0,#0x10]
000004  f0410180          ORR      r1,r1,#0x80
000008  6101              STR      r1,[r0,#0x10]
;;;395    }
00000a  4770              BX       lr
;;;396    
                          ENDP

                  |L20.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_LockBank2||, CODE, READONLY, ALIGN=2

                  FLASH_LockBank2 PROC
;;;403      */
;;;404    void FLASH_LockBank2(void)
000000  4802              LDR      r0,|L21.12|
;;;405    {
;;;406      /* Set the Lock Bit to lock the FPEC and the CR of  Bank2 */
;;;407      FLASH->CR2 |= CR_LOCK_Set;
000002  6d01              LDR      r1,[r0,#0x50]
000004  f0410180          ORR      r1,r1,#0x80
000008  6501              STR      r1,[r0,#0x50]
;;;408    }
00000a  4770              BX       lr
;;;409    #endif /* STM32F10X_XL */
                          ENDP

                  |L21.12|
                          DCD      0x40022000

                          AREA ||i.FLASH_PrefetchBufferCmd||, CODE, READONLY, ALIGN=2

                  FLASH_PrefetchBufferCmd PROC
;;;298      */
;;;299    void FLASH_PrefetchBufferCmd(uint32_t FLASH_PrefetchBuffer)
000000  4904              LDR      r1,|L22.20|
;;;300    {
;;;301      /* Check the parameters */
;;;302      assert_param(IS_FLASH_PREFETCHBUFFER_STATE(FLASH_PrefetchBuffer));
;;;303      
;;;304      /* Enable or disable the Prefetch Buffer */
;;;305      FLASH->ACR &= ACR_PRFTBE_Mask;
000002  680a              LDR      r2,[r1,#0]
000004  f0220210          BIC      r2,r2,#0x10
000008  600a              STR      r2,[r1,#0]
;;;306      FLASH->ACR |= FLASH_PrefetchBuffer;
00000a  680a              LDR      r2,[r1,#0]
00000c  4302              ORRS     r2,r2,r0
00000e  600a              STR      r2,[r1,#0]
;;;307    }
000010  4770              BX       lr
;;;308    
                          ENDP

000012  0000              DCW      0x0000
                  |L22.20|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramHalfWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramHalfWord PROC
;;;856      */
;;;857    FLASH_Status FLASH_ProgramHalfWord(uint32_t Address, uint16_t Data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;858    {
000004  4604              MOV      r4,r0
;;;859      FLASH_Status status = FLASH_COMPLETE;
;;;860      /* Check the parameters */
;;;861      assert_param(IS_FLASH_ADDRESS(Address));
;;;862    
;;;863    #ifdef STM32F10X_XL
;;;864      /* Wait for last operation to be completed */
;;;865      status = FLASH_WaitForLastOperation(ProgramTimeout);
000006  f44f5800          MOV      r8,#0x2000
00000a  460e              MOV      r6,r1                 ;858
00000c  4640              MOV      r0,r8
00000e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;866      
;;;867      if(Address < FLASH_BANK1_END_ADDRESS)
000012  4911              LDR      r1,|L23.88|
;;;868      {
;;;869        if(status == FLASH_COMPLETE)
;;;870        {
;;;871          /* if the previous operation is completed, proceed to program the new data */
;;;872          FLASH->CR |= CR_PG_Set;
000014  4d11              LDR      r5,|L23.92|
;;;873      
;;;874          *(__IO uint16_t*)Address = Data;
;;;875          /* Wait for last operation to be completed */
;;;876          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;877    
;;;878          /* Disable the PG Bit */
;;;879          FLASH->CR &= CR_PG_Reset;
000016  f64177fe          MOV      r7,#0x1ffe
00001a  428c              CMP      r4,r1                 ;867
00001c  d20e              BCS      |L23.60|
00001e  2804              CMP      r0,#4                 ;869
000020  d10a              BNE      |L23.56|
000022  6928              LDR      r0,[r5,#0x10]         ;872
000024  f0400001          ORR      r0,r0,#1              ;872
000028  6128              STR      r0,[r5,#0x10]         ;872
00002a  8026              STRH     r6,[r4,#0]            ;874
00002c  4640              MOV      r0,r8                 ;876
00002e  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000032  6929              LDR      r1,[r5,#0x10]
000034  4039              ANDS     r1,r1,r7
000036  6129              STR      r1,[r5,#0x10]
                  |L23.56|
;;;880        }
;;;881      }
;;;882      else
;;;883      {
;;;884        if(status == FLASH_COMPLETE)
;;;885        {
;;;886          /* if the previous operation is completed, proceed to program the new data */
;;;887          FLASH->CR2 |= CR_PG_Set;
;;;888      
;;;889          *(__IO uint16_t*)Address = Data;
;;;890          /* Wait for last operation to be completed */
;;;891          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;892    
;;;893          /* Disable the PG Bit */
;;;894          FLASH->CR2 &= CR_PG_Reset;
;;;895        }
;;;896      }
;;;897    #else
;;;898      /* Wait for last operation to be completed */
;;;899      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;900      
;;;901      if(status == FLASH_COMPLETE)
;;;902      {
;;;903        /* if the previous operation is completed, proceed to program the new data */
;;;904        FLASH->CR |= CR_PG_Set;
;;;905      
;;;906        *(__IO uint16_t*)Address = Data;
;;;907        /* Wait for last operation to be completed */
;;;908        status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;909        
;;;910        /* Disable the PG Bit */
;;;911        FLASH->CR &= CR_PG_Reset;
;;;912      } 
;;;913    #endif  /* STM32F10X_XL */
;;;914      
;;;915      /* Return the Program Status */
;;;916      return status;
;;;917    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L23.60|
00003c  2804              CMP      r0,#4                 ;884
00003e  d1fb              BNE      |L23.56|
000040  6d28              LDR      r0,[r5,#0x50]         ;887
000042  f0400001          ORR      r0,r0,#1              ;887
000046  6528              STR      r0,[r5,#0x50]         ;887
000048  8026              STRH     r6,[r4,#0]            ;889
00004a  4640              MOV      r0,r8                 ;891
00004c  f7fffffe          BL       FLASH_WaitForLastBank2Operation
000050  6d29              LDR      r1,[r5,#0x50]         ;894
000052  4039              ANDS     r1,r1,r7              ;894
000054  6529              STR      r1,[r5,#0x50]         ;894
000056  e7ef              B        |L23.56|
;;;918    
                          ENDP

                  |L23.88|
                          DCD      0x0807ffff
                  |L23.92|
                          DCD      0x40022000

                          AREA ||i.FLASH_ProgramOptionByteData||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramOptionByteData PROC
;;;927      */
;;;928    FLASH_Status FLASH_ProgramOptionByteData(uint32_t Address, uint8_t Data)
000000  b5f0              PUSH     {r4-r7,lr}
;;;929    {
000002  4605              MOV      r5,r0
;;;930      FLASH_Status status = FLASH_COMPLETE;
;;;931      /* Check the parameters */
;;;932      assert_param(IS_OB_DATA_ADDRESS(Address));
;;;933      status = FLASH_WaitForLastOperation(ProgramTimeout);
000004  f44f5700          MOV      r7,#0x2000
000008  460e              MOV      r6,r1                 ;929
00000a  4638              MOV      r0,r7
00000c  f7fffffe          BL       FLASH_WaitForLastOperation
;;;934    
;;;935      if(status == FLASH_COMPLETE)
000010  2804              CMP      r0,#4
000012  d113              BNE      |L24.60|
;;;936      {
;;;937        /* Authorize the small information block programming */
;;;938        FLASH->OPTKEYR = FLASH_KEY1;
000014  4c0b              LDR      r4,|L24.68|
000016  480a              LDR      r0,|L24.64|
000018  60a0              STR      r0,[r4,#8]
;;;939        FLASH->OPTKEYR = FLASH_KEY2;
00001a  480b              LDR      r0,|L24.72|
00001c  60a0              STR      r0,[r4,#8]
;;;940        /* Enables the Option Bytes Programming operation */
;;;941        FLASH->CR |= CR_OPTPG_Set; 
00001e  6920              LDR      r0,[r4,#0x10]
000020  f0400010          ORR      r0,r0,#0x10
000024  6120              STR      r0,[r4,#0x10]
;;;942        *(__IO uint16_t*)Address = Data;
000026  802e              STRH     r6,[r5,#0]
;;;943        
;;;944        /* Wait for last operation to be completed */
;;;945        status = FLASH_WaitForLastOperation(ProgramTimeout);
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;946        if(status != FLASH_TIMEOUT)
00002e  2805              CMP      r0,#5
000030  d004              BEQ      |L24.60|
;;;947        {
;;;948          /* if the program operation is completed, disable the OPTPG Bit */
;;;949          FLASH->CR &= CR_OPTPG_Reset;
000032  6921              LDR      r1,[r4,#0x10]
000034  f64172ef          MOV      r2,#0x1fef
000038  4011              ANDS     r1,r1,r2
00003a  6121              STR      r1,[r4,#0x10]
                  |L24.60|
;;;950        }
;;;951      }
;;;952      /* Return the Option Byte Data Program Status */
;;;953      return status;
;;;954    }
00003c  bdf0              POP      {r4-r7,pc}
;;;955    
                          ENDP

00003e  0000              DCW      0x0000
                  |L24.64|
                          DCD      0x45670123
                  |L24.68|
                          DCD      0x40022000
                  |L24.72|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_ProgramWord||, CODE, READONLY, ALIGN=2

                  FLASH_ProgramWord PROC
;;;679      */
;;;680    FLASH_Status FLASH_ProgramWord(uint32_t Address, uint32_t Data)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;681    {
000004  4604              MOV      r4,r0
;;;682      FLASH_Status status = FLASH_COMPLETE;
;;;683      __IO uint32_t tmp = 0;
;;;684    
;;;685      /* Check the parameters */
;;;686      assert_param(IS_FLASH_ADDRESS(Address));
;;;687    
;;;688    #ifdef STM32F10X_XL
;;;689      if(Address < FLASH_BANK1_END_ADDRESS - 2)
000006  4a37              LDR      r2,|L25.228|
;;;690      { 
;;;691        /* Wait for last operation to be completed */
;;;692        status = FLASH_WaitForLastBank1Operation(ProgramTimeout); 
;;;693        if(status == FLASH_COMPLETE)
;;;694        {
;;;695          /* if the previous operation is completed, proceed to program the new first 
;;;696            half word */
;;;697          FLASH->CR |= CR_PG_Set;
;;;698      
;;;699          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;700          /* Wait for last operation to be completed */
;;;701          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;702     
;;;703          if(status == FLASH_COMPLETE)
;;;704          {
;;;705            /* if the previous operation is completed, proceed to program the new second 
;;;706            half word */
;;;707            tmp = Address + 2;
;;;708    
;;;709            *(__IO uint16_t*) tmp = Data >> 16;
;;;710        
;;;711            /* Wait for last operation to be completed */
;;;712            status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;713            
;;;714            /* Disable the PG Bit */
;;;715            FLASH->CR &= CR_PG_Reset;
000008  f64175fe          MOV      r5,#0x1ffe
00000c  0c0f              LSRS     r7,r1,#16             ;709
00000e  1ca8              ADDS     r0,r5,#2              ;692
000010  f8df80d4          LDR      r8,|L25.232|
000014  b28e              UXTH     r6,r1                 ;699
000016  4294              CMP      r4,r2                 ;689
000018  d21c              BCS      |L25.84|
00001a  4681              MOV      r9,r0                 ;692
00001c  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000020  2804              CMP      r0,#4                 ;693
000022  d115              BNE      |L25.80|
000024  f8d81010          LDR      r1,[r8,#0x10]         ;697
000028  f0410101          ORR      r1,r1,#1              ;697
00002c  f8c81010          STR      r1,[r8,#0x10]         ;697
000030  8026              STRH     r6,[r4,#0]            ;699
000032  464e              MOV      r6,r9                 ;701
000034  4648              MOV      r0,r9                 ;701
000036  f7fffffe          BL       FLASH_WaitForLastOperation
00003a  2804              CMP      r0,#4                 ;703
00003c  d103              BNE      |L25.70|
00003e  8067              STRH     r7,[r4,#2]            ;709
000040  4630              MOV      r0,r6                 ;712
000042  f7fffffe          BL       FLASH_WaitForLastOperation
                  |L25.70|
;;;716          }
;;;717          else
;;;718          {
;;;719            /* Disable the PG Bit */
;;;720            FLASH->CR &= CR_PG_Reset;
000046  f8d82010          LDR      r2,[r8,#0x10]
00004a  402a              ANDS     r2,r2,r5
00004c  f8c82010          STR      r2,[r8,#0x10]
                  |L25.80|
;;;721           }
;;;722        }
;;;723      }
;;;724      else if(Address == (FLASH_BANK1_END_ADDRESS - 1))
;;;725      {
;;;726        /* Wait for last operation to be completed */
;;;727        status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;728    
;;;729        if(status == FLASH_COMPLETE)
;;;730        {
;;;731          /* if the previous operation is completed, proceed to program the new first 
;;;732            half word */
;;;733          FLASH->CR |= CR_PG_Set;
;;;734      
;;;735          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;736    
;;;737          /* Wait for last operation to be completed */
;;;738          status = FLASH_WaitForLastBank1Operation(ProgramTimeout);
;;;739          
;;;740    	  /* Disable the PG Bit */
;;;741          FLASH->CR &= CR_PG_Reset;
;;;742        }
;;;743        else
;;;744        {
;;;745          /* Disable the PG Bit */
;;;746          FLASH->CR &= CR_PG_Reset;
;;;747        }
;;;748    
;;;749        /* Wait for last operation to be completed */
;;;750        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;751    
;;;752        if(status == FLASH_COMPLETE)
;;;753        {
;;;754          /* if the previous operation is completed, proceed to program the new second 
;;;755          half word */
;;;756          FLASH->CR2 |= CR_PG_Set;
;;;757          tmp = Address + 2;
;;;758    
;;;759          *(__IO uint16_t*) tmp = Data >> 16;
;;;760        
;;;761          /* Wait for last operation to be completed */
;;;762          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;763            
;;;764          /* Disable the PG Bit */
;;;765          FLASH->CR2 &= CR_PG_Reset;
;;;766        }
;;;767        else
;;;768        {
;;;769          /* Disable the PG Bit */
;;;770          FLASH->CR2 &= CR_PG_Reset;
;;;771        }
;;;772      }
;;;773      else
;;;774      {
;;;775        /* Wait for last operation to be completed */
;;;776        status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;777    
;;;778        if(status == FLASH_COMPLETE)
;;;779        {
;;;780          /* if the previous operation is completed, proceed to program the new first 
;;;781            half word */
;;;782          FLASH->CR2 |= CR_PG_Set;
;;;783      
;;;784          *(__IO uint16_t*)Address = (uint16_t)Data;
;;;785          /* Wait for last operation to be completed */
;;;786          status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;787     
;;;788          if(status == FLASH_COMPLETE)
;;;789          {
;;;790            /* if the previous operation is completed, proceed to program the new second 
;;;791            half word */
;;;792            tmp = Address + 2;
;;;793    
;;;794            *(__IO uint16_t*) tmp = Data >> 16;
;;;795        
;;;796            /* Wait for last operation to be completed */
;;;797            status = FLASH_WaitForLastBank2Operation(ProgramTimeout);
;;;798            
;;;799            /* Disable the PG Bit */
;;;800            FLASH->CR2 &= CR_PG_Reset;
;;;801          }
;;;802          else
;;;803          {
;;;804            /* Disable the PG Bit */
;;;805            FLASH->CR2 &= CR_PG_Reset;
;;;806          }
;;;807        }
;;;808      }
;;;809    #else
;;;810      /* Wait for last operation to be completed */
;;;811      status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;812      
;;;813      if(status == FLASH_COMPLETE)
;;;814      {
;;;815        /* if the previous operation is completed, proceed to program the new first 
;;;816        half word */
;;;817        FLASH->CR |= CR_PG_Set;
;;;818      
;;;819        *(__IO uint16_t*)Address = (uint16_t)Data;
;;;820        /* Wait for last operation to be completed */
;;;821        status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;822     
;;;823        if(status == FLASH_COMPLETE)
;;;824        {
;;;825          /* if the previous operation is completed, proceed to program the new second 
;;;826          half word */
;;;827          tmp = Address + 2;
;;;828    
;;;829          *(__IO uint16_t*) tmp = Data >> 16;
;;;830        
;;;831          /* Wait for last operation to be completed */
;;;832          status = FLASH_WaitForLastOperation(ProgramTimeout);
;;;833            
;;;834          /* Disable the PG Bit */
;;;835          FLASH->CR &= CR_PG_Reset;
;;;836        }
;;;837        else
;;;838        {
;;;839          /* Disable the PG Bit */
;;;840          FLASH->CR &= CR_PG_Reset;
;;;841        }
;;;842      }         
;;;843    #endif /* STM32F10X_XL */
;;;844       
;;;845      /* Return the Program Status */
;;;846      return status;
;;;847    }
000050  e8bd83f0          POP      {r4-r9,pc}
                  |L25.84|
000054  4923              LDR      r1,|L25.228|
000056  4681              MOV      r9,r0                 ;776
000058  1c49              ADDS     r1,r1,#1              ;724
00005a  428c              CMP      r4,r1                 ;724
00005c  d12c              BNE      |L25.184|
00005e  f7fffffe          BL       FLASH_WaitForLastBank1Operation
000062  2804              CMP      r0,#4                 ;729
000064  d109              BNE      |L25.122|
000066  f8d80010          LDR      r0,[r8,#0x10]         ;733
00006a  f0400101          ORR      r1,r0,#1              ;733
00006e  f8c81010          STR      r1,[r8,#0x10]         ;733
000072  8026              STRH     r6,[r4,#0]            ;735
000074  4648              MOV      r0,r9                 ;738
000076  f7fffffe          BL       FLASH_WaitForLastBank1Operation
                  |L25.122|
00007a  f8d81010          LDR      r1,[r8,#0x10]         ;746
00007e  4029              ANDS     r1,r1,r5              ;746
000080  f8c81010          STR      r1,[r8,#0x10]         ;746
000084  4648              MOV      r0,r9                 ;750
000086  f7fffffe          BL       FLASH_WaitForLastBank2Operation
00008a  2804              CMP      r0,#4                 ;752
00008c  d10e              BNE      |L25.172|
00008e  f8d80050          LDR      r0,[r8,#0x50]         ;756
000092  4646              MOV      r6,r8                 ;756
000094  f0400001          ORR      r0,r0,#1              ;756
000098  f8c80050          STR      r0,[r8,#0x50]         ;756
00009c  8067              STRH     r7,[r4,#2]            ;759
00009e  4648              MOV      r0,r9                 ;762
0000a0  f7fffffe          BL       FLASH_WaitForLastBank2Operation
0000a4  6d31              LDR      r1,[r6,#0x50]         ;765
0000a6  4029              ANDS     r1,r1,r5              ;765
0000a8  6531              STR      r1,[r6,#0x50]         ;765
0000aa  e7d1              B        |L25.80|
                  |L25.172|
0000ac  f8d82050          LDR      r2,[r8,#0x50]         ;770
0000b0  402a              ANDS     r2,r2,r5              ;770
0000b2  f8c82050          STR      r2,[r8,#0x50]         ;770
0000b6  e7cb              B        |L25.80|
                  |L25.184|
0000b8  f7fffffe          BL       FLASH_WaitForLastBank2Operation
0000bc  2804              CMP      r0,#4                 ;778
0000be  d1c7              BNE      |L25.80|
0000c0  f8d81050          LDR      r1,[r8,#0x50]         ;782
0000c4  f0410101          ORR      r1,r1,#1              ;782
0000c8  f8c81050          STR      r1,[r8,#0x50]         ;782
0000cc  8026              STRH     r6,[r4,#0]            ;784
0000ce  464e              MOV      r6,r9                 ;786
0000d0  4648              MOV      r0,r9                 ;786
0000d2  f7fffffe          BL       FLASH_WaitForLastBank2Operation
0000d6  2804              CMP      r0,#4                 ;788
0000d8  d1e8              BNE      |L25.172|
0000da  8067              STRH     r7,[r4,#2]            ;794
0000dc  4630              MOV      r0,r6                 ;797
0000de  f7fffffe          BL       FLASH_WaitForLastBank2Operation
0000e2  e7e3              B        |L25.172|
;;;848    
                          ENDP

                  |L25.228|
                          DCD      0x0807fffd
                  |L25.232|
                          DCD      0x40022000

                          AREA ||i.FLASH_ReadOutProtection||, CODE, READONLY, ALIGN=2

                  FLASH_ReadOutProtection PROC
;;;1047     */
;;;1048   FLASH_Status FLASH_ReadOutProtection(FunctionalState NewState)
000000  b570              PUSH     {r4-r6,lr}
;;;1049   {
000002  4606              MOV      r6,r0
;;;1050     FLASH_Status status = FLASH_COMPLETE;
;;;1051     /* Check the parameters */
;;;1052     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1053     status = FLASH_WaitForLastOperation(EraseTimeout);
000004  f44f2530          MOV      r5,#0xb0000
000008  4628              MOV      r0,r5
00000a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1054     if(status == FLASH_COMPLETE)
00000e  2804              CMP      r0,#4
000010  d118              BNE      |L26.68|
;;;1055     {
;;;1056       /* Authorizes the small information block programming */
;;;1057       FLASH->OPTKEYR = FLASH_KEY1;
000012  4c1a              LDR      r4,|L26.124|
000014  4818              LDR      r0,|L26.120|
000016  60a0              STR      r0,[r4,#8]
;;;1058       FLASH->OPTKEYR = FLASH_KEY2;
000018  4819              LDR      r0,|L26.128|
00001a  60a0              STR      r0,[r4,#8]
;;;1059       FLASH->CR |= CR_OPTER_Set;
00001c  6920              LDR      r0,[r4,#0x10]
00001e  f0400020          ORR      r0,r0,#0x20
000022  6120              STR      r0,[r4,#0x10]
;;;1060       FLASH->CR |= CR_STRT_Set;
000024  6920              LDR      r0,[r4,#0x10]
000026  f0400040          ORR      r0,r0,#0x40
00002a  6120              STR      r0,[r4,#0x10]
;;;1061       /* Wait for last operation to be completed */
;;;1062       status = FLASH_WaitForLastOperation(EraseTimeout);
00002c  4628              MOV      r0,r5
00002e  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1063       if(status == FLASH_COMPLETE)
;;;1064       {
;;;1065         /* if the erase operation is completed, disable the OPTER Bit */
;;;1066         FLASH->CR &= CR_OPTER_Reset;
000032  f64171df          MOV      r1,#0x1fdf
000036  2804              CMP      r0,#4                 ;1063
000038  d005              BEQ      |L26.70|
;;;1067         /* Enable the Option Bytes Programming operation */
;;;1068         FLASH->CR |= CR_OPTPG_Set; 
;;;1069         if(NewState != DISABLE)
;;;1070         {
;;;1071           OB->RDP = 0x00;
;;;1072         }
;;;1073         else
;;;1074         {
;;;1075           OB->RDP = RDP_Key;  
;;;1076         }
;;;1077         /* Wait for last operation to be completed */
;;;1078         status = FLASH_WaitForLastOperation(EraseTimeout); 
;;;1079       
;;;1080         if(status != FLASH_TIMEOUT)
;;;1081         {
;;;1082           /* if the program operation is completed, disable the OPTPG Bit */
;;;1083           FLASH->CR &= CR_OPTPG_Reset;
;;;1084         }
;;;1085       }
;;;1086       else 
;;;1087       {
;;;1088         if(status != FLASH_TIMEOUT)
00003a  2805              CMP      r0,#5
00003c  d002              BEQ      |L26.68|
;;;1089         {
;;;1090           /* Disable the OPTER Bit */
;;;1091           FLASH->CR &= CR_OPTER_Reset;
00003e  6922              LDR      r2,[r4,#0x10]
000040  400a              ANDS     r2,r2,r1
000042  6122              STR      r2,[r4,#0x10]
                  |L26.68|
;;;1092         }
;;;1093       }
;;;1094     }
;;;1095     /* Return the protection operation Status */
;;;1096     return status;       
;;;1097   }
000044  bd70              POP      {r4-r6,pc}
                  |L26.70|
000046  6920              LDR      r0,[r4,#0x10]         ;1066
000048  4008              ANDS     r0,r0,r1              ;1066
00004a  6120              STR      r0,[r4,#0x10]         ;1066
00004c  6920              LDR      r0,[r4,#0x10]         ;1068
00004e  f0400010          ORR      r0,r0,#0x10           ;1068
000052  6120              STR      r0,[r4,#0x10]         ;1068
000054  480b              LDR      r0,|L26.132|
000056  b10e              CBZ      r6,|L26.92|
000058  2100              MOVS     r1,#0                 ;1071
00005a  e000              B        |L26.94|
                  |L26.92|
00005c  21a5              MOVS     r1,#0xa5              ;1075
                  |L26.94|
00005e  f8a01800          STRH     r1,[r0,#0x800]        ;1075
000062  4628              MOV      r0,r5                 ;1078
000064  f7fffffe          BL       FLASH_WaitForLastOperation
000068  2805              CMP      r0,#5                 ;1080
00006a  d0eb              BEQ      |L26.68|
00006c  6921              LDR      r1,[r4,#0x10]         ;1083
00006e  f64172ef          MOV      r2,#0x1fef            ;1083
000072  4011              ANDS     r1,r1,r2              ;1083
000074  6121              STR      r1,[r4,#0x10]         ;1083
000076  bd70              POP      {r4-r6,pc}
;;;1098   
                          ENDP

                  |L26.120|
                          DCD      0x45670123
                  |L26.124|
                          DCD      0x40022000
                  |L26.128|
                          DCD      0xcdef89ab
                  |L26.132|
                          DCD      0x1ffff000

                          AREA ||i.FLASH_SetLatency||, CODE, READONLY, ALIGN=2

                  FLASH_SetLatency PROC
;;;252      */
;;;253    void FLASH_SetLatency(uint32_t FLASH_Latency)
000000  4a03              LDR      r2,|L27.16|
;;;254    {
;;;255      uint32_t tmpreg = 0;
;;;256      
;;;257      /* Check the parameters */
;;;258      assert_param(IS_FLASH_LATENCY(FLASH_Latency));
;;;259      
;;;260      /* Read the ACR register */
;;;261      tmpreg = FLASH->ACR;  
000002  6811              LDR      r1,[r2,#0]
;;;262      
;;;263      /* Sets the Latency value */
;;;264      tmpreg &= ACR_LATENCY_Mask;
000004  f0010138          AND      r1,r1,#0x38
;;;265      tmpreg |= FLASH_Latency;
000008  4301              ORRS     r1,r1,r0
;;;266      
;;;267      /* Write the ACR register */
;;;268      FLASH->ACR = tmpreg;
00000a  6011              STR      r1,[r2,#0]
;;;269    }
00000c  4770              BX       lr
;;;270    
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      0x40022000

                          AREA ||i.FLASH_Unlock||, CODE, READONLY, ALIGN=2

                  FLASH_Unlock PROC
;;;317      */
;;;318    void FLASH_Unlock(void)
000000  4804              LDR      r0,|L28.20|
;;;319    {
;;;320      /* Authorize the FPEC of Bank1 Access */
;;;321      FLASH->KEYR = FLASH_KEY1;
000002  4903              LDR      r1,|L28.16|
000004  6041              STR      r1,[r0,#4]
;;;322      FLASH->KEYR = FLASH_KEY2;
000006  4a04              LDR      r2,|L28.24|
000008  6042              STR      r2,[r0,#4]
;;;323    
;;;324    #ifdef STM32F10X_XL
;;;325      /* Authorize the FPEC of Bank2 Access */
;;;326      FLASH->KEYR2 = FLASH_KEY1;
00000a  6441              STR      r1,[r0,#0x44]
;;;327      FLASH->KEYR2 = FLASH_KEY2;
00000c  6442              STR      r2,[r0,#0x44]
;;;328    #endif /* STM32F10X_XL */
;;;329    }
00000e  4770              BX       lr
;;;330    /**
                          ENDP

                  |L28.16|
                          DCD      0x45670123
                  |L28.20|
                          DCD      0x40022000
                  |L28.24|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank1||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank1 PROC
;;;338      */
;;;339    void FLASH_UnlockBank1(void)
000000  4803              LDR      r0,|L29.16|
;;;340    {
;;;341      /* Authorize the FPEC of Bank1 Access */
;;;342      FLASH->KEYR = FLASH_KEY1;
000002  4902              LDR      r1,|L29.12|
000004  6041              STR      r1,[r0,#4]
;;;343      FLASH->KEYR = FLASH_KEY2;
000006  4903              LDR      r1,|L29.20|
000008  6041              STR      r1,[r0,#4]
;;;344    }
00000a  4770              BX       lr
;;;345    
                          ENDP

                  |L29.12|
                          DCD      0x45670123
                  |L29.16|
                          DCD      0x40022000
                  |L29.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UnlockBank2||, CODE, READONLY, ALIGN=2

                  FLASH_UnlockBank2 PROC
;;;352      */
;;;353    void FLASH_UnlockBank2(void)
000000  4803              LDR      r0,|L30.16|
;;;354    {
;;;355      /* Authorize the FPEC of Bank2 Access */
;;;356      FLASH->KEYR2 = FLASH_KEY1;
000002  4902              LDR      r1,|L30.12|
000004  6441              STR      r1,[r0,#0x44]
;;;357      FLASH->KEYR2 = FLASH_KEY2;
000006  4903              LDR      r1,|L30.20|
000008  6441              STR      r1,[r0,#0x44]
;;;358    
;;;359    }
00000a  4770              BX       lr
;;;360    #endif /* STM32F10X_XL */
                          ENDP

                  |L30.12|
                          DCD      0x45670123
                  |L30.16|
                          DCD      0x40022000
                  |L30.20|
                          DCD      0xcdef89ab

                          AREA ||i.FLASH_UserOptionByteConfig||, CODE, READONLY, ALIGN=2

                  FLASH_UserOptionByteConfig PROC
;;;1116     */
;;;1117   FLASH_Status FLASH_UserOptionByteConfig(uint16_t OB_IWDG, uint16_t OB_STOP, uint16_t OB_STDBY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1118   {
;;;1119     FLASH_Status status = FLASH_COMPLETE; 
;;;1120   
;;;1121     /* Check the parameters */
;;;1122     assert_param(IS_OB_IWDG_SOURCE(OB_IWDG));
;;;1123     assert_param(IS_OB_STOP_SOURCE(OB_STOP));
;;;1124     assert_param(IS_OB_STDBY_SOURCE(OB_STDBY));
;;;1125   
;;;1126     /* Authorize the small information block programming */
;;;1127     FLASH->OPTKEYR = FLASH_KEY1;
000004  4c13              LDR      r4,|L31.84|
000006  4606              MOV      r6,r0                 ;1118
000008  4811              LDR      r0,|L31.80|
00000a  460d              MOV      r5,r1                 ;1118
00000c  4617              MOV      r7,r2                 ;1118
00000e  60a0              STR      r0,[r4,#8]
;;;1128     FLASH->OPTKEYR = FLASH_KEY2;
000010  4811              LDR      r0,|L31.88|
000012  60a0              STR      r0,[r4,#8]
;;;1129     
;;;1130     /* Wait for last operation to be completed */
;;;1131     status = FLASH_WaitForLastOperation(ProgramTimeout);
000014  f44f5800          MOV      r8,#0x2000
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1132     
;;;1133     if(status == FLASH_COMPLETE)
00001e  2804              CMP      r0,#4
000020  d113              BNE      |L31.74|
;;;1134     {  
;;;1135       /* Enable the Option Bytes Programming operation */
;;;1136       FLASH->CR |= CR_OPTPG_Set; 
000022  6920              LDR      r0,[r4,#0x10]
000024  f0400010          ORR      r0,r0,#0x10
000028  6120              STR      r0,[r4,#0x10]
;;;1137              
;;;1138       OB->USER = OB_IWDG | (uint16_t)(OB_STOP | (uint16_t)(OB_STDBY | ((uint16_t)0xF8))); 
00002a  433d              ORRS     r5,r5,r7
00002c  490b              LDR      r1,|L31.92|
00002e  4335              ORRS     r5,r5,r6
000030  f04500f8          ORR      r0,r5,#0xf8
000034  8008              STRH     r0,[r1,#0]
;;;1139     
;;;1140       /* Wait for last operation to be completed */
;;;1141       status = FLASH_WaitForLastOperation(ProgramTimeout);
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       FLASH_WaitForLastOperation
;;;1142       if(status != FLASH_TIMEOUT)
00003c  2805              CMP      r0,#5
00003e  d004              BEQ      |L31.74|
;;;1143       {
;;;1144         /* if the program operation is completed, disable the OPTPG Bit */
;;;1145         FLASH->CR &= CR_OPTPG_Reset;
000040  6921              LDR      r1,[r4,#0x10]
000042  f64172ef          MOV      r2,#0x1fef
000046  4011              ANDS     r1,r1,r2
000048  6121              STR      r1,[r4,#0x10]
                  |L31.74|
;;;1146       }
;;;1147     }    
;;;1148     /* Return the Option Byte program Status */
;;;1149     return status;
;;;1150   }
00004a  e8bd81f0          POP      {r4-r8,pc}
;;;1151   
                          ENDP

00004e  0000              DCW      0x0000
                  |L31.80|
                          DCD      0x45670123
                  |L31.84|
                          DCD      0x40022000
                  |L31.88|
                          DCD      0xcdef89ab
                  |L31.92|
                          DCD      0x1ffff802

                          AREA ||i.FLASH_WaitForLastBank1Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank1Operation PROC
;;;1621     */
;;;1622   FLASH_Status FLASH_WaitForLastBank1Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1623   { 
000002  4603              MOV      r3,r0
;;;1624     FLASH_Status status = FLASH_COMPLETE;
;;;1625      
;;;1626     /* Check for the Flash Status */
;;;1627     status = FLASH_GetBank1Status();
000004  f7fffffe          BL       FLASH_GetBank1Status
;;;1628     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1629     while((status == FLASH_FLAG_BANK1_BSY) && (Timeout != 0x00))
000008  e002              B        |L32.16|
                  |L32.10|
;;;1630     {
;;;1631       status = FLASH_GetBank1Status();
00000a  f7fffffe          BL       FLASH_GetBank1Status
;;;1632       Timeout--;
00000e  1e5b              SUBS     r3,r3,#1
                  |L32.16|
000010  2801              CMP      r0,#1                 ;1629
000012  d003              BEQ      |L32.28|
;;;1633     }
;;;1634     if(Timeout == 0x00 )
000014  2b00              CMP      r3,#0
000016  d100              BNE      |L32.26|
                  |L32.24|
;;;1635     {
;;;1636       status = FLASH_TIMEOUT;
000018  2005              MOVS     r0,#5
                  |L32.26|
;;;1637     }
;;;1638     /* Return the operation status */
;;;1639     return status;
;;;1640   }
00001a  bd00              POP      {pc}
                  |L32.28|
00001c  2b00              CMP      r3,#0                 ;1629
00001e  d1f4              BNE      |L32.10|
000020  e7fa              B        |L32.24|
;;;1641   
                          ENDP


                          AREA ||i.FLASH_WaitForLastBank2Operation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastBank2Operation PROC
;;;1649     */
;;;1650   FLASH_Status FLASH_WaitForLastBank2Operation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1651   { 
000002  4603              MOV      r3,r0
;;;1652     FLASH_Status status = FLASH_COMPLETE;
;;;1653      
;;;1654     /* Check for the Flash Status */
;;;1655     status = FLASH_GetBank2Status();
000004  f7fffffe          BL       FLASH_GetBank2Status
;;;1656     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1657     while((status == (FLASH_FLAG_BANK2_BSY & 0x7FFFFFFF)) && (Timeout != 0x00))
000008  e002              B        |L33.16|
                  |L33.10|
;;;1658     {
;;;1659       status = FLASH_GetBank2Status();
00000a  f7fffffe          BL       FLASH_GetBank2Status
;;;1660       Timeout--;
00000e  1e5b              SUBS     r3,r3,#1
                  |L33.16|
000010  2801              CMP      r0,#1                 ;1657
000012  d003              BEQ      |L33.28|
;;;1661     }
;;;1662     if(Timeout == 0x00 )
000014  2b00              CMP      r3,#0
000016  d100              BNE      |L33.26|
                  |L33.24|
;;;1663     {
;;;1664       status = FLASH_TIMEOUT;
000018  2005              MOVS     r0,#5
                  |L33.26|
;;;1665     }
;;;1666     /* Return the operation status */
;;;1667     return status;
;;;1668   }
00001a  bd00              POP      {pc}
                  |L33.28|
00001c  2b00              CMP      r3,#0                 ;1657
00001e  d1f4              BNE      |L33.10|
000020  e7fa              B        |L33.24|
;;;1669   #endif /* STM32F10X_XL */
                          ENDP


                          AREA ||i.FLASH_WaitForLastOperation||, CODE, READONLY, ALIGN=1

                  FLASH_WaitForLastOperation PROC
;;;1593     */
;;;1594   FLASH_Status FLASH_WaitForLastOperation(uint32_t Timeout)
000000  b500              PUSH     {lr}
;;;1595   { 
000002  4603              MOV      r3,r0
;;;1596     FLASH_Status status = FLASH_COMPLETE;
;;;1597      
;;;1598     /* Check for the Flash Status */
;;;1599     status = FLASH_GetBank1Status();
000004  f7fffffe          BL       FLASH_GetBank1Status
;;;1600     /* Wait for a Flash operation to complete or a TIMEOUT to occur */
;;;1601     while((status == FLASH_BUSY) && (Timeout != 0x00))
000008  e002              B        |L34.16|
                  |L34.10|
;;;1602     {
;;;1603       status = FLASH_GetBank1Status();
00000a  f7fffffe          BL       FLASH_GetBank1Status
;;;1604       Timeout--;
00000e  1e5b              SUBS     r3,r3,#1
                  |L34.16|
000010  2801              CMP      r0,#1                 ;1601
000012  d003              BEQ      |L34.28|
;;;1605     }
;;;1606     if(Timeout == 0x00 )
000014  2b00              CMP      r3,#0
000016  d100              BNE      |L34.26|
                  |L34.24|
;;;1607     {
;;;1608       status = FLASH_TIMEOUT;
000018  2005              MOVS     r0,#5
                  |L34.26|
;;;1609     }
;;;1610     /* Return the operation status */
;;;1611     return status;
;;;1612   }
00001a  bd00              POP      {pc}
                  |L34.28|
00001c  2b00              CMP      r3,#0                 ;1601
00001e  d1f4              BNE      |L34.10|
000020  e7fa              B        |L34.24|
;;;1613   
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_flash.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_flash_c_a2a150d6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_flash_c_a2a150d6____REVSH|
#line 128
|__asm___17_stm32f10x_flash_c_a2a150d6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
