; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\system_stm32f10x.o --depend=.\ouput\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\system_stm32f10x.crf Source\FWLib\cm3\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;925      */
;;;926    static void SetSysClockTo72(void)
000000  4922              LDR      r1,|L1.140|
;;;927    {
;;;928      __IO uint32_t StartUpCounter = 0, HSEStatus = 0;
000002  2000              MOVS     r0,#0
;;;929      
;;;930      /* SYSCLK, HCLK, PCLK2 and PCLK1 configuration ---------------------------*/    
;;;931      /* Enable HSE */    
;;;932      RCC->CR |= ((uint32_t)RCC_CR_HSEON);
000004  680a              LDR      r2,[r1,#0]
000006  f4423280          ORR      r2,r2,#0x10000
00000a  600a              STR      r2,[r1,#0]
;;;933     
;;;934      /* Wait till HSE is ready and if Time out is reached exit */
;;;935      do
;;;936      {
;;;937        HSEStatus = RCC->CR & RCC_CR_HSERDY;
;;;938        StartUpCounter++;  
;;;939      } while((HSEStatus == 0) && (StartUpCounter != HSE_STARTUP_TIMEOUT));
00000c  f44f63a0          MOV      r3,#0x500
                  |L1.16|
000010  680a              LDR      r2,[r1,#0]            ;937
000012  f1000001          ADD      r0,r0,#1              ;938
000016  f4123f00          TST      r2,#0x20000           ;937
00001a  d101              BNE      |L1.32|
00001c  4298              CMP      r0,r3
00001e  d1f7              BNE      |L1.16|
                  |L1.32|
;;;940    
;;;941      if ((RCC->CR & RCC_CR_HSERDY) != RESET)
000020  6808              LDR      r0,[r1,#0]
000022  0380              LSLS     r0,r0,#14
000024  d530              BPL      |L1.136|
;;;942      {
;;;943        HSEStatus = (uint32_t)0x01;
;;;944      }
;;;945      else
;;;946      {
;;;947        HSEStatus = (uint32_t)0x00;
;;;948      }  
;;;949    
;;;950      if (HSEStatus == (uint32_t)0x01)
;;;951      {
;;;952        /* Enable Prefetch Buffer */
;;;953        FLASH->ACR |= FLASH_ACR_PRFTBE;
000026  481a              LDR      r0,|L1.144|
000028  6802              LDR      r2,[r0,#0]
00002a  f0420210          ORR      r2,r2,#0x10
00002e  6002              STR      r2,[r0,#0]
;;;954    
;;;955        /* Flash 2 wait state */
;;;956        FLASH->ACR &= (uint32_t)((uint32_t)~FLASH_ACR_LATENCY);
000030  6802              LDR      r2,[r0,#0]
000032  f0220203          BIC      r2,r2,#3
000036  6002              STR      r2,[r0,#0]
;;;957        FLASH->ACR |= (uint32_t)FLASH_ACR_LATENCY_2;    
000038  6802              LDR      r2,[r0,#0]
00003a  f0420202          ORR      r2,r2,#2
00003e  6002              STR      r2,[r0,#0]
;;;958    
;;;959     
;;;960        /* HCLK = SYSCLK */
;;;961        RCC->CFGR |= (uint32_t)RCC_CFGR_HPRE_DIV1;
000040  6848              LDR      r0,[r1,#4]
000042  6048              STR      r0,[r1,#4]
;;;962          
;;;963        /* PCLK2 = HCLK */
;;;964        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE2_DIV1;
000044  6848              LDR      r0,[r1,#4]
000046  6048              STR      r0,[r1,#4]
;;;965        
;;;966        /* PCLK1 = HCLK */
;;;967        RCC->CFGR |= (uint32_t)RCC_CFGR_PPRE1_DIV2;
000048  6848              LDR      r0,[r1,#4]
00004a  f4406080          ORR      r0,r0,#0x400
00004e  6048              STR      r0,[r1,#4]
;;;968    
;;;969    #ifdef STM32F10X_CL
;;;970        /* Configure PLLs ------------------------------------------------------*/
;;;971        /* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;972        /* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;973            
;;;974        RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;975                                  RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;976        RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;977                                 RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;978      
;;;979        /* Enable PLL2 */
;;;980        RCC->CR |= RCC_CR_PLL2ON;
;;;981        /* Wait till PLL2 is ready */
;;;982        while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;983        {
;;;984        }
;;;985        
;;;986       
;;;987        /* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;988        RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;989        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | 
;;;990                                RCC_CFGR_PLLMULL9); 
;;;991    #else    
;;;992        /*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;993        RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE |
000050  6848              LDR      r0,[r1,#4]
000052  f420107c          BIC      r0,r0,#0x3f0000
000056  6048              STR      r0,[r1,#4]
;;;994                                            RCC_CFGR_PLLMULL));
;;;995        RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000058  6848              LDR      r0,[r1,#4]
00005a  f44010e8          ORR      r0,r0,#0x1d0000
00005e  6048              STR      r0,[r1,#4]
;;;996    #endif /* STM32F10X_CL */
;;;997    
;;;998        /* Enable PLL */
;;;999        RCC->CR |= RCC_CR_PLLON;
000060  6808              LDR      r0,[r1,#0]
000062  f0407080          ORR      r0,r0,#0x1000000
000066  6008              STR      r0,[r1,#0]
                  |L1.104|
;;;1000   
;;;1001       /* Wait till PLL is ready */
;;;1002       while((RCC->CR & RCC_CR_PLLRDY) == 0)
000068  6808              LDR      r0,[r1,#0]
00006a  0180              LSLS     r0,r0,#6
00006c  d5fc              BPL      |L1.104|
;;;1003       {
;;;1004       }
;;;1005       
;;;1006       /* Select PLL as system clock source */
;;;1007       RCC->CFGR &= (uint32_t)((uint32_t)~(RCC_CFGR_SW));
00006e  6848              LDR      r0,[r1,#4]
000070  f0200003          BIC      r0,r0,#3
000074  6048              STR      r0,[r1,#4]
;;;1008       RCC->CFGR |= (uint32_t)RCC_CFGR_SW_PLL;    
000076  6848              LDR      r0,[r1,#4]
000078  f0400002          ORR      r0,r0,#2
00007c  6048              STR      r0,[r1,#4]
                  |L1.126|
;;;1009   
;;;1010       /* Wait till PLL is used as system clock source */
;;;1011       while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
00007e  6848              LDR      r0,[r1,#4]
000080  f3c00081          UBFX     r0,r0,#2,#2
000084  2802              CMP      r0,#2
000086  d1fa              BNE      |L1.126|
                  |L1.136|
;;;1012       {
;;;1013       }
;;;1014     }
;;;1015     else
;;;1016     { /* If HSE fails to start-up, the application will have wrong clock 
;;;1017            configuration. User can add here some code to deal with this error */
;;;1018     }
;;;1019   }
000088  4770              BX       lr
;;;1020   #endif
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      0x40021000
                  |L1.144|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;244      */
;;;245    void SystemCoreClockUpdate (void)
000000  4a15              LDR      r2,|L2.88|
;;;246    {
000002  b510              PUSH     {r4,lr}
;;;247      uint32_t tmp = 0, pllmull = 0, pllsource = 0;
;;;248    
;;;249    #ifdef  STM32F10X_CL
;;;250      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;251    #endif /* STM32F10X_CL */
;;;252    
;;;253    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;254      uint32_t prediv1factor = 0;
;;;255    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;256        
;;;257      /* Get SYSCLK source -------------------------------------------------------*/
;;;258      tmp = RCC->CFGR & RCC_CFGR_SWS;
000004  6850              LDR      r0,[r2,#4]
;;;259      
;;;260      switch (tmp)
;;;261      {
;;;262        case 0x00:  /* HSI used as system clock */
;;;263          SystemCoreClock = HSI_VALUE;
000006  4b15              LDR      r3,|L2.92|
000008  f010010c          ANDS     r1,r0,#0xc            ;258
00000c  4814              LDR      r0,|L2.96|
00000e  d003              BEQ      |L2.24|
000010  2904              CMP      r1,#4                 ;260
000012  d001              BEQ      |L2.24|
000014  2908              CMP      r1,#8                 ;260
000016  d001              BEQ      |L2.28|
                  |L2.24|
;;;264          break;
000018  6003              STR      r3,[r0,#0]  ; SystemCoreClock
00001a  e012              B        |L2.66|
                  |L2.28|
;;;265        case 0x04:  /* HSE used as system clock */
;;;266          SystemCoreClock = HSE_VALUE;
;;;267          break;
;;;268        case 0x08:  /* PLL used as system clock */
;;;269    
;;;270          /* Get PLL clock source and multiplication factor ----------------------*/
;;;271          pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00001c  6851              LDR      r1,[r2,#4]
;;;272          pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
00001e  6853              LDR      r3,[r2,#4]
000020  f4011170          AND      r1,r1,#0x3c0000       ;271
;;;273          
;;;274    #ifndef STM32F10X_CL      
;;;275          pllmull = ( pllmull >> 18) + 2;
000024  f04f0402          MOV      r4,#2
000028  f4133f80          TST      r3,#0x10000           ;272
00002c  eb044191          ADD      r1,r4,r1,LSR #18
;;;276          
;;;277          if (pllsource == 0x00)
000030  d002              BEQ      |L2.56|
;;;278          {
;;;279            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;280            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;281          }
;;;282          else
;;;283          {
;;;284     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;285           prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;286           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;287           SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;288     #else
;;;289            /* HSE selected as PLL clock entry */
;;;290            if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
000032  6853              LDR      r3,[r2,#4]
000034  039b              LSLS     r3,r3,#14
000036  d501              BPL      |L2.60|
                  |L2.56|
000038  4b0a              LDR      r3,|L2.100|
00003a  e000              B        |L2.62|
                  |L2.60|
;;;291            {/* HSE oscillator clock divided by 2 */
;;;292              SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
;;;293            }
;;;294            else
;;;295            {
;;;296              SystemCoreClock = HSE_VALUE * pllmull;
00003c  4b07              LDR      r3,|L2.92|
                  |L2.62|
00003e  4359              MULS     r1,r3,r1              ;292
000040  6001              STR      r1,[r0,#0]            ;292  ; SystemCoreClock
                  |L2.66|
;;;297            }
;;;298     #endif
;;;299          }
;;;300    #else
;;;301          pllmull = pllmull >> 18;
;;;302          
;;;303          if (pllmull != 0x0D)
;;;304          {
;;;305             pllmull += 2;
;;;306          }
;;;307          else
;;;308          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;309            pllmull = 13 / 2; 
;;;310          }
;;;311                
;;;312          if (pllsource == 0x00)
;;;313          {
;;;314            /* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;315            SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;316          }
;;;317          else
;;;318          {/* PREDIV1 selected as PLL clock entry */
;;;319            
;;;320            /* Get PREDIV1 clock source and division factor */
;;;321            prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;322            prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;323            
;;;324            if (prediv1source == 0)
;;;325            { 
;;;326              /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;327              SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;328            }
;;;329            else
;;;330            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;331              
;;;332              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;333              prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;334              pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;335              SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;336            }
;;;337          }
;;;338    #endif /* STM32F10X_CL */ 
;;;339          break;
;;;340    
;;;341        default:
;;;342          SystemCoreClock = HSI_VALUE;
;;;343          break;
;;;344      }
;;;345      
;;;346      /* Compute HCLK clock frequency ----------------*/
;;;347      /* Get HCLK prescaler */
;;;348      tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000042  6851              LDR      r1,[r2,#4]
000044  4a06              LDR      r2,|L2.96|
000046  f3c11103          UBFX     r1,r1,#4,#4
00004a  1d12              ADDS     r2,r2,#4
00004c  5c51              LDRB     r1,[r2,r1]
;;;349      /* HCLK clock frequency */
;;;350      SystemCoreClock >>= tmp;  
00004e  6802              LDR      r2,[r0,#0]  ; SystemCoreClock
000050  40ca              LSRS     r2,r2,r1
000052  6002              STR      r2,[r0,#0]  ; SystemCoreClock
;;;351    }
000054  bd10              POP      {r4,pc}
;;;352    
                          ENDP

000056  0000              DCW      0x0000
                  |L2.88|
                          DCD      0x40021000
                  |L2.92|
                          DCD      0x007a1200
                  |L2.96|
                          DCD      ||.data||
                  |L2.100|
                          DCD      0x003d0900

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;179      */
;;;180    void SystemInit (void)
000000  480f              LDR      r0,|L3.64|
;;;181    {
000002  b510              PUSH     {r4,lr}
;;;182      /* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;183      /* Set HSION bit */
;;;184      RCC->CR |= (uint32_t)0x00000001;
000004  6801              LDR      r1,[r0,#0]
000006  f0410101          ORR      r1,r1,#1
00000a  6001              STR      r1,[r0,#0]
;;;185    
;;;186      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;187    #ifndef STM32F10X_CL
;;;188      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000c  6841              LDR      r1,[r0,#4]
00000e  4a0d              LDR      r2,|L3.68|
000010  4011              ANDS     r1,r1,r2
000012  6041              STR      r1,[r0,#4]
;;;189    #else
;;;190      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;191    #endif /* STM32F10X_CL */   
;;;192      
;;;193      /* Reset HSEON, CSSON and PLLON bits */
;;;194      RCC->CR &= (uint32_t)0xFEF6FFFF;
000014  6801              LDR      r1,[r0,#0]
000016  4a0c              LDR      r2,|L3.72|
000018  4011              ANDS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;195    
;;;196      /* Reset HSEBYP bit */
;;;197      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001c  6801              LDR      r1,[r0,#0]
00001e  f4212180          BIC      r1,r1,#0x40000
000022  6001              STR      r1,[r0,#0]
;;;198    
;;;199      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;200      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000024  6841              LDR      r1,[r0,#4]
000026  f42101fe          BIC      r1,r1,#0x7f0000
00002a  6041              STR      r1,[r0,#4]
;;;201    
;;;202    #ifdef STM32F10X_CL
;;;203      /* Reset PLL2ON and PLL3ON bits */
;;;204      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;205    
;;;206      /* Disable all interrupts and clear pending bits  */
;;;207      RCC->CIR = 0x00FF0000;
;;;208    
;;;209      /* Reset CFGR2 register */
;;;210      RCC->CFGR2 = 0x00000000;
;;;211    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;212      /* Disable all interrupts and clear pending bits  */
;;;213      RCC->CIR = 0x009F0000;
;;;214    
;;;215      /* Reset CFGR2 register */
;;;216      RCC->CFGR2 = 0x00000000;      
;;;217    #else
;;;218      /* Disable all interrupts and clear pending bits  */
;;;219      RCC->CIR = 0x009F0000;
00002c  f44f011f          MOV      r1,#0x9f0000
000030  6081              STR      r1,[r0,#8]
000032  f7fffffe          BL       SetSysClockTo72
;;;220    #endif /* STM32F10X_CL */
;;;221        
;;;222    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;223      #ifdef DATA_IN_ExtSRAM
;;;224        SystemInit_ExtMemCtl(); 
;;;225      #endif /* DATA_IN_ExtSRAM */
;;;226    #endif 
;;;227    
;;;228      /* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;229      /* Configure the Flash Latency cycles and enable prefetch buffer */
;;;230      SetSysClock();
;;;231    
;;;232    #ifdef VECT_TAB_SRAM
;;;233      SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;234    #else
;;;235      SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000036  4905              LDR      r1,|L3.76|
000038  f04f6000          MOV      r0,#0x8000000
00003c  6008              STR      r0,[r1,#0]
;;;236    #endif 
;;;237    }
00003e  bd10              POP      {r4,pc}
;;;238    
                          ENDP

                  |L3.64|
                          DCD      0x40021000
                  |L3.68|
                          DCD      0xf8ff0000
                  |L3.72|
                          DCD      0xfef6ffff
                  |L3.76|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\cm3\\system_stm32f10x.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_system_stm32f10x_c_5d646a67____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REVSH|
#line 128
|__asm___18_system_stm32f10x_c_5d646a67____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
