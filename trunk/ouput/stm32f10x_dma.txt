; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_dma.o --depend=.\ouput\stm32f10x_dma.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_dma.crf Source\FWLib\src\stm32f10x_dma.c]
                          THUMB

                          AREA ||i.DMA_ClearFlag||, CODE, READONLY, ALIGN=2

                  DMA_ClearFlag PROC
;;;520      */
;;;521    void DMA_ClearFlag(uint32_t DMA_FLAG)
000000  4903              LDR      r1,|L1.16|
;;;522    {
;;;523      /* Check the parameters */
;;;524      assert_param(IS_DMA_CLEAR_FLAG(DMA_FLAG));
;;;525      /* Calculate the used DMA */
;;;526    
;;;527      if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
000002  00c2              LSLS     r2,r0,#3
000004  d502              BPL      |L1.12|
;;;528      {
;;;529        /* Clear the selected DMA flags */
;;;530        DMA2->IFCR = DMA_FLAG;
000006  f8c10404          STR      r0,[r1,#0x404]
;;;531      }
;;;532      else
;;;533      {
;;;534        /* Clear the selected DMA flags */
;;;535        DMA1->IFCR = DMA_FLAG;
;;;536      }
;;;537    }
00000a  4770              BX       lr
                  |L1.12|
00000c  6048              STR      r0,[r1,#4]            ;535
00000e  4770              BX       lr
;;;538    
                          ENDP

                  |L1.16|
                          DCD      0x40020000

                          AREA ||i.DMA_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  DMA_ClearITPendingBit PROC
;;;680      */
;;;681    void DMA_ClearITPendingBit(uint32_t DMA_IT)
000000  4903              LDR      r1,|L2.16|
;;;682    {
;;;683      /* Check the parameters */
;;;684      assert_param(IS_DMA_CLEAR_IT(DMA_IT));
;;;685    
;;;686      /* Calculate the used DMA */
;;;687      if ((DMA_IT & FLAG_Mask) != (uint32_t)RESET)
000002  00c2              LSLS     r2,r0,#3
000004  d502              BPL      |L2.12|
;;;688      {
;;;689        /* Clear the selected DMA interrupt pending bits */
;;;690        DMA2->IFCR = DMA_IT;
000006  f8c10404          STR      r0,[r1,#0x404]
;;;691      }
;;;692      else
;;;693      {
;;;694        /* Clear the selected DMA interrupt pending bits */
;;;695        DMA1->IFCR = DMA_IT;
;;;696      }
;;;697    }
00000a  4770              BX       lr
                  |L2.12|
00000c  6048              STR      r0,[r1,#4]            ;695
00000e  4770              BX       lr
;;;698    
                          ENDP

                  |L2.16|
                          DCD      0x40020000

                          AREA ||i.DMA_Cmd||, CODE, READONLY, ALIGN=1

                  DMA_Cmd PROC
;;;292      */
;;;293    void DMA_Cmd(DMA_Channel_TypeDef* DMAy_Channelx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;294    {
;;;295      /* Check the parameters */
;;;296      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;297      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;298    
;;;299      if (NewState != DISABLE)
;;;300      {
;;;301        /* Enable the selected DMAy Channelx */
;;;302        DMAy_Channelx->CCR |= DMA_CCR1_EN;
;;;303      }
;;;304      else
;;;305      {
;;;306        /* Disable the selected DMAy Channelx */
;;;307        DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
000002  6801              LDR      r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410101          ORR      r1,r1,#1              ;302
00000a  e002              B        |L3.18|
                  |L3.12|
00000c  f64f72fe          MOV      r2,#0xfffe
000010  4011              ANDS     r1,r1,r2
                  |L3.18|
000012  6001              STR      r1,[r0,#0]            ;302
;;;308      }
;;;309    }
000014  4770              BX       lr
;;;310    
                          ENDP


                          AREA ||i.DMA_DeInit||, CODE, READONLY, ALIGN=2

                  DMA_DeInit PROC
;;;106      */
;;;107    void DMA_DeInit(DMA_Channel_TypeDef* DMAy_Channelx)
000000  6801              LDR      r1,[r0,#0]
;;;108    {
;;;109      /* Check the parameters */
;;;110      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;111      
;;;112      /* Disable the selected DMAy Channelx */
;;;113      DMAy_Channelx->CCR &= (uint16_t)(~DMA_CCR1_EN);
000002  f64f72fe          MOV      r2,#0xfffe
000006  4011              ANDS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;114      
;;;115      /* Reset DMAy Channelx control register */
;;;116      DMAy_Channelx->CCR  = 0;
00000a  2100              MOVS     r1,#0
00000c  6001              STR      r1,[r0,#0]
;;;117      
;;;118      /* Reset DMAy Channelx remaining bytes register */
;;;119      DMAy_Channelx->CNDTR = 0;
00000e  6041              STR      r1,[r0,#4]
;;;120      
;;;121      /* Reset DMAy Channelx peripheral address register */
;;;122      DMAy_Channelx->CPAR  = 0;
000010  6081              STR      r1,[r0,#8]
;;;123      
;;;124      /* Reset DMAy Channelx memory address register */
;;;125      DMAy_Channelx->CMAR = 0;
000012  60c1              STR      r1,[r0,#0xc]
;;;126      
;;;127      if (DMAy_Channelx == DMA1_Channel1)
;;;128      {
;;;129        /* Reset interrupt pending bits for DMA1 Channel1 */
;;;130        DMA1->IFCR |= DMA1_Channel1_IT_Mask;
000014  4933              LDR      r1,|L4.228|
000016  4a33              LDR      r2,|L4.228|
000018  3908              SUBS     r1,r1,#8
00001a  4290              CMP      r0,r2                 ;127
00001c  d103              BNE      |L4.38|
00001e  6848              LDR      r0,[r1,#4]
000020  f040000f          ORR      r0,r0,#0xf
000024  e006              B        |L4.52|
                  |L4.38|
;;;131      }
;;;132      else if (DMAy_Channelx == DMA1_Channel2)
000026  4a2f              LDR      r2,|L4.228|
000028  3214              ADDS     r2,r2,#0x14
00002a  4290              CMP      r0,r2
00002c  d104              BNE      |L4.56|
;;;133      {
;;;134        /* Reset interrupt pending bits for DMA1 Channel2 */
;;;135        DMA1->IFCR |= DMA1_Channel2_IT_Mask;
00002e  6848              LDR      r0,[r1,#4]
000030  f04000f0          ORR      r0,r0,#0xf0
                  |L4.52|
000034  6048              STR      r0,[r1,#4]            ;130
;;;136      }
;;;137      else if (DMAy_Channelx == DMA1_Channel3)
;;;138      {
;;;139        /* Reset interrupt pending bits for DMA1 Channel3 */
;;;140        DMA1->IFCR |= DMA1_Channel3_IT_Mask;
;;;141      }
;;;142      else if (DMAy_Channelx == DMA1_Channel4)
;;;143      {
;;;144        /* Reset interrupt pending bits for DMA1 Channel4 */
;;;145        DMA1->IFCR |= DMA1_Channel4_IT_Mask;
;;;146      }
;;;147      else if (DMAy_Channelx == DMA1_Channel5)
;;;148      {
;;;149        /* Reset interrupt pending bits for DMA1 Channel5 */
;;;150        DMA1->IFCR |= DMA1_Channel5_IT_Mask;
;;;151      }
;;;152      else if (DMAy_Channelx == DMA1_Channel6)
;;;153      {
;;;154        /* Reset interrupt pending bits for DMA1 Channel6 */
;;;155        DMA1->IFCR |= DMA1_Channel6_IT_Mask;
;;;156      }
;;;157      else if (DMAy_Channelx == DMA1_Channel7)
;;;158      {
;;;159        /* Reset interrupt pending bits for DMA1 Channel7 */
;;;160        DMA1->IFCR |= DMA1_Channel7_IT_Mask;
;;;161      }
;;;162      else if (DMAy_Channelx == DMA2_Channel1)
;;;163      {
;;;164        /* Reset interrupt pending bits for DMA2 Channel1 */
;;;165        DMA2->IFCR |= DMA2_Channel1_IT_Mask;
;;;166      }
;;;167      else if (DMAy_Channelx == DMA2_Channel2)
;;;168      {
;;;169        /* Reset interrupt pending bits for DMA2 Channel2 */
;;;170        DMA2->IFCR |= DMA2_Channel2_IT_Mask;
;;;171      }
;;;172      else if (DMAy_Channelx == DMA2_Channel3)
;;;173      {
;;;174        /* Reset interrupt pending bits for DMA2 Channel3 */
;;;175        DMA2->IFCR |= DMA2_Channel3_IT_Mask;
;;;176      }
;;;177      else if (DMAy_Channelx == DMA2_Channel4)
;;;178      {
;;;179        /* Reset interrupt pending bits for DMA2 Channel4 */
;;;180        DMA2->IFCR |= DMA2_Channel4_IT_Mask;
;;;181      }
;;;182      else
;;;183      { 
;;;184        if (DMAy_Channelx == DMA2_Channel5)
;;;185        {
;;;186          /* Reset interrupt pending bits for DMA2 Channel5 */
;;;187          DMA2->IFCR |= DMA2_Channel5_IT_Mask;
;;;188        }
;;;189      }
;;;190    }
000036  4770              BX       lr
                  |L4.56|
000038  4a2a              LDR      r2,|L4.228|
00003a  3228              ADDS     r2,r2,#0x28           ;137
00003c  4290              CMP      r0,r2                 ;137
00003e  d103              BNE      |L4.72|
000040  6848              LDR      r0,[r1,#4]            ;140
000042  f4406070          ORR      r0,r0,#0xf00          ;140
000046  e7f5              B        |L4.52|
                  |L4.72|
000048  4a26              LDR      r2,|L4.228|
00004a  323c              ADDS     r2,r2,#0x3c           ;142
00004c  4290              CMP      r0,r2                 ;142
00004e  d103              BNE      |L4.88|
000050  6848              LDR      r0,[r1,#4]            ;145
000052  f4404070          ORR      r0,r0,#0xf000         ;145
000056  e7ed              B        |L4.52|
                  |L4.88|
000058  4a22              LDR      r2,|L4.228|
00005a  3250              ADDS     r2,r2,#0x50           ;147
00005c  4290              CMP      r0,r2                 ;147
00005e  d103              BNE      |L4.104|
000060  6848              LDR      r0,[r1,#4]            ;150
000062  f4402070          ORR      r0,r0,#0xf0000        ;150
000066  e7e5              B        |L4.52|
                  |L4.104|
000068  4a1e              LDR      r2,|L4.228|
00006a  3264              ADDS     r2,r2,#0x64           ;152
00006c  4290              CMP      r0,r2                 ;152
00006e  d103              BNE      |L4.120|
000070  6848              LDR      r0,[r1,#4]            ;155
000072  f4400070          ORR      r0,r0,#0xf00000       ;155
000076  e7dd              B        |L4.52|
                  |L4.120|
000078  4a1a              LDR      r2,|L4.228|
00007a  3278              ADDS     r2,r2,#0x78           ;157
00007c  4290              CMP      r0,r2                 ;157
00007e  d103              BNE      |L4.136|
000080  6848              LDR      r0,[r1,#4]            ;160
000082  f0406070          ORR      r0,r0,#0xf000000      ;160
000086  e7d5              B        |L4.52|
                  |L4.136|
000088  4a17              LDR      r2,|L4.232|
00008a  4290              CMP      r0,r2                 ;162
00008c  d104              BNE      |L4.152|
00008e  f8d10404          LDR      r0,[r1,#0x404]        ;165
000092  f040000f          ORR      r0,r0,#0xf            ;165
000096  e007              B        |L4.168|
                  |L4.152|
000098  4a13              LDR      r2,|L4.232|
00009a  3214              ADDS     r2,r2,#0x14           ;167
00009c  4290              CMP      r0,r2                 ;167
00009e  d106              BNE      |L4.174|
0000a0  f8d10404          LDR      r0,[r1,#0x404]        ;170
0000a4  f04000f0          ORR      r0,r0,#0xf0           ;170
                  |L4.168|
0000a8  f8c10404          STR      r0,[r1,#0x404]        ;165
                  |L4.172|
0000ac  4770              BX       lr
                  |L4.174|
0000ae  4a0e              LDR      r2,|L4.232|
0000b0  3228              ADDS     r2,r2,#0x28           ;172
0000b2  4290              CMP      r0,r2                 ;172
0000b4  d104              BNE      |L4.192|
0000b6  f8d10404          LDR      r0,[r1,#0x404]        ;175
0000ba  f4406070          ORR      r0,r0,#0xf00          ;175
0000be  e7f3              B        |L4.168|
                  |L4.192|
0000c0  4a09              LDR      r2,|L4.232|
0000c2  323c              ADDS     r2,r2,#0x3c           ;177
0000c4  4290              CMP      r0,r2                 ;177
0000c6  d104              BNE      |L4.210|
0000c8  f8d10404          LDR      r0,[r1,#0x404]        ;180
0000cc  f4404070          ORR      r0,r0,#0xf000         ;180
0000d0  e7ea              B        |L4.168|
                  |L4.210|
0000d2  4a05              LDR      r2,|L4.232|
0000d4  3250              ADDS     r2,r2,#0x50           ;184
0000d6  4290              CMP      r0,r2                 ;184
0000d8  d1e8              BNE      |L4.172|
0000da  f8d10404          LDR      r0,[r1,#0x404]        ;187
0000de  f4402070          ORR      r0,r0,#0xf0000        ;187
0000e2  e7e1              B        |L4.168|
;;;191    
                          ENDP

                  |L4.228|
                          DCD      0x40020008
                  |L4.232|
                          DCD      0x40020408

                          AREA ||i.DMA_GetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_GetCurrDataCounter PROC
;;;369      */
;;;370    uint16_t DMA_GetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx)
000000  6840              LDR      r0,[r0,#4]
;;;371    {
;;;372      /* Check the parameters */
;;;373      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;374      /* Return the number of remaining data units for DMAy Channelx */
;;;375      return ((uint16_t)(DMAy_Channelx->CNDTR));
000002  b280              UXTH     r0,r0
;;;376    }
000004  4770              BX       lr
;;;377    
                          ENDP


                          AREA ||i.DMA_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetFlagStatus PROC
;;;431      */
;;;432    FlagStatus DMA_GetFlagStatus(uint32_t DMA_FLAG)
000000  4602              MOV      r2,r0
;;;433    {
;;;434      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;435      uint32_t tmpreg = 0;
;;;436      /* Check the parameters */
;;;437      assert_param(IS_DMA_GET_FLAG(DMA_FLAG));
;;;438    
;;;439      /* Calculate the used DMA */
;;;440      if ((DMA_FLAG & FLAG_Mask) != (uint32_t)RESET)
;;;441      {
;;;442        /* Get DMA2 ISR register value */
;;;443        tmpreg = DMA2->ISR ;
000004  4905              LDR      r1,|L6.28|
000006  00d3              LSLS     r3,r2,#3              ;440
000008  d502              BPL      |L6.16|
00000a  f8d11400          LDR      r1,[r1,#0x400]
00000e  e000              B        |L6.18|
                  |L6.16|
;;;444      }
;;;445      else
;;;446      {
;;;447        /* Get DMA1 ISR register value */
;;;448        tmpreg = DMA1->ISR ;
000010  6809              LDR      r1,[r1,#0]
                  |L6.18|
;;;449      }
;;;450    
;;;451      /* Check the status of the specified DMA flag */
;;;452      if ((tmpreg & DMA_FLAG) != (uint32_t)RESET)
000012  4211              TST      r1,r2
000014  d000              BEQ      |L6.24|
;;;453      {
;;;454        /* DMA_FLAG is set */
;;;455        bitstatus = SET;
000016  2001              MOVS     r0,#1
                  |L6.24|
;;;456      }
;;;457      else
;;;458      {
;;;459        /* DMA_FLAG is reset */
;;;460        bitstatus = RESET;
;;;461      }
;;;462      
;;;463      /* Return the DMA_FLAG status */
;;;464      return  bitstatus;
;;;465    }
000018  4770              BX       lr
;;;466    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      0x40020000

                          AREA ||i.DMA_GetITStatus||, CODE, READONLY, ALIGN=2

                  DMA_GetITStatus PROC
;;;592      */
;;;593    ITStatus DMA_GetITStatus(uint32_t DMA_IT)
000000  4602              MOV      r2,r0
;;;594    {
;;;595      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;596      uint32_t tmpreg = 0;
;;;597      /* Check the parameters */
;;;598      assert_param(IS_DMA_GET_IT(DMA_IT));
;;;599    
;;;600      /* Calculate the used DMA */
;;;601      if ((DMA_IT & FLAG_Mask) != (uint32_t)RESET)
;;;602      {
;;;603        /* Get DMA2 ISR register value */
;;;604        tmpreg = DMA2->ISR ;
000004  4905              LDR      r1,|L7.28|
000006  00d3              LSLS     r3,r2,#3              ;601
000008  d502              BPL      |L7.16|
00000a  f8d11400          LDR      r1,[r1,#0x400]
00000e  e000              B        |L7.18|
                  |L7.16|
;;;605      }
;;;606      else
;;;607      {
;;;608        /* Get DMA1 ISR register value */
;;;609        tmpreg = DMA1->ISR ;
000010  6809              LDR      r1,[r1,#0]
                  |L7.18|
;;;610      }
;;;611    
;;;612      /* Check the status of the specified DMA interrupt */
;;;613      if ((tmpreg & DMA_IT) != (uint32_t)RESET)
000012  4211              TST      r1,r2
000014  d000              BEQ      |L7.24|
;;;614      {
;;;615        /* DMA_IT is set */
;;;616        bitstatus = SET;
000016  2001              MOVS     r0,#1
                  |L7.24|
;;;617      }
;;;618      else
;;;619      {
;;;620        /* DMA_IT is reset */
;;;621        bitstatus = RESET;
;;;622      }
;;;623      /* Return the DMA_IT status */
;;;624      return  bitstatus;
;;;625    }
000018  4770              BX       lr
;;;626    
                          ENDP

00001a  0000              DCW      0x0000
                  |L7.28|
                          DCD      0x40020000

                          AREA ||i.DMA_ITConfig||, CODE, READONLY, ALIGN=1

                  DMA_ITConfig PROC
;;;324      */
;;;325    void DMA_ITConfig(DMA_Channel_TypeDef* DMAy_Channelx, uint32_t DMA_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;326    {
;;;327      /* Check the parameters */
;;;328      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;329      assert_param(IS_DMA_CONFIG_IT(DMA_IT));
;;;330      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;331      if (NewState != DISABLE)
;;;332      {
;;;333        /* Enable the selected DMA interrupts */
;;;334        DMAy_Channelx->CCR |= DMA_IT;
;;;335      }
;;;336      else
;;;337      {
;;;338        /* Disable the selected DMA interrupts */
;;;339        DMAy_Channelx->CCR &= ~DMA_IT;
000002  6802              LDR      r2,[r0,#0]
000004  d001              BEQ      |L8.10|
000006  430a              ORRS     r2,r2,r1              ;334
000008  e000              B        |L8.12|
                  |L8.10|
00000a  438a              BICS     r2,r2,r1
                  |L8.12|
00000c  6002              STR      r2,[r0,#0]            ;334
;;;340      }
;;;341    }
00000e  4770              BX       lr
;;;342    
                          ENDP


                          AREA ||i.DMA_Init||, CODE, READONLY, ALIGN=1

                  DMA_Init PROC
;;;200      */
;;;201    void DMA_Init(DMA_Channel_TypeDef* DMAy_Channelx, DMA_InitTypeDef* DMA_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;202    {
;;;203      uint32_t tmpreg = 0;
;;;204    
;;;205      /* Check the parameters */
;;;206      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;207      assert_param(IS_DMA_DIR(DMA_InitStruct->DMA_DIR));
;;;208      assert_param(IS_DMA_BUFFER_SIZE(DMA_InitStruct->DMA_BufferSize));
;;;209      assert_param(IS_DMA_PERIPHERAL_INC_STATE(DMA_InitStruct->DMA_PeripheralInc));
;;;210      assert_param(IS_DMA_MEMORY_INC_STATE(DMA_InitStruct->DMA_MemoryInc));   
;;;211      assert_param(IS_DMA_PERIPHERAL_DATA_SIZE(DMA_InitStruct->DMA_PeripheralDataSize));
;;;212      assert_param(IS_DMA_MEMORY_DATA_SIZE(DMA_InitStruct->DMA_MemoryDataSize));
;;;213      assert_param(IS_DMA_MODE(DMA_InitStruct->DMA_Mode));
;;;214      assert_param(IS_DMA_PRIORITY(DMA_InitStruct->DMA_Priority));
;;;215      assert_param(IS_DMA_M2M_STATE(DMA_InitStruct->DMA_M2M));
;;;216    
;;;217    /*--------------------------- DMAy Channelx CCR Configuration -----------------*/
;;;218      /* Get the DMAy_Channelx CCR value */
;;;219      tmpreg = DMAy_Channelx->CCR;
000002  6803              LDR      r3,[r0,#0]
;;;220      /* Clear MEM2MEM, PL, MSIZE, PSIZE, MINC, PINC, CIRC and DIR bits */
;;;221      tmpreg &= CCR_CLEAR_Mask;
000004  f64772f0          MOV      r2,#0x7ff0
000008  4393              BICS     r3,r3,r2
;;;222      /* Configure DMAy Channelx: data transfer, data size, priority level and mode */
;;;223      /* Set DIR bit according to DMA_DIR value */
;;;224      /* Set CIRC bit according to DMA_Mode value */
;;;225      /* Set PINC bit according to DMA_PeripheralInc value */
;;;226      /* Set MINC bit according to DMA_MemoryInc value */
;;;227      /* Set PSIZE bits according to DMA_PeripheralDataSize value */
;;;228      /* Set MSIZE bits according to DMA_MemoryDataSize value */
;;;229      /* Set PL bits according to DMA_Priority value */
;;;230      /* Set the MEM2MEM bit according to DMA_M2M value */
;;;231      tmpreg |= DMA_InitStruct->DMA_DIR | DMA_InitStruct->DMA_Mode |
00000a  6a0c              LDR      r4,[r1,#0x20]
00000c  688a              LDR      r2,[r1,#8]
00000e  4322              ORRS     r2,r2,r4
000010  e9d14504          LDRD     r4,r5,[r1,#0x10]
000014  432c              ORRS     r4,r4,r5
000016  4322              ORRS     r2,r2,r4
000018  698c              LDR      r4,[r1,#0x18]
00001a  4322              ORRS     r2,r2,r4
00001c  69cc              LDR      r4,[r1,#0x1c]
00001e  4322              ORRS     r2,r2,r4
000020  6a4c              LDR      r4,[r1,#0x24]
000022  4322              ORRS     r2,r2,r4
000024  6a8c              LDR      r4,[r1,#0x28]
000026  4322              ORRS     r2,r2,r4
000028  431a              ORRS     r2,r2,r3
;;;232                DMA_InitStruct->DMA_PeripheralInc | DMA_InitStruct->DMA_MemoryInc |
;;;233                DMA_InitStruct->DMA_PeripheralDataSize | DMA_InitStruct->DMA_MemoryDataSize |
;;;234                DMA_InitStruct->DMA_Priority | DMA_InitStruct->DMA_M2M;
;;;235    
;;;236      /* Write to DMAy Channelx CCR */
;;;237      DMAy_Channelx->CCR = tmpreg;
00002a  6002              STR      r2,[r0,#0]
;;;238    
;;;239    /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
;;;240      /* Write to DMAy Channelx CNDTR */
;;;241      DMAy_Channelx->CNDTR = DMA_InitStruct->DMA_BufferSize;
00002c  68ca              LDR      r2,[r1,#0xc]
00002e  6042              STR      r2,[r0,#4]
;;;242    
;;;243    /*--------------------------- DMAy Channelx CPAR Configuration ----------------*/
;;;244      /* Write to DMAy Channelx CPAR */
;;;245      DMAy_Channelx->CPAR = DMA_InitStruct->DMA_PeripheralBaseAddr;
000030  680a              LDR      r2,[r1,#0]
000032  6082              STR      r2,[r0,#8]
;;;246    
;;;247    /*--------------------------- DMAy Channelx CMAR Configuration ----------------*/
;;;248      /* Write to DMAy Channelx CMAR */
;;;249      DMAy_Channelx->CMAR = DMA_InitStruct->DMA_MemoryBaseAddr;
000034  6849              LDR      r1,[r1,#4]
000036  60c1              STR      r1,[r0,#0xc]
;;;250    }
000038  bd30              POP      {r4,r5,pc}
;;;251    
                          ENDP


                          AREA ||i.DMA_SetCurrDataCounter||, CODE, READONLY, ALIGN=1

                  DMA_SetCurrDataCounter PROC
;;;351      */
;;;352    void DMA_SetCurrDataCounter(DMA_Channel_TypeDef* DMAy_Channelx, uint16_t DataNumber)
000000  6041              STR      r1,[r0,#4]
;;;353    {
;;;354      /* Check the parameters */
;;;355      assert_param(IS_DMA_ALL_PERIPH(DMAy_Channelx));
;;;356      
;;;357    /*--------------------------- DMAy Channelx CNDTR Configuration ---------------*/
;;;358      /* Write to DMAy Channelx CNDTR */
;;;359      DMAy_Channelx->CNDTR = DataNumber;  
;;;360    }
000002  4770              BX       lr
;;;361    
                          ENDP


                          AREA ||i.DMA_StructInit||, CODE, READONLY, ALIGN=1

                  DMA_StructInit PROC
;;;257      */
;;;258    void DMA_StructInit(DMA_InitTypeDef* DMA_InitStruct)
000000  2100              MOVS     r1,#0
;;;259    {
;;;260    /*-------------- Reset DMA init structure parameters values ------------------*/
;;;261      /* Initialize the DMA_PeripheralBaseAddr member */
;;;262      DMA_InitStruct->DMA_PeripheralBaseAddr = 0;
;;;263      /* Initialize the DMA_MemoryBaseAddr member */
;;;264      DMA_InitStruct->DMA_MemoryBaseAddr = 0;
000002  6001              STR      r1,[r0,#0]
;;;265      /* Initialize the DMA_DIR member */
;;;266      DMA_InitStruct->DMA_DIR = DMA_DIR_PeripheralSRC;
000004  6041              STR      r1,[r0,#4]
;;;267      /* Initialize the DMA_BufferSize member */
;;;268      DMA_InitStruct->DMA_BufferSize = 0;
000006  6081              STR      r1,[r0,#8]
;;;269      /* Initialize the DMA_PeripheralInc member */
;;;270      DMA_InitStruct->DMA_PeripheralInc = DMA_PeripheralInc_Disable;
000008  60c1              STR      r1,[r0,#0xc]
;;;271      /* Initialize the DMA_MemoryInc member */
;;;272      DMA_InitStruct->DMA_MemoryInc = DMA_MemoryInc_Disable;
00000a  6101              STR      r1,[r0,#0x10]
;;;273      /* Initialize the DMA_PeripheralDataSize member */
;;;274      DMA_InitStruct->DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;
00000c  6141              STR      r1,[r0,#0x14]
;;;275      /* Initialize the DMA_MemoryDataSize member */
;;;276      DMA_InitStruct->DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
00000e  6181              STR      r1,[r0,#0x18]
;;;277      /* Initialize the DMA_Mode member */
;;;278      DMA_InitStruct->DMA_Mode = DMA_Mode_Normal;
000010  61c1              STR      r1,[r0,#0x1c]
;;;279      /* Initialize the DMA_Priority member */
;;;280      DMA_InitStruct->DMA_Priority = DMA_Priority_Low;
000012  6201              STR      r1,[r0,#0x20]
;;;281      /* Initialize the DMA_M2M member */
;;;282      DMA_InitStruct->DMA_M2M = DMA_M2M_Disable;
000014  6241              STR      r1,[r0,#0x24]
000016  6281              STR      r1,[r0,#0x28]
;;;283    }
000018  4770              BX       lr
;;;284    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_dma.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_dma_c_e9b554c0____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_dma_c_e9b554c0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_dma_c_e9b554c0____REVSH|
#line 128
|__asm___15_stm32f10x_dma_c_e9b554c0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
