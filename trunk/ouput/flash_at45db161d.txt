; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\flash_at45db161d.o --depend=.\ouput\flash_at45db161d.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\flash_at45db161d.crf Source\APP\flash_AT45DB161D.c]
                          THUMB

                          AREA ||i.BUFFER_Read||, CODE, READONLY, ALIGN=2

                  BUFFER_Read PROC
;;;121    */
;;;122    void BUFFER_Read(SPI_TypeDef *SPIx ,uint8_t buf_num, uint16_t addr,uint8_t *spi_data, uint16_t spi_data_num)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;123    {
;;;124        uint16_t i;
;;;125    	SPIcs_Reset();
000004  f8df8058          LDR      r8,|L1.96|
000008  4681              MOV      r9,r0                 ;123
00000a  460f              MOV      r7,r1                 ;123
00000c  4614              MOV      r4,r2                 ;123
00000e  461d              MOV      r5,r3                 ;123
000010  2108              MOVS     r1,#8
000012  4640              MOV      r0,r8
000014  9e08              LDR      r6,[sp,#0x20]
000016  f7fffffe          BL       GPIO_ResetBits
;;;126    	SPI_WrRd_byte(SPIx, buf_num );
00001a  4639              MOV      r1,r7
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       SPI_WrRd_byte
;;;127    	SPI_WrRd_byte(SPIx,  0x00 );
000022  2100              MOVS     r1,#0
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       SPI_WrRd_byte
;;;128    	SPI_WrRd_byte(SPIx,  (uint8_t)(addr>>8) );
00002a  0a21              LSRS     r1,r4,#8
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       SPI_WrRd_byte
;;;129    	SPI_WrRd_byte(SPIx,  (uint8_t)(addr) );
000032  b2e1              UXTB     r1,r4
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       SPI_WrRd_byte
;;;130    #if DUMMY_BYTE == 1
;;;131    	SPI_WrRd_byte(SPIx,  0x00 );
;;;132    #endif
;;;133    	for(i = 0; i < spi_data_num; i++)
00003a  2400              MOVS     r4,#0
00003c  e007              B        |L1.78|
                  |L1.62|
;;;134    	{
;;;135    		*spi_data++ = SPI_WrRd_byte(SPIx, 0x00);	
00003e  2100              MOVS     r1,#0
000040  4648              MOV      r0,r9
000042  f7fffffe          BL       SPI_WrRd_byte
000046  1c64              ADDS     r4,r4,#1              ;133
000048  f8050b01          STRB     r0,[r5],#1
00004c  b2a4              UXTH     r4,r4                 ;133
                  |L1.78|
00004e  42b4              CMP      r4,r6                 ;133
000050  d3f5              BCC      |L1.62|
;;;136    	}
;;;137        SPIcs_Set();
000052  4640              MOV      r0,r8
000054  e8bd47f0          POP      {r4-r10,lr}
000058  2108              MOVS     r1,#8
00005a  f7ffbffe          B.W      GPIO_SetBits
;;;138    }
;;;139    
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      0x40011800

                          AREA ||i.BUFFER_Write||, CODE, READONLY, ALIGN=2

                  BUFFER_Write PROC
;;;98     */
;;;99     void BUFFER_Write(SPI_TypeDef *SPIx ,uint8_t buf_num, uint16_t addr, uint8_t *spi_data, uint16_t spi_data_num)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;100    {
;;;101        uint16_t i;
;;;102    	SPIcs_Reset();
000004  f8df8054          LDR      r8,|L2.92|
000008  4681              MOV      r9,r0                 ;100
00000a  460f              MOV      r7,r1                 ;100
00000c  4614              MOV      r4,r2                 ;100
00000e  461d              MOV      r5,r3                 ;100
000010  2108              MOVS     r1,#8
000012  4640              MOV      r0,r8
000014  9e08              LDR      r6,[sp,#0x20]
000016  f7fffffe          BL       GPIO_ResetBits
;;;103    	SPI_WrRd_byte(SPIx, buf_num);
00001a  4639              MOV      r1,r7
00001c  4648              MOV      r0,r9
00001e  f7fffffe          BL       SPI_WrRd_byte
;;;104    	SPI_WrRd_byte(SPIx, 0x00);
000022  2100              MOVS     r1,#0
000024  4648              MOV      r0,r9
000026  f7fffffe          BL       SPI_WrRd_byte
;;;105    	SPI_WrRd_byte(SPIx, (uint8_t)(addr>>8));
00002a  0a21              LSRS     r1,r4,#8
00002c  4648              MOV      r0,r9
00002e  f7fffffe          BL       SPI_WrRd_byte
;;;106    	SPI_WrRd_byte(SPIx, (uint8_t)addr);
000032  b2e1              UXTB     r1,r4
000034  4648              MOV      r0,r9
000036  f7fffffe          BL       SPI_WrRd_byte
;;;107    	for(i = 0; i < spi_data_num; i++)
00003a  2400              MOVS     r4,#0
00003c  e006              B        |L2.76|
                  |L2.62|
;;;108    	{
;;;109    		SPI_WrRd_byte(SPIx, *spi_data++);	
00003e  f8151b01          LDRB     r1,[r5],#1
000042  4648              MOV      r0,r9
000044  f7fffffe          BL       SPI_WrRd_byte
000048  1c64              ADDS     r4,r4,#1              ;107
00004a  b2a4              UXTH     r4,r4                 ;107
                  |L2.76|
00004c  42b4              CMP      r4,r6                 ;107
00004e  d3f6              BCC      |L2.62|
;;;110    	}
;;;111        SPIcs_Set();
000050  4640              MOV      r0,r8
000052  e8bd47f0          POP      {r4-r10,lr}
000056  2108              MOVS     r1,#8
000058  f7ffbffe          B.W      GPIO_SetBits
;;;112    }
;;;113    
                          ENDP

                  |L2.92|
                          DCD      0x40011800

                          AREA ||i.BufToMainMemPage||, CODE, READONLY, ALIGN=2

                  BufToMainMemPage PROC
;;;145    */
;;;146    Error_status BufToMainMemPage(SPI_TypeDef *SPIx,uint8_t buf_Erase, uint16_t Pageaddr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;147    {
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
000008  4606              MOV      r6,r0
;;;148        uint8_t temp;
;;;149        if(Pageaddr >= MAX_PAGE)   
00000a  f5b25f80          CMP      r2,#0x1000
00000e  d302              BCC      |L3.22|
;;;150    	{
;;;151    		return PageOver;
000010  2001              MOVS     r0,#1
                  |L3.18|
;;;152    	}
;;;153    	FlashWaitBusy(SPIx);
;;;154    	SPIcs_Reset();
;;;155    	SPI_WrRd_byte(SPIx, buf_Erase);
;;;156    	temp = (uint8_t)(Pageaddr >> 6); //高6位(page_addr的最高4位不用)
;;;157    	SPI_WrRd_byte(SPIx, temp);
;;;158    	temp = (uint8_t)(Pageaddr << 2); //低6位(page_addr的最高4位不用)
;;;159    	SPI_WrRd_byte(SPIx, temp);
;;;160    
;;;161    	SPI_WrRd_byte(SPIx, 0x00);        //无用位
;;;162    	SPIcs_Set();
;;;163    	FlashWaitBusy(SPIx);
;;;164    	return OP_OK;
;;;165    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L3.22|
000016  f7fffffe          BL       FlashWaitBusy
00001a  4d10              LDR      r5,|L3.92|
00001c  2108              MOVS     r1,#8                 ;154
00001e  4628              MOV      r0,r5                 ;154
000020  f7fffffe          BL       GPIO_ResetBits
000024  4639              MOV      r1,r7                 ;155
000026  4630              MOV      r0,r6                 ;155
000028  f7fffffe          BL       SPI_WrRd_byte
00002c  f3c41187          UBFX     r1,r4,#6,#8           ;156
000030  4630              MOV      r0,r6                 ;157
000032  f7fffffe          BL       SPI_WrRd_byte
000036  06a0              LSLS     r0,r4,#26             ;158
000038  0e01              LSRS     r1,r0,#24             ;158
00003a  4630              MOV      r0,r6                 ;159
00003c  f7fffffe          BL       SPI_WrRd_byte
000040  2100              MOVS     r1,#0                 ;161
000042  4630              MOV      r0,r6                 ;161
000044  f7fffffe          BL       SPI_WrRd_byte
000048  2108              MOVS     r1,#8                 ;162
00004a  4628              MOV      r0,r5                 ;162
00004c  f7fffffe          BL       GPIO_SetBits
000050  4630              MOV      r0,r6                 ;163
000052  f7fffffe          BL       FlashWaitBusy
000056  2000              MOVS     r0,#0                 ;164
000058  e7db              B        |L3.18|
;;;166    
                          ENDP

00005a  0000              DCW      0x0000
                  |L3.92|
                          DCD      0x40011800

                          AREA ||i.FlashWaitBusy||, CODE, READONLY, ALIGN=2

                  FlashWaitBusy PROC
;;;255    */
;;;256    void FlashWaitBusy(SPI_TypeDef *SPIx)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
;;;258    	unsigned char state_reg=0x00;
;;;259    	SPIcs_Reset();
000002  4d0c              LDR      r5,|L4.52|
000004  4606              MOV      r6,r0                 ;257
000006  2400              MOVS     r4,#0                 ;258
000008  2108              MOVS     r1,#8
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       GPIO_ResetBits
;;;260    	SPI_WrRd_byte(SPIx, 0xD7);
000010  21d7              MOVS     r1,#0xd7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       SPI_WrRd_byte
;;;261    	while((state_reg&0x80) == 0)
000018  e004              B        |L4.36|
                  |L4.26|
;;;262    	{		
;;;263    		state_reg = SPI_WrRd_byte(SPIx,0x00);// SPI_Flash_ReadByte();
00001a  2100              MOVS     r1,#0
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       SPI_WrRd_byte
000022  4604              MOV      r4,r0
                  |L4.36|
000024  0620              LSLS     r0,r4,#24             ;261
000026  d5f8              BPL      |L4.26|
;;;264    	//	state_reg = SPI_WrRd_byte(SPIx,0x00);
;;;265    	}
;;;266    	SPIcs_Set();
000028  4628              MOV      r0,r5
00002a  e8bd4070          POP      {r4-r6,lr}
00002e  2108              MOVS     r1,#8
000030  f7ffbffe          B.W      GPIO_SetBits
;;;267    	
;;;268    }
;;;269    
                          ENDP

                  |L4.52|
                          DCD      0x40011800

                          AREA ||i.MMemPageRead||, CODE, READONLY, ALIGN=2

                  MMemPageRead PROC
;;;189    
;;;190    Error_status MMemPageRead(SPI_TypeDef *SPIx,uint16_t Pageaddr, uint16_t Byteaddr ,uint8_t *data_buf, uint16_t data_num)//pdf p7 p28
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;191    {
000004  4681              MOV      r9,r0
;;;192    	uint16_t i;
;;;193    	if(Pageaddr >= MAX_PAGE)         
000006  9e08              LDR      r6,[sp,#0x20]
000008  460c              MOV      r4,r1                 ;191
00000a  4617              MOV      r7,r2                 ;191
00000c  461d              MOV      r5,r3                 ;191
00000e  f5b15f80          CMP      r1,#0x1000
000012  d302              BCC      |L5.26|
;;;194    	{
;;;195    		return PageOver;
000014  2001              MOVS     r0,#1
                  |L5.22|
;;;196    	}
;;;197    	if(Byteaddr >= MAX_BYTE_PAGE)	 
;;;198    	{
;;;199    		return ByteOver;
;;;200    	}
;;;201    	if(data_num >  MAX_BYTE_PAGE)	 
;;;202    	{
;;;203    		return  ReadByteOver;
;;;204    	}
;;;205    	FlashWaitBusy(SPIx);
;;;206    	SPIcs_Reset();
;;;207    	SPI_WrRd_byte(SPIx, 0xd2);	 //opcode
;;;208    	SPI_WrRd_byte(SPIx, (uint8_t)(Pageaddr>>6));	 //高6位(page_addr的最高2位不用)
;;;209    	SPI_WrRd_byte(SPIx, (uint8_t)((Pageaddr << 2)|(Byteaddr >> 8)&0x3)); //低6位ageaddr 高2位byteaddr
;;;210    	SPI_WrRd_byte(SPIx, (uint8_t)Byteaddr);	//低8位byteaddr
;;;211    
;;;212    	for(i =0 ;i < 4;i++)
;;;213    	{
;;;214    		SPI_WrRd_byte(SPIx, 0x00);        //4 dummy bytes
;;;215    	}
;;;216    	for(i = 0; i<data_num; i++)
;;;217    	{
;;;218    		*data_buf++ = SPI_WrRd_byte(SPIx, 0x00);
;;;219    	}
;;;220    	SPIcs_Set();
;;;221    	FlashWaitBusy(SPIx);
;;;222    	return OP_OK;	
;;;223    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L5.26|
00001a  f44f7004          MOV      r0,#0x210             ;197
00001e  4287              CMP      r7,r0                 ;197
000020  d301              BCC      |L5.38|
000022  2002              MOVS     r0,#2                 ;199
000024  e7f7              B        |L5.22|
                  |L5.38|
000026  4286              CMP      r6,r0                 ;201
000028  d901              BLS      |L5.46|
00002a  2003              MOVS     r0,#3                 ;203
00002c  e7f3              B        |L5.22|
                  |L5.46|
00002e  4648              MOV      r0,r9                 ;205
000030  f7fffffe          BL       FlashWaitBusy
000034  f8df8070          LDR      r8,|L5.168|
000038  2108              MOVS     r1,#8                 ;206
00003a  4640              MOV      r0,r8                 ;206
00003c  f7fffffe          BL       GPIO_ResetBits
000040  21d2              MOVS     r1,#0xd2              ;207
000042  4648              MOV      r0,r9                 ;207
000044  f7fffffe          BL       SPI_WrRd_byte
000048  f3c41187          UBFX     r1,r4,#6,#8           ;208
00004c  4648              MOV      r0,r9                 ;208
00004e  f7fffffe          BL       SPI_WrRd_byte
000052  f3c72001          UBFX     r0,r7,#8,#2           ;209
000056  ea400084          ORR      r0,r0,r4,LSL #2       ;209
00005a  b2c1              UXTB     r1,r0                 ;209
00005c  4648              MOV      r0,r9                 ;209
00005e  f7fffffe          BL       SPI_WrRd_byte
000062  b2f9              UXTB     r1,r7                 ;210
000064  4648              MOV      r0,r9                 ;210
000066  f7fffffe          BL       SPI_WrRd_byte
00006a  2400              MOVS     r4,#0                 ;212
                  |L5.108|
00006c  2100              MOVS     r1,#0                 ;214
00006e  4648              MOV      r0,r9                 ;214
000070  f7fffffe          BL       SPI_WrRd_byte
000074  1c64              ADDS     r4,r4,#1              ;212
000076  b2a4              UXTH     r4,r4                 ;212
000078  2c04              CMP      r4,#4                 ;212
00007a  d3f7              BCC      |L5.108|
00007c  2400              MOVS     r4,#0                 ;216
00007e  e007              B        |L5.144|
                  |L5.128|
000080  2100              MOVS     r1,#0                 ;218
000082  4648              MOV      r0,r9                 ;218
000084  f7fffffe          BL       SPI_WrRd_byte
000088  1c64              ADDS     r4,r4,#1              ;216
00008a  f8050b01          STRB     r0,[r5],#1            ;218
00008e  b2a4              UXTH     r4,r4                 ;216
                  |L5.144|
000090  42b4              CMP      r4,r6                 ;216
000092  d3f5              BCC      |L5.128|
000094  2108              MOVS     r1,#8                 ;220
000096  4640              MOV      r0,r8                 ;220
000098  f7fffffe          BL       GPIO_SetBits
00009c  4648              MOV      r0,r9                 ;221
00009e  f7fffffe          BL       FlashWaitBusy
0000a2  2000              MOVS     r0,#0                 ;222
0000a4  e7b7              B        |L5.22|
;;;224    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L5.168|
                          DCD      0x40011800

                          AREA ||i.MemPageToBUFF||, CODE, READONLY, ALIGN=2

                  MemPageToBUFF PROC
;;;227    */
;;;228    Error_status MemPageToBUFF(SPI_TypeDef *SPIx,uint8_t buffer_num,uint16_t Pageaddr)//pdf p19 p37
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;229    {
000004  460f              MOV      r7,r1
000006  4614              MOV      r4,r2
000008  4606              MOV      r6,r0
;;;230    	if(Pageaddr >= MAX_PAGE)         
00000a  f5b25f80          CMP      r2,#0x1000
00000e  d302              BCC      |L6.22|
;;;231    	{
;;;232    		return PageOver;
000010  2001              MOVS     r0,#1
                  |L6.18|
;;;233    	}
;;;234    	FlashWaitBusy(SPIx);
;;;235    	SPIcs_Reset();
;;;236    	SPI_WrRd_byte(SPIx, buffer_num);	 //opcode
;;;237    	SPI_WrRd_byte(SPIx, (uint8_t)(Pageaddr >>6));	 //高6位(page_addr的最高2位不用)
;;;238    	SPI_WrRd_byte(SPIx, (uint8_t)(Pageaddr << 2));    //低6位ageaddr 
;;;239    	SPI_WrRd_byte(SPIx, 0x00);        //1 dummy bytes
;;;240    	SPIcs_Set();
;;;241    	FlashWaitBusy(SPIx);
;;;242    	return OP_OK;	
;;;243    }
000012  e8bd81f0          POP      {r4-r8,pc}
                  |L6.22|
000016  f7fffffe          BL       FlashWaitBusy
00001a  4d10              LDR      r5,|L6.92|
00001c  2108              MOVS     r1,#8                 ;235
00001e  4628              MOV      r0,r5                 ;235
000020  f7fffffe          BL       GPIO_ResetBits
000024  4639              MOV      r1,r7                 ;236
000026  4630              MOV      r0,r6                 ;236
000028  f7fffffe          BL       SPI_WrRd_byte
00002c  f3c41187          UBFX     r1,r4,#6,#8           ;237
000030  4630              MOV      r0,r6                 ;237
000032  f7fffffe          BL       SPI_WrRd_byte
000036  06a0              LSLS     r0,r4,#26             ;238
000038  0e01              LSRS     r1,r0,#24             ;238
00003a  4630              MOV      r0,r6                 ;238
00003c  f7fffffe          BL       SPI_WrRd_byte
000040  2100              MOVS     r1,#0                 ;239
000042  4630              MOV      r0,r6                 ;239
000044  f7fffffe          BL       SPI_WrRd_byte
000048  2108              MOVS     r1,#8                 ;240
00004a  4628              MOV      r0,r5                 ;240
00004c  f7fffffe          BL       GPIO_SetBits
000050  4630              MOV      r0,r6                 ;241
000052  f7fffffe          BL       FlashWaitBusy
000056  2000              MOVS     r0,#0                 ;242
000058  e7db              B        |L6.18|
;;;244    /*
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
                          DCD      0x40011800

                          AREA ||i.SPI_WrRd_byte||, CODE, READONLY, ALIGN=1

                  SPI_WrRd_byte PROC
;;;82     */
;;;83     uint8_t SPI_WrRd_byte(SPI_TypeDef *SPIx,uint8_t spi_send)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
                  |L7.6|
;;;85     	while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE) == RESET);
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L7.6|
;;;86     	SPI_I2S_SendData(SPIx,spi_send);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_I2S_SendData
                  |L7.26|
;;;87     //	while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_TXE) == RESET);
;;;88     	while (SPI_I2S_GetFlagStatus(SPIx, SPI_I2S_FLAG_RXNE) == RESET);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L7.26|
;;;89     	return((uint8_t)SPI_I2S_ReceiveData(SPIx));
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c0              UXTB     r0,r0
;;;90     }
00002e  bd70              POP      {r4-r6,pc}
;;;91     /**************************************
                          ENDP


                          AREA ||i.page_erase||, CODE, READONLY, ALIGN=2

                  page_erase PROC
;;;273    */
;;;274    Error_status page_erase(SPI_TypeDef *SPIx, uint16_t pageaddr)
000000  b570              PUSH     {r4-r6,lr}
;;;275    {
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;276        if(pageaddr >= MAX_PAGE) return PageOver;
000006  f5b15f80          CMP      r1,#0x1000
00000a  d301              BCC      |L8.16|
00000c  2001              MOVS     r0,#1
;;;277    	FlashWaitBusy(SPIx);
;;;278    	SPIcs_Reset();
;;;279    	SPI_WrRd_byte(SPIx,PAGE_ERASE);
;;;280    	SPI_WrRd_byte(SPIx,(u8)(pageaddr >> 6));
;;;281    	SPI_WrRd_byte(SPIx,(u8)(pageaddr << 2));
;;;282    	SPI_WrRd_byte(SPIx,0x00);	//Dummy byte
;;;283    	//|-23-|-22-|21|20|19|18|17|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|0|
;;;284    	//|2个无关位|------------12位页地址-------------|----10个无关位-----|
;;;285    	SPIcs_Set();
;;;286    	return OP_OK;
;;;287    }
00000e  bd70              POP      {r4-r6,pc}
                  |L8.16|
000010  f7fffffe          BL       FlashWaitBusy
000014  4d0e              LDR      r5,|L8.80|
000016  2108              MOVS     r1,#8                 ;278
000018  4628              MOV      r0,r5                 ;278
00001a  f7fffffe          BL       GPIO_ResetBits
00001e  2181              MOVS     r1,#0x81              ;279
000020  4630              MOV      r0,r6                 ;279
000022  f7fffffe          BL       SPI_WrRd_byte
000026  f3c41187          UBFX     r1,r4,#6,#8           ;280
00002a  4630              MOV      r0,r6                 ;280
00002c  f7fffffe          BL       SPI_WrRd_byte
000030  06a0              LSLS     r0,r4,#26             ;281
000032  0e01              LSRS     r1,r0,#24             ;281
000034  4630              MOV      r0,r6                 ;281
000036  f7fffffe          BL       SPI_WrRd_byte
00003a  2100              MOVS     r1,#0                 ;282
00003c  4630              MOV      r0,r6                 ;282
00003e  f7fffffe          BL       SPI_WrRd_byte
000042  2108              MOVS     r1,#8                 ;285
000044  4628              MOV      r0,r5                 ;285
000046  f7fffffe          BL       GPIO_SetBits
00004a  2000              MOVS     r0,#0                 ;286
00004c  bd70              POP      {r4-r6,pc}
;;;288    
                          ENDP

00004e  0000              DCW      0x0000
                  |L8.80|
                          DCD      0x40011800

                          AREA ||i.spi_at45db161d_initial||, CODE, READONLY, ALIGN=1

                  spi_at45db161d_initial PROC
;;;7      ****************************/
;;;8      void spi_at45db161d_initial(void)//bsp.c中定义		使用spi3
000000  4770              BX       lr
;;;9      {
;;;10     	#if 0
;;;11         GPIO_InitTypeDef GPIO_InitStructure;
;;;12     	SPI_InitTypeDef  SPI_InitStructure;
;;;13     
;;;14      	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA|RCC_APB2Periph_GPIOB|RCC_APB2Periph_GPIOE|RCC_APB2Periph_AFIO, ENABLE);
;;;15     
;;;16     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1 , ENABLE);
;;;17     
;;;18     
;;;19         /* Configure SPI1 pins: SCK, MISO and MOSI */
;;;20         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 |  GPIO_Pin_7|GPIO_Pin_6;
;;;21         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;22         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;23         GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;24     
;;;25     	/*GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;//MISO
;;;26     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;27     	GPIO_Init(GPIOA, &GPIO_InitStructure); */
;;;28     	/*SPI1 pin: NSS*/
;;;29     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
;;;30         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
;;;31         GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;32         GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;33     
;;;34     
;;;35     	#if 0
;;;36           /* SPI_SLAVE_	Tx_DMA_Channel configuration ---------------------------------------------*/
;;;37     	{
;;;38     		DMA_InitTypeDef  DMA_InitStructure;
;;;39     		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
;;;40     		DMA_DeInit(DMA1_Channel3); //SPI_TX  / /通道选择
;;;41     	  	DMA_InitStructure.DMA_PeripheralBaseAddr =(uint32_t)(&SPI1->DR);//外设地址
;;;42     //	  	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)SPI1_Buffer_Tx; //数据地址
;;;43     	  	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralDST;	//数据方向
;;;44     //	  	DMA_InitStructure.DMA_BufferSize = BUFFER_SIZE;//数据量
;;;45     	  	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;   //外设地址变化
;;;46     	  	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;			 // 存储器地址变化
;;;47     	  	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;	// 外设传输数据宽度
;;;48     	  	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;		//存储器数据宽度
;;;49     	  	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;  //是否是循环模式
;;;50     	  	DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh;	//通道优先级
;;;51     	  	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;  //是否启动存储器到存储器模式
;;;52     	  	DMA_Init(DMA1_Channel3, &DMA_InitStructure);
;;;53     
;;;54     		//SPI_I2S_DMACmd(SPI1, SPI_I2S_DMAReq_Tx, ENABLE);
;;;55     	}
;;;56        #endif
;;;57     	SPI_Cmd(SPI1, DISABLE);
;;;58     	GPIO_SetBits(GPIOA, GPIO_Pin_4);
;;;59       	SPI_InitStructure.SPI_Direction =SPI_Direction_2Lines_FullDuplex; // SPI_Direction_1Line_Tx ;//
;;;60       	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
;;;61       	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
;;;62       	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;	//初始化为第一个上升沿开始发送	  //模式还可以设置为   SPI_CPOL_High /Low
;;;63       	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;				                  //模式还可以设置为    SPI_CPHA_2Edge/1Edge
;;;64       	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
;;;65       	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
;;;66       	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
;;;67       	SPI_InitStructure.SPI_CRCPolynomial = 7;
;;;68       	SPI_Init(SPI1, &SPI_InitStructure);
;;;69     	//SPI_I2S_DMACmd(SPI1, SPI_I2S_DMAReq_Tx, ENABLE);
;;;70       	/* Enable SPIy */
;;;71       	SPI_Cmd(SPI1, ENABLE);
;;;72     	  /* Enable DMA1 Channel5 */
;;;73        // DMA_Cmd(DMA1_Channel3, ENABLE);
;;;74     
;;;75      #endif
;;;76     }
;;;77     /******************************
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\APP\\flash_AT45DB161D.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_flash_AT45DB161D_c_c085ce10____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_flash_AT45DB161D_c_c085ce10____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___18_flash_AT45DB161D_c_c085ce10____REVSH|
#line 128
|__asm___18_flash_AT45DB161D_c_c085ce10____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
