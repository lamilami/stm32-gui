; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\rtc.o --depend=.\ouput\rtc.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\rtc.crf Source\BSP\rtc.c]
                          THUMB

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;83     
;;;84     unsigned char Is_Leap_Year(unsigned short year)		  //知道返回的值是多少
000000  0781              LSLS     r1,r0,#30
;;;85     {
;;;86         return((year%4==0)&&(year%100!=0)||(year%400==0));
000002  d105              BNE      |L1.16|
000004  2164              MOVS     r1,#0x64
000006  fbb0f2f1          UDIV     r2,r0,r1
00000a  fb010112          MLS      r1,r1,r2,r0
00000e  b941              CBNZ     r1,|L1.34|
                  |L1.16|
000010  f44f71c8          MOV      r1,#0x190
000014  fbb0f2f1          UDIV     r2,r0,r1
000018  fb010012          MLS      r0,r1,r2,r0
00001c  b108              CBZ      r0,|L1.34|
00001e  2000              MOVS     r0,#0
;;;87     }
000020  4770              BX       lr
                  |L1.34|
000022  2001              MOVS     r0,#1                 ;86
000024  4770              BX       lr
;;;88     
                          ENDP


                          AREA ||i.RTC_Check||, CODE, READONLY, ALIGN=2

                  RTC_Check PROC
;;;188    
;;;189    char RTC_Check(tim timer)
000000  b510              PUSH     {r4,lr}
;;;190    {
000002  4603              MOV      r3,r0
000004  b280              UXTH     r0,r0
;;;191       if(Is_Leap_Year(timer.year))
000006  f7fffffe          BL       Is_Leap_Year
00000a  0004              MOVS     r4,r0
;;;192        {
;;;193            if((timer.month == 2) && (timer.date >mon_table[timer.month-1]))
00000c  4808              LDR      r0,|L2.48|
00000e  f3c34107          UBFX     r1,r3,#16,#8          ;191
000012  ea4f6213          LSR      r2,r3,#24             ;191
000016  d004              BEQ      |L2.34|
000018  2902              CMP      r1,#2
00001a  d102              BNE      |L2.34|
00001c  5c0b              LDRB     r3,[r1,r0]
00001e  429a              CMP      r2,r3
000020  d802              BHI      |L2.40|
                  |L2.34|
;;;194             {
;;;195               return ERROR;
;;;196               // GUI_MessageBox("请输入正确的日期","error!!",0); 
;;;197             }
;;;198            else
;;;199            {
;;;200                if(timer.date > mon_table[timer.month-1])
000022  5c08              LDRB     r0,[r1,r0]
000024  4282              CMP      r2,r0
000026  d901              BLS      |L2.44|
                  |L2.40|
;;;201                {
;;;202                    return ERROR;
;;;203                  ///  GUI_MessageBox("请输入正确的日期","error!!",0); 
;;;204                }
;;;205            }   
;;;206         }
;;;207       else
;;;208        {
;;;209            if(timer.date > mon_table[timer.month-1])
;;;210             {
;;;211                return ERROR;
000028  2000              MOVS     r0,#0
;;;212               // GUI_MessageBox("请输入正确的日期","error!!",0); 
;;;213             }
;;;214            
;;;215        }
;;;216       return SUCCESS;
;;;217       
;;;218    }
00002a  bd10              POP      {r4,pc}
                  |L2.44|
00002c  2001              MOVS     r0,#1                 ;216
00002e  bd10              POP      {r4,pc}
;;;219    
                          ENDP

                  |L2.48|
                          DCD      ||.constdata||-0x1

                          AREA ||i.RTC_Config_Init||, CODE, READONLY, ALIGN=1

                  RTC_Config_Init PROC
;;;328    }
;;;329    void RTC_Config_Init(void)
000000  b510              PUSH     {r4,lr}
;;;330    {
;;;331        if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A1 )
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       BKP_ReadBackupRegister
000008  f24a54a1          MOV      r4,#0xa5a1
00000c  42a0              CMP      r0,r4
00000e  d00b              BEQ      |L3.40|
;;;332    	{
;;;333    	    RTC_Configuration(); 
000010  f7fffffe          BL       RTC_Configuration
;;;334    		RTC_WaitForLastTask();
000014  f7fffffe          BL       RTC_WaitForLastTask
;;;335    	//	RTC_SetCounter(Time_Regulate());		   	 	 
;;;336    	   // RTC_Set(2010,11,14,15,38,30);
;;;337    
;;;338    		RTC_WaitForLastTask(); 
000018  f7fffffe          BL       RTC_WaitForLastTask
;;;339    
;;;340    		BKP_WriteBackupRegister(BKP_DR1, 0xA5A1);
00001c  4621              MOV      r1,r4
00001e  e8bd4010          POP      {r4,lr}
000022  2004              MOVS     r0,#4
000024  f7ffbffe          B.W      BKP_WriteBackupRegister
                  |L3.40|
;;;341    	}
;;;342    	else
;;;343    	{
;;;344    		RTC_WaitForSynchro();        				
000028  f7fffffe          BL       RTC_WaitForSynchro
;;;345    													
;;;346    	 	RTC_WaitForLastTask();       				
00002c  f7fffffe          BL       RTC_WaitForLastTask
;;;347    																									 
;;;348         	RTC_ITConfig(RTC_IT_SEC, ENABLE);   		
000030  2101              MOVS     r1,#1
000032  4608              MOV      r0,r1
000034  f7fffffe          BL       RTC_ITConfig
;;;349    													
;;;350         	RTC_WaitForLastTask();
000038  e8bd4010          POP      {r4,lr}
00003c  f7ffbffe          B.W      RTC_WaitForLastTask
;;;351    	} 
;;;352    }
                          ENDP


                          AREA ||i.RTC_Configuration||, CODE, READONLY, ALIGN=1

                  RTC_Configuration PROC
;;;269    
;;;270    void RTC_Configuration(void)
000000  b510              PUSH     {r4,lr}
;;;271    {
;;;272    	/* Enable PWR and BKP clocks */
;;;273      	RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000002  2101              MOVS     r1,#1
000004  f04f50c0          MOV      r0,#0x18000000
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;274    
;;;275      	/* Allow access to BKP Domain */
;;;276      	PWR_BackupAccessCmd(ENABLE);
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       PWR_BackupAccessCmd
;;;277    
;;;278      	/* Reset Backup Domain */
;;;279      	BKP_DeInit();
000012  f7fffffe          BL       BKP_DeInit
;;;280    
;;;281    #ifdef RTCClockSource_LSI
;;;282      /* Enable LSI */ 
;;;283      RCC_LSICmd(ENABLE);
;;;284      /* Wait till LSI is ready */
;;;285      while(RCC_GetFlagStatus(RCC_FLAG_LSIRDY) == RESET)
;;;286      {
;;;287      }
;;;288    
;;;289      /* Select LSI as RTC Clock Source */
;;;290      RCC_RTCCLKConfig(RCC_RTCCLKSource_LSI);  
;;;291    #elif defined	RTCClockSource_LSE
;;;292      	/* Enable LSE */
;;;293      	RCC_LSEConfig(RCC_LSE_ON);
000016  2001              MOVS     r0,#1
000018  f7fffffe          BL       RCC_LSEConfig
                  |L4.28|
;;;294      	/* Wait till LSE is ready */
;;;295      	while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET)
00001c  2041              MOVS     r0,#0x41
00001e  f7fffffe          BL       RCC_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0fa              BEQ      |L4.28|
;;;296      	{}
;;;297    
;;;298      	/* Select LSE as RTC Clock Source */
;;;299      	RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
000026  f44f7080          MOV      r0,#0x100
00002a  f7fffffe          BL       RCC_RTCCLKConfig
;;;300    #endif
;;;301      	/* Enable RTC Clock */
;;;302      	RCC_RTCCLKCmd(ENABLE);
00002e  2001              MOVS     r0,#1
000030  f7fffffe          BL       RCC_RTCCLKCmd
;;;303    
;;;304      	/* Wait for RTC registers synchronization */
;;;305      	RTC_WaitForSynchro();
000034  f7fffffe          BL       RTC_WaitForSynchro
;;;306    
;;;307      	/* Wait until last write operation on RTC registers has finished */
;;;308      	RTC_WaitForLastTask();
000038  f7fffffe          BL       RTC_WaitForLastTask
;;;309    
;;;310      	/* Enable the RTC Second */
;;;311      	RTC_ITConfig(RTC_IT_SEC, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  4608              MOV      r0,r1
000040  f7fffffe          BL       RTC_ITConfig
;;;312    
;;;313      	/* Wait until last write operation on RTC registers has finished */
;;;314      	RTC_WaitForLastTask();
000044  f7fffffe          BL       RTC_WaitForLastTask
;;;315    
;;;316      	/* Set RTC prescaler: set RTC period to 1sec */
;;;317          /* Set RTC prescaler: set RTC period to 1sec */
;;;318    #ifdef RTCClockSource_LSI
;;;319      		RTC_SetPrescaler(31999); /* RTC period = RTCCLK/RTC_PR = (32.000 KHz)/(31999+1) */
;;;320    #elif defined	RTCClockSource_LSE
;;;321      		RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
000048  f64770ff          MOV      r0,#0x7fff
00004c  f7fffffe          BL       RTC_SetPrescaler
;;;322    #endif
;;;323    
;;;324      //	RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
;;;325    
;;;326      	/* Wait until last write operation on RTC registers has finished */
;;;327      	RTC_WaitForLastTask();
000050  e8bd4010          POP      {r4,lr}
000054  f7ffbffe          B.W      RTC_WaitForLastTask
;;;328    }
;;;329    void RTC_Config_Init(void)
                          ENDP


                          AREA ||i.RTC_Get_Time||, CODE, READONLY, ALIGN=2

                  RTC_Get_Time PROC
;;;88     
;;;89     unsigned char RTC_Get_Time(tim *timer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;90     {
000004  4604              MOV      r4,r0
;;;91         static unsigned short daycnt=0;
;;;92     	unsigned int timecount=0;
;;;93     	unsigned int temp=0;
;;;94     	unsigned short temp1=0;
;;;95     	RTC_WaitForLastTask();
000006  f7fffffe          BL       RTC_WaitForLastTask
00000a  492e              LDR      r1,|L5.196|
;;;96     	timecount=RTC->CNTH;//得到计数器中的值(秒钟数)
00000c  8808              LDRH     r0,[r1,#0]
;;;97     	timecount<<=16;
;;;98     	timecount+=RTC->CNTL;
00000e  8889              LDRH     r1,[r1,#4]
;;;99     	temp=timecount/86400; //得到天数(秒钟数对应的)
000010  f8df90b4          LDR      r9,|L5.200|
000014  eb014600          ADD      r6,r1,r0,LSL #16      ;98
000018  fbb6f3f9          UDIV     r3,r6,r9
;;;100    	if(daycnt!=temp)//超过一天了
00001c  482b              LDR      r0,|L5.204|
00001e  461f              MOV      r7,r3                 ;99
000020  8801              LDRH     r1,[r0,#0]  ; daycnt
000022  4299              CMP      r1,r3
000024  d031              BEQ      |L5.138|
;;;101    	{
;;;102    		daycnt=temp;
000026  8003              STRH     r3,[r0,#0]
;;;103    		temp1=1970; //从1970年开始
000028  f24075b2          MOV      r5,#0x7b2
;;;104    		while(temp>=365)
;;;105    		{
;;;106    			if(Is_Leap_Year(temp1))//是闰年
;;;107    			{
;;;108    				if(temp>=366)temp-=366;//闰年的秒钟数
00002c  f44f78b7          MOV      r8,#0x16e
000030  f44f7ab6          MOV      r10,#0x16c            ;104
;;;109    				else {temp1++;break;}
;;;110    			}
;;;111    			else temp-=365; //平年
;;;112    			temp1++;
000034  e00f              B        |L5.86|
                  |L5.54|
000036  4628              MOV      r0,r5                 ;106
000038  f7fffffe          BL       Is_Leap_Year
00003c  b138              CBZ      r0,|L5.78|
00003e  4543              CMP      r3,r8                 ;108
000040  d302              BCC      |L5.72|
000042  f5a373b7          SUB      r3,r3,#0x16e          ;108
000046  e004              B        |L5.82|
                  |L5.72|
000048  1c6d              ADDS     r5,r5,#1              ;109
00004a  b2ad              UXTH     r5,r5                 ;109
00004c  e005              B        |L5.90|
                  |L5.78|
00004e  f2a3136d          SUB      r3,r3,#0x16d          ;111
                  |L5.82|
000052  1c6d              ADDS     r5,r5,#1
000054  b2ad              UXTH     r5,r5
                  |L5.86|
000056  4553              CMP      r3,r10                ;104
000058  d8ed              BHI      |L5.54|
                  |L5.90|
;;;113    		}
;;;114    		timer->year=temp1;//得到年份
00005a  8025              STRH     r5,[r4,#0]
;;;115    		temp1=0;
00005c  2500              MOVS     r5,#0
;;;116    		while(temp>=28)//超过了一个月
;;;117    		{
;;;118    			if(Is_Leap_Year(timer->year)&&temp1==1)//当年是不是闰年/2月份
;;;119    			{
;;;120    				if(temp>=29)temp-=29;//闰年的秒钟数
;;;121    				else break;
;;;122    			}
;;;123    			else
;;;124    			{
;;;125    				if(temp>=mon_table[temp1])temp-=mon_table[temp1];//平年
00005e  f8df8070          LDR      r8,|L5.208|
;;;126    				else break;
;;;127    			}
;;;128    			temp1++;
000062  e00c              B        |L5.126|
                  |L5.100|
000064  8820              LDRH     r0,[r4,#0]            ;118
000066  f7fffffe          BL       Is_Leap_Year
00006a  b108              CBZ      r0,|L5.112|
00006c  2d01              CMP      r5,#1                 ;118
00006e  d025              BEQ      |L5.188|
                  |L5.112|
000070  f8180005          LDRB     r0,[r8,r5]            ;125
000074  4298              CMP      r0,r3                 ;125
000076  d804              BHI      |L5.130|
000078  1a1b              SUBS     r3,r3,r0              ;125
                  |L5.122|
00007a  1c6d              ADDS     r5,r5,#1
00007c  b2ad              UXTH     r5,r5
                  |L5.126|
00007e  2b1c              CMP      r3,#0x1c              ;116
000080  d2f0              BCS      |L5.100|
                  |L5.130|
;;;129    		}
;;;130    		timer->month=temp1+1;//得到月份
000082  1c6d              ADDS     r5,r5,#1
000084  70a5              STRB     r5,[r4,#2]
;;;131    		timer->date=temp+1; //得到日期
000086  1c5b              ADDS     r3,r3,#1
000088  70e3              STRB     r3,[r4,#3]
                  |L5.138|
;;;132    	}
;;;133    	temp=timecount%86400; //得到秒钟数
00008a  fb096017          MLS      r0,r9,r7,r6
;;;134    	timer->hour=temp/3600; //小时
00008e  f44f6261          MOV      r2,#0xe10
000092  fbb0f1f2          UDIV     r1,r0,r2
000096  7161              STRB     r1,[r4,#5]
;;;135    	timer->min=(temp%3600)/60; //分钟
000098  fb020111          MLS      r1,r2,r1,r0
00009c  223c              MOVS     r2,#0x3c
00009e  fbb1f0f2          UDIV     r0,r1,r2
0000a2  71a0              STRB     r0,[r4,#6]
;;;136    	timer->sec=(temp%3600)%60; //秒钟
0000a4  fb021010          MLS      r0,r2,r0,r1
0000a8  71e0              STRB     r0,[r4,#7]
;;;137    	//timer->sec = 0; //秒钟
;;;138    	timer->week=RTC_Get_Week(timer->year,timer->month,timer->date);//获取星期
0000aa  78e2              LDRB     r2,[r4,#3]
0000ac  78a1              LDRB     r1,[r4,#2]
0000ae  8820              LDRH     r0,[r4,#0]
0000b0  f7fffffe          BL       RTC_Get_Week
0000b4  7120              STRB     r0,[r4,#4]
;;;139    	return 0;
0000b6  2000              MOVS     r0,#0
;;;140    }
0000b8  e8bd87f0          POP      {r4-r10,pc}
                  |L5.188|
0000bc  2b1d              CMP      r3,#0x1d              ;120
0000be  d3e0              BCC      |L5.130|
0000c0  3b1d              SUBS     r3,r3,#0x1d           ;120
0000c2  e7da              B        |L5.122|
;;;141    
                          ENDP

                  |L5.196|
                          DCD      0x40002818
                  |L5.200|
                          DCD      0x00015180
                  |L5.204|
                          DCD      ||area_number.15||
                  |L5.208|
                          DCD      ||.constdata||

                          AREA ||i.RTC_Get_Week||, CODE, READONLY, ALIGN=1

                  RTC_Get_Week PROC
;;;68     
;;;69     unsigned char RTC_Get_Week(unsigned short year,unsigned char month,unsigned char day)//	 0=sunday
000000  1e40              SUBS     r0,r0,#1
;;;70     {
;;;71         year--;
000002  b280              UXTH     r0,r0
;;;72     	if(month>2)
000004  2902              CMP      r1,#2
000006  d902              BLS      |L6.14|
;;;73     	{
;;;74     	    month-=2;
000008  1e89              SUBS     r1,r1,#2
00000a  b2c9              UXTB     r1,r1
00000c  e003              B        |L6.22|
                  |L6.14|
;;;75     	}
;;;76     	else
;;;77     	{
;;;78     	    month+=10;
00000e  310a              ADDS     r1,r1,#0xa
;;;79     		year--;
000010  1e40              SUBS     r0,r0,#1
000012  b2c9              UXTB     r1,r1                 ;78
000014  b280              UXTH     r0,r0
                  |L6.22|
;;;80     	}
;;;81     	return((year+(year/4)+(13*month-1)/5+day)%7);
000016  eb010381          ADD      r3,r1,r1,LSL #2
00001a  eb0301c1          ADD      r1,r3,r1,LSL #3
00001e  1e49              SUBS     r1,r1,#1
000020  2305              MOVS     r3,#5
000022  fb91f1f3          SDIV     r1,r1,r3
000026  eb000090          ADD      r0,r0,r0,LSR #2
00002a  4408              ADD      r0,r0,r1
00002c  4410              ADD      r0,r0,r2
00002e  2107              MOVS     r1,#7
000030  fb90f2f1          SDIV     r2,r0,r1
000034  fb010012          MLS      r0,r1,r2,r0
000038  b2c0              UXTB     r0,r0
;;;82     }
00003a  4770              BX       lr
;;;83     
                          ENDP


                          AREA ||i.RTC_Set||, CODE, READONLY, ALIGN=2

                  RTC_Set PROC
;;;150    //const unsigned char mon_table[12]={31,28,31,30,31,30,31,31,30,31,30,31};
;;;151    unsigned char RTC_Set(tim timer)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;152    {
000004  4604              MOV      r4,r0
;;;153    	unsigned short t;
;;;154    	unsigned int seccount=0;
000006  b285              UXTH     r5,r0
000008  2300              MOVS     r3,#0
;;;155    	if(timer.year<1970||timer.year>2099)return 1;
00000a  f2a570b2          SUB      r0,r5,#0x7b2
00000e  460e              MOV      r6,r1                 ;152
000010  2882              CMP      r0,#0x82
000012  d302              BCC      |L7.26|
000014  2001              MOVS     r0,#1
                  |L7.22|
;;;156    	for(t=1970;t<timer.year;t++) //把所有年份的秒钟相加
;;;157    	{
;;;158    		if(Is_Leap_Year(t)!=0)seccount+=31622400;//闰年的秒钟数
;;;159    		else seccount+=31536000; //平年的秒钟数
;;;160    	}
;;;161    	timer.month-=1;
;;;162    	for(t=0;t<timer.month;t++) //把前面月份的秒钟数相加
;;;163    	{
;;;164    		seccount+=(unsigned int)mon_table[t]*86400;//月份秒钟数相加
;;;165    		if(Is_Leap_Year(timer.year)&&t==1)seccount+=86400;//闰年2月份增加一天的秒钟数
;;;166    	}
;;;167    	seccount+=(unsigned int)(timer.date-1)*86400;//把前面日期的秒钟数相加
;;;168    	seccount+=(unsigned int)timer.hour*3600;//小时秒钟数
;;;169    	seccount+=(unsigned int)timer.min*60; //分钟秒钟数
;;;170    	seccount+=timer.sec;//最后的秒钟加上去
;;;171    
;;;172    	
;;;173    	//设置时钟
;;;174    	RCC->APB1ENR|=1<<28;//使能电源时钟
;;;175    	RCC->APB1ENR|=1<<27;//使能备份时钟
;;;176    	PWR->CR|=1<<8; //取消备份区写保护
;;;177    	//上面三步是必须的!
;;;178    	RTC->CRL|=1<<4; //允许配置
;;;179    	RTC->CNTL=seccount&0xffff;
;;;180    	RTC->CNTH=seccount>>16;
;;;181    	RTC->CRL&=~(1<<4);//配置更新
;;;182    	while(!(RTC->CRL&(1<<5)));//等待RTC寄存器操作完成
;;;183    	return 0;
;;;184    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L7.26|
00001a  f24077b2          MOV      r7,#0x7b2             ;156
00001e  f8df80d8          LDR      r8,|L7.248|
000022  f8df90d8          LDR      r9,|L7.252|
000026  e008              B        |L7.58|
                  |L7.40|
000028  4638              MOV      r0,r7                 ;158
00002a  f7fffffe          BL       Is_Leap_Year
00002e  b108              CBZ      r0,|L7.52|
000030  4443              ADD      r3,r3,r8              ;158
000032  e000              B        |L7.54|
                  |L7.52|
000034  444b              ADD      r3,r3,r9              ;159
                  |L7.54|
000036  1c7f              ADDS     r7,r7,#1              ;156
000038  b2bf              UXTH     r7,r7                 ;156
                  |L7.58|
00003a  42bd              CMP      r5,r7                 ;156
00003c  d8f4              BHI      |L7.40|
00003e  f3c44007          UBFX     r0,r4,#16,#8          ;156
000042  1e40              SUBS     r0,r0,#1              ;161
000044  b2c7              UXTB     r7,r0                 ;161
000046  f3674417          BFI      r4,r7,#16,#8          ;161
00004a  46a0              MOV      r8,r4                 ;161
00004c  2400              MOVS     r4,#0                 ;162
00004e  f8df90b0          LDR      r9,|L7.256|
000052  f8dfa0b0          LDR      r10,|L7.260|
000056  e00f              B        |L7.120|
                  |L7.88|
000058  f8190004          LDRB     r0,[r9,r4]            ;164
00005c  f24021a3          MOV      r1,#0x2a3             ;164
000060  4348              MULS     r0,r1,r0              ;164
000062  eb0313c0          ADD      r3,r3,r0,LSL #7       ;164
000066  4628              MOV      r0,r5                 ;164
000068  f7fffffe          BL       Is_Leap_Year
00006c  b110              CBZ      r0,|L7.116|
00006e  2c01              CMP      r4,#1                 ;165
000070  d100              BNE      |L7.116|
000072  4453              ADD      r3,r3,r10             ;165
                  |L7.116|
000074  1c64              ADDS     r4,r4,#1              ;162
000076  b2a4              UXTH     r4,r4                 ;162
                  |L7.120|
000078  42a7              CMP      r7,r4                 ;162
00007a  d8ed              BHI      |L7.88|
00007c  ea4f6018          LSR      r0,r8,#24             ;162
000080  f24021a3          MOV      r1,#0x2a3             ;167
000084  4348              MULS     r0,r1,r0              ;167
000086  491f              LDR      r1,|L7.260|
000088  eb0310c0          ADD      r0,r3,r0,LSL #7       ;167
00008c  4249              RSBS     r1,r1,#0              ;167
00008e  4401              ADD      r1,r1,r0              ;167
000090  f3c62007          UBFX     r0,r6,#8,#8           ;167
000094  ebc01240          RSB      r2,r0,r0,LSL #5       ;168
000098  ebc22000          RSB      r0,r2,r0,LSL #8       ;168
00009c  eb011100          ADD      r1,r1,r0,LSL #4       ;168
0000a0  f3c64007          UBFX     r0,r6,#16,#8          ;168
0000a4  ebc01000          RSB      r0,r0,r0,LSL #4       ;169
0000a8  eb010080          ADD      r0,r1,r0,LSL #2       ;169
0000ac  eb006116          ADD      r1,r0,r6,LSR #24      ;170
0000b0  4815              LDR      r0,|L7.264|
0000b2  69c2              LDR      r2,[r0,#0x1c]         ;174
0000b4  f0425280          ORR      r2,r2,#0x10000000     ;174
0000b8  61c2              STR      r2,[r0,#0x1c]         ;174
0000ba  69c2              LDR      r2,[r0,#0x1c]         ;175
0000bc  f0426200          ORR      r2,r2,#0x8000000      ;175
0000c0  61c2              STR      r2,[r0,#0x1c]         ;175
0000c2  4812              LDR      r0,|L7.268|
0000c4  6802              LDR      r2,[r0,#0]            ;176
0000c6  f4427280          ORR      r2,r2,#0x100          ;176
0000ca  6002              STR      r2,[r0,#0]            ;176
0000cc  4810              LDR      r0,|L7.272|
0000ce  8802              LDRH     r2,[r0,#0]            ;178
0000d0  f0420210          ORR      r2,r2,#0x10           ;178
0000d4  8002              STRH     r2,[r0,#0]            ;178
0000d6  8301              STRH     r1,[r0,#0x18]         ;179
0000d8  ea4f4111          LSR      r1,r1,#16             ;180
0000dc  8281              STRH     r1,[r0,#0x14]         ;180
0000de  8801              LDRH     r1,[r0,#0]            ;181
0000e0  f0210110          BIC      r1,r1,#0x10           ;181
0000e4  8001              STRH     r1,[r0,#0]            ;181
0000e6  f6a00004          SUB      r0,r0,#0x804          ;181
                  |L7.234|
0000ea  f8b01804          LDRH     r1,[r0,#0x804]        ;182
0000ee  0689              LSLS     r1,r1,#26             ;182
0000f0  d5fb              BPL      |L7.234|
0000f2  2000              MOVS     r0,#0                 ;183
0000f4  e78f              B        |L7.22|
;;;185    
                          ENDP

0000f6  0000              DCW      0x0000
                  |L7.248|
                          DCD      0x01e28500
                  |L7.252|
                          DCD      0x01e13380
                  |L7.256|
                          DCD      ||.constdata||
                  |L7.260|
                          DCD      0x00015180
                  |L7.264|
                          DCD      0x40021000
                  |L7.268|
                          DCD      0x40007000
                  |L7.272|
                          DCD      0x40002804

                          AREA ||i.RTC_time_to_string||, CODE, READONLY, ALIGN=1

                  RTC_time_to_string PROC
;;;220    
;;;221    RTC_time_to_string(char *buf ,tim timer)
000000  b5f0              PUSH     {r4-r7,lr}
;;;222    {
000002  b28c              UXTH     r4,r1
;;;223    	buf[0] = timer.year/1000 +'0';
000004  f44f757a          MOV      r5,#0x3e8
000008  fbb4f3f5          UDIV     r3,r4,r5
00000c  f1030630          ADD      r6,r3,#0x30
;;;224        buf[1] = timer.year%1000/100 +'0';
000010  fb054513          MLS      r5,r5,r3,r4
000014  2364              MOVS     r3,#0x64
000016  fbb5f5f3          UDIV     r5,r5,r3
00001a  7006              STRB     r6,[r0,#0]            ;223
00001c  3530              ADDS     r5,r5,#0x30
00001e  7045              STRB     r5,[r0,#1]
;;;225        buf[2] = timer.year%100/10 +'0';
000020  fbb4f5f3          UDIV     r5,r4,r3
000024  fb034515          MLS      r5,r3,r5,r4
000028  230a              MOVS     r3,#0xa
00002a  fbb5f5f3          UDIV     r5,r5,r3
00002e  3530              ADDS     r5,r5,#0x30
000030  7085              STRB     r5,[r0,#2]
;;;226        buf[3] = timer.year%10 +'0';
000032  fbb4f5f3          UDIV     r5,r4,r3
000036  fb034415          MLS      r4,r3,r5,r4
00003a  3430              ADDS     r4,r4,#0x30
00003c  70c4              STRB     r4,[r0,#3]
;;;227                    
;;;228        buf[4] = '-';
00003e  f3c14507          UBFX     r5,r1,#16,#8
;;;229                    
;;;230        buf[5] = timer.month/10  +'0';
000042  fbb5f4f3          UDIV     r4,r5,r3
000046  f1040730          ADD      r7,r4,#0x30
00004a  262d              MOVS     r6,#0x2d              ;228
;;;231        buf[6] = timer.month%10 +'0';
00004c  fb035414          MLS      r4,r3,r4,r5
000050  7106              STRB     r6,[r0,#4]            ;228
000052  7147              STRB     r7,[r0,#5]            ;230
000054  3430              ADDS     r4,r4,#0x30
000056  7184              STRB     r4,[r0,#6]
;;;232    
;;;233        buf[7] = '-';
000058  0e0c              LSRS     r4,r1,#24
;;;234                    
;;;235        buf[8] = timer.date/10 +'0';
00005a  fbb4f1f3          UDIV     r1,r4,r3
00005e  f1010530          ADD      r5,r1,#0x30
;;;236        buf[9] = timer.date%10 +'0';
000062  fb034111          MLS      r1,r3,r1,r4
000066  71c6              STRB     r6,[r0,#7]            ;233
000068  7205              STRB     r5,[r0,#8]            ;235
00006a  3130              ADDS     r1,r1,#0x30
00006c  7241              STRB     r1,[r0,#9]
;;;237                    
;;;238        buf[10] = ' ';
00006e  2120              MOVS     r1,#0x20
000070  7281              STRB     r1,[r0,#0xa]
000072  f3c22407          UBFX     r4,r2,#8,#8
;;;239                    
;;;240        buf[11] = timer.hour/10  +'0';
000076  fbb4f1f3          UDIV     r1,r4,r3
00007a  f1010530          ADD      r5,r1,#0x30
;;;241        buf[12] = timer.hour%10 +'0';
00007e  fb034111          MLS      r1,r3,r1,r4
000082  72c5              STRB     r5,[r0,#0xb]          ;240
000084  3130              ADDS     r1,r1,#0x30
000086  7301              STRB     r1,[r0,#0xc]
;;;242    
;;;243        buf[13] = ':';
000088  f3c24407          UBFX     r4,r2,#16,#8
;;;244                    
;;;245        buf[14] = timer.min/10 +'0';
00008c  fbb4f1f3          UDIV     r1,r4,r3
000090  f1010630          ADD      r6,r1,#0x30
000094  253a              MOVS     r5,#0x3a              ;243
;;;246        buf[15] = timer.min%10 +'0';
000096  fb034111          MLS      r1,r3,r1,r4
00009a  7345              STRB     r5,[r0,#0xd]          ;243
00009c  7386              STRB     r6,[r0,#0xe]          ;245
00009e  3130              ADDS     r1,r1,#0x30
0000a0  73c1              STRB     r1,[r0,#0xf]
;;;247    
;;;248    	buf[16] = ':';
0000a2  0e12              LSRS     r2,r2,#24
;;;249    	
;;;250    	buf[17] = timer.sec/10 +'0';
0000a4  fbb2f1f3          UDIV     r1,r2,r3
0000a8  f1010430          ADD      r4,r1,#0x30
;;;251        buf[18] = timer.sec%10 +'0';
0000ac  fb032111          MLS      r1,r3,r1,r2
0000b0  7405              STRB     r5,[r0,#0x10]         ;248
0000b2  7444              STRB     r4,[r0,#0x11]         ;250
0000b4  3130              ADDS     r1,r1,#0x30
0000b6  7481              STRB     r1,[r0,#0x12]
;;;252        buf[19] = '\0';
0000b8  2100              MOVS     r1,#0
0000ba  74c1              STRB     r1,[r0,#0x13]
;;;253    	
;;;254    }
0000bc  bdf0              POP      {r4-r7,pc}
;;;255    
                          ENDP


                          AREA ||i.get_hour_min||, CODE, READONLY, ALIGN=1

                  get_hour_min PROC
;;;256    
;;;257    void get_hour_min(char *buf ,tim timer)
000000  b530              PUSH     {r4,r5,lr}
;;;258    {
000002  f3c22307          UBFX     r3,r2,#8,#8
;;;259    	buf[0] = timer.hour/10  +'0';
000006  240a              MOVS     r4,#0xa
000008  fbb3f1f4          UDIV     r1,r3,r4
00000c  f1010530          ADD      r5,r1,#0x30
;;;260        buf[1] = timer.hour%10 +'0';
000010  fb043111          MLS      r1,r4,r1,r3
000014  7005              STRB     r5,[r0,#0]            ;259
000016  3130              ADDS     r1,r1,#0x30
000018  7041              STRB     r1,[r0,#1]
;;;261    
;;;262        buf[2] = ':';
00001a  213a              MOVS     r1,#0x3a
00001c  7081              STRB     r1,[r0,#2]
00001e  f3c24207          UBFX     r2,r2,#16,#8
;;;263                    
;;;264        buf[3] = timer.min/10 +'0';
000022  fbb2f1f4          UDIV     r1,r2,r4
000026  f1010330          ADD      r3,r1,#0x30
;;;265        buf[4] = timer.min%10 +'0';
00002a  fb042111          MLS      r1,r4,r1,r2
00002e  70c3              STRB     r3,[r0,#3]            ;264
000030  3130              ADDS     r1,r1,#0x30
000032  7101              STRB     r1,[r0,#4]
;;;266    	buf[5] = '\0';
000034  2100              MOVS     r1,#0
000036  7141              STRB     r1,[r0,#5]
;;;267    
;;;268    }
000038  bd30              POP      {r4,r5,pc}
;;;269    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000008  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=0

000000  53756e64          DCB      "Sunday",0
000004  617900  
000007  4d6f6e64          DCB      "Monday",0
00000b  617900  
00000e  54756573          DCB      "Tuesday",0
000012  64617900
000016  5765646e          DCB      "Wednesday",0
00001a  65736461
00001e  7900    
000020  54687572          DCB      "Thursday",0
000024  73646179
000028  00      
000029  46726964          DCB      "Friday",0
00002d  617900  
000030  53617475          DCB      "Saturday",0
000034  72646179
000038  00      

                          AREA ||.data||, DATA, ALIGN=2

                  week
                          DCD      ||.conststring||
                          DCD      ||.conststring||+0x7
                          DCD      ||.conststring||+0xe
                          DCD      ||.conststring||+0x16
                          DCD      ||.conststring||+0x20
                          DCD      ||.conststring||+0x29
                          DCD      ||.conststring||+0x30

                          AREA ||area_number.15||, DATA, ALIGN=1

                          EXPORTAS ||area_number.15||, ||.data||
                  daycnt
000000  0000              DCW      0x0000

                          AREA ||area_number.16||, DATA, ALIGN=1

                          EXPORTAS ||area_number.16||, ||.data||
                  w_timer
                          %        8

;*** Start embedded assembler ***

#line 1 "Source\\BSP\\rtc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_54b4358b____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_rtc_c_54b4358b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_rtc_c_54b4358b____REVSH|
#line 128
|__asm___5_rtc_c_54b4358b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
