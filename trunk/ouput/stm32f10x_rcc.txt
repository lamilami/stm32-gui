; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_rcc.o --depend=.\ouput\stm32f10x_rcc.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_rcc.crf Source\FWLib\src\stm32f10x_rcc.c]
                          THUMB

                          AREA ||i.RCC_ADCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_ADCCLKConfig PROC
;;;764      */
;;;765    void RCC_ADCCLKConfig(uint32_t RCC_PCLK2)
000000  4a03              LDR      r2,|L1.16|
;;;766    {
;;;767      uint32_t tmpreg = 0;
;;;768      /* Check the parameters */
;;;769      assert_param(IS_RCC_ADCCLK(RCC_PCLK2));
;;;770      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;771      /* Clear ADCPRE[1:0] bits */
;;;772      tmpreg &= CFGR_ADCPRE_Reset_Mask;
000004  f4214140          BIC      r1,r1,#0xc000
;;;773      /* Set ADCPRE[1:0] bits according to RCC_PCLK2 value */
;;;774      tmpreg |= RCC_PCLK2;
000008  4301              ORRS     r1,r1,r0
;;;775      /* Store the new value */
;;;776      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;777    }
00000c  4770              BX       lr
;;;778    
                          ENDP

00000e  0000              DCW      0x0000
                  |L1.16|
                          DCD      0x40021000

                          AREA ||i.RCC_AHBPeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_AHBPeriphClockCmd PROC
;;;1062     */
;;;1063   void RCC_AHBPeriphClockCmd(uint32_t RCC_AHBPeriph, FunctionalState NewState)
000000  4a04              LDR      r2,|L2.20|
;;;1064   {
;;;1065     /* Check the parameters */
;;;1066     assert_param(IS_RCC_AHB_PERIPH(RCC_AHBPeriph));
;;;1067     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1068   
;;;1069     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1070     {
;;;1071       RCC->AHBENR |= RCC_AHBPeriph;
;;;1072     }
;;;1073     else
;;;1074     {
;;;1075       RCC->AHBENR &= ~RCC_AHBPeriph;
000004  6951              LDR      r1,[r2,#0x14]
000006  d001              BEQ      |L2.12|
000008  4301              ORRS     r1,r1,r0              ;1071
00000a  e000              B        |L2.14|
                  |L2.12|
00000c  4381              BICS     r1,r1,r0
                  |L2.14|
00000e  6151              STR      r1,[r2,#0x14]         ;1071
;;;1076     }
;;;1077   }
000010  4770              BX       lr
;;;1078   
                          ENDP

000012  0000              DCW      0x0000
                  |L2.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphClockCmd PROC
;;;1124     */
;;;1125   void RCC_APB1PeriphClockCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L3.20|
;;;1126   {
;;;1127     /* Check the parameters */
;;;1128     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1129     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1130     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1131     {
;;;1132       RCC->APB1ENR |= RCC_APB1Periph;
;;;1133     }
;;;1134     else
;;;1135     {
;;;1136       RCC->APB1ENR &= ~RCC_APB1Periph;
000004  69d1              LDR      r1,[r2,#0x1c]
000006  d001              BEQ      |L3.12|
000008  4301              ORRS     r1,r1,r0              ;1132
00000a  e000              B        |L3.14|
                  |L3.12|
00000c  4381              BICS     r1,r1,r0
                  |L3.14|
00000e  61d1              STR      r1,[r2,#0x1c]         ;1132
;;;1137     }
;;;1138   }
000010  4770              BX       lr
;;;1139   
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB1PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB1PeriphResetCmd PROC
;;;1214     */
;;;1215   void RCC_APB1PeriphResetCmd(uint32_t RCC_APB1Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L4.20|
;;;1216   {
;;;1217     /* Check the parameters */
;;;1218     assert_param(IS_RCC_APB1_PERIPH(RCC_APB1Periph));
;;;1219     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1220     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1221     {
;;;1222       RCC->APB1RSTR |= RCC_APB1Periph;
;;;1223     }
;;;1224     else
;;;1225     {
;;;1226       RCC->APB1RSTR &= ~RCC_APB1Periph;
000004  6911              LDR      r1,[r2,#0x10]
000006  d001              BEQ      |L4.12|
000008  4301              ORRS     r1,r1,r0              ;1222
00000a  e000              B        |L4.14|
                  |L4.12|
00000c  4381              BICS     r1,r1,r0
                  |L4.14|
00000e  6111              STR      r1,[r2,#0x10]         ;1222
;;;1227     }
;;;1228   }
000010  4770              BX       lr
;;;1229   
                          ENDP

000012  0000              DCW      0x0000
                  |L4.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphClockCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphClockCmd PROC
;;;1093     */
;;;1094   void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L5.20|
;;;1095   {
;;;1096     /* Check the parameters */
;;;1097     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1098     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1099     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1100     {
;;;1101       RCC->APB2ENR |= RCC_APB2Periph;
;;;1102     }
;;;1103     else
;;;1104     {
;;;1105       RCC->APB2ENR &= ~RCC_APB2Periph;
000004  6991              LDR      r1,[r2,#0x18]
000006  d001              BEQ      |L5.12|
000008  4301              ORRS     r1,r1,r0              ;1101
00000a  e000              B        |L5.14|
                  |L5.12|
00000c  4381              BICS     r1,r1,r0
                  |L5.14|
00000e  6191              STR      r1,[r2,#0x18]         ;1101
;;;1106     }
;;;1107   }
000010  4770              BX       lr
;;;1108   
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      0x40021000

                          AREA ||i.RCC_APB2PeriphResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_APB2PeriphResetCmd PROC
;;;1183     */
;;;1184   void RCC_APB2PeriphResetCmd(uint32_t RCC_APB2Periph, FunctionalState NewState)
000000  4a04              LDR      r2,|L6.20|
;;;1185   {
;;;1186     /* Check the parameters */
;;;1187     assert_param(IS_RCC_APB2_PERIPH(RCC_APB2Periph));
;;;1188     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1189     if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;1190     {
;;;1191       RCC->APB2RSTR |= RCC_APB2Periph;
;;;1192     }
;;;1193     else
;;;1194     {
;;;1195       RCC->APB2RSTR &= ~RCC_APB2Periph;
000004  68d1              LDR      r1,[r2,#0xc]
000006  d001              BEQ      |L6.12|
000008  4301              ORRS     r1,r1,r0              ;1191
00000a  e000              B        |L6.14|
                  |L6.12|
00000c  4381              BICS     r1,r1,r0
                  |L6.14|
00000e  60d1              STR      r1,[r2,#0xc]          ;1191
;;;1196     }
;;;1197   }
000010  4770              BX       lr
;;;1198   
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40021000

                          AREA ||i.RCC_AdjustHSICalibrationValue||, CODE, READONLY, ALIGN=2

                  RCC_AdjustHSICalibrationValue PROC
;;;332      */
;;;333    void RCC_AdjustHSICalibrationValue(uint8_t HSICalibrationValue)
000000  4a03              LDR      r2,|L7.16|
;;;334    {
;;;335      uint32_t tmpreg = 0;
;;;336      /* Check the parameters */
;;;337      assert_param(IS_RCC_CALIBRATION_VALUE(HSICalibrationValue));
;;;338      tmpreg = RCC->CR;
000002  6811              LDR      r1,[r2,#0]
;;;339      /* Clear HSITRIM[4:0] bits */
;;;340      tmpreg &= CR_HSITRIM_Mask;
000004  f02101f8          BIC      r1,r1,#0xf8
;;;341      /* Set the HSITRIM[4:0] bits according to HSICalibrationValue value */
;;;342      tmpreg |= (uint32_t)HSICalibrationValue << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;343      /* Store the new value */
;;;344      RCC->CR = tmpreg;
00000c  6010              STR      r0,[r2,#0]
;;;345    }
00000e  4770              BX       lr
;;;346    
                          ENDP

                  |L7.16|
                          DCD      0x40021000

                          AREA ||i.RCC_BackupResetCmd||, CODE, READONLY, ALIGN=2

                  RCC_BackupResetCmd PROC
;;;1235     */
;;;1236   void RCC_BackupResetCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;1237   {
;;;1238     /* Check the parameters */
;;;1239     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1240     *(__IO uint32_t *) BDCR_BDRST_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;1241   }
000004  4770              BX       lr
;;;1242   
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x42420440

                          AREA ||i.RCC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RCC_ClearFlag PROC
;;;1369     */
;;;1370   void RCC_ClearFlag(void)
000000  4802              LDR      r0,|L9.12|
;;;1371   {
;;;1372     /* Set RMVF bit to clear the reset flags */
;;;1373     RCC->CSR |= CSR_RMVF_Set;
000002  6a41              LDR      r1,[r0,#0x24]
000004  f0417180          ORR      r1,r1,#0x1000000
000008  6241              STR      r1,[r0,#0x24]
;;;1374   }
00000a  4770              BX       lr
;;;1375   
                          ENDP

                  |L9.12|
                          DCD      0x40021000

                          AREA ||i.RCC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RCC_ClearITPendingBit PROC
;;;1446     */
;;;1447   void RCC_ClearITPendingBit(uint8_t RCC_IT)
000000  4901              LDR      r1,|L10.8|
;;;1448   {
;;;1449     /* Check the parameters */
;;;1450     assert_param(IS_RCC_CLEAR_IT(RCC_IT));
;;;1451   
;;;1452     /* Perform Byte access to RCC_CIR[23:16] bits to clear the selected interrupt
;;;1453        pending bits */
;;;1454     *(__IO uint8_t *) CIR_BYTE3_ADDRESS = RCC_IT;
000002  7288              STRB     r0,[r1,#0xa]
;;;1455   }
000004  4770              BX       lr
;;;1456   
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40021000

                          AREA ||i.RCC_ClockSecuritySystemCmd||, CODE, READONLY, ALIGN=2

                  RCC_ClockSecuritySystemCmd PROC
;;;1248     */
;;;1249   void RCC_ClockSecuritySystemCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L11.8|
;;;1250   {
;;;1251     /* Check the parameters */
;;;1252     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1253     *(__IO uint32_t *) CR_CSSON_BB = (uint32_t)NewState;
000002  64c8              STR      r0,[r1,#0x4c]
;;;1254   }
000004  4770              BX       lr
;;;1255   
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x42420000

                          AREA ||i.RCC_DeInit||, CODE, READONLY, ALIGN=2

                  RCC_DeInit PROC
;;;215      */
;;;216    void RCC_DeInit(void)
000000  480c              LDR      r0,|L12.52|
;;;217    {
;;;218      /* Set HSION bit */
;;;219      RCC->CR |= (uint32_t)0x00000001;
000002  6801              LDR      r1,[r0,#0]
000004  f0410101          ORR      r1,r1,#1
000008  6001              STR      r1,[r0,#0]
;;;220    
;;;221      /* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;222    #ifndef STM32F10X_CL
;;;223      RCC->CFGR &= (uint32_t)0xF8FF0000;
00000a  6841              LDR      r1,[r0,#4]
00000c  4a0a              LDR      r2,|L12.56|
00000e  4011              ANDS     r1,r1,r2
000010  6041              STR      r1,[r0,#4]
;;;224    #else
;;;225      RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;226    #endif /* STM32F10X_CL */   
;;;227      
;;;228      /* Reset HSEON, CSSON and PLLON bits */
;;;229      RCC->CR &= (uint32_t)0xFEF6FFFF;
000012  6801              LDR      r1,[r0,#0]
000014  4a09              LDR      r2,|L12.60|
000016  4011              ANDS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;230    
;;;231      /* Reset HSEBYP bit */
;;;232      RCC->CR &= (uint32_t)0xFFFBFFFF;
00001a  6801              LDR      r1,[r0,#0]
00001c  f4212180          BIC      r1,r1,#0x40000
000020  6001              STR      r1,[r0,#0]
;;;233    
;;;234      /* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;235      RCC->CFGR &= (uint32_t)0xFF80FFFF;
000022  6841              LDR      r1,[r0,#4]
000024  f42101fe          BIC      r1,r1,#0x7f0000
000028  6041              STR      r1,[r0,#4]
;;;236    
;;;237    #ifdef STM32F10X_CL
;;;238      /* Reset PLL2ON and PLL3ON bits */
;;;239      RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;240    
;;;241      /* Disable all interrupts and clear pending bits  */
;;;242      RCC->CIR = 0x00FF0000;
;;;243    
;;;244      /* Reset CFGR2 register */
;;;245      RCC->CFGR2 = 0x00000000;
;;;246    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;247      /* Disable all interrupts and clear pending bits  */
;;;248      RCC->CIR = 0x009F0000;
;;;249    
;;;250      /* Reset CFGR2 register */
;;;251      RCC->CFGR2 = 0x00000000;      
;;;252    #else
;;;253      /* Disable all interrupts and clear pending bits  */
;;;254      RCC->CIR = 0x009F0000;
00002a  f44f011f          MOV      r1,#0x9f0000
00002e  6081              STR      r1,[r0,#8]
;;;255    #endif /* STM32F10X_CL */
;;;256    
;;;257    }
000030  4770              BX       lr
;;;258    
                          ENDP

000032  0000              DCW      0x0000
                  |L12.52|
                          DCD      0x40021000
                  |L12.56|
                          DCD      0xf8ff0000
                  |L12.60|
                          DCD      0xfef6ffff

                          AREA ||i.RCC_GetClocksFreq||, CODE, READONLY, ALIGN=2

                  RCC_GetClocksFreq PROC
;;;906      */
;;;907    void RCC_GetClocksFreq(RCC_ClocksTypeDef* RCC_Clocks)
000000  4a21              LDR      r2,|L13.136|
;;;908    {
000002  b510              PUSH     {r4,lr}
;;;909      uint32_t tmp = 0, pllmull = 0, pllsource = 0, presc = 0;
;;;910    
;;;911    #ifdef  STM32F10X_CL
;;;912      uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;913    #endif /* STM32F10X_CL */
;;;914    
;;;915    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;916      uint32_t prediv1factor = 0;
;;;917    #endif
;;;918        
;;;919      /* Get SYSCLK source -------------------------------------------------------*/
;;;920      tmp = RCC->CFGR & CFGR_SWS_Mask;
000004  6851              LDR      r1,[r2,#4]
;;;921      
;;;922      switch (tmp)
;;;923      {
;;;924        case 0x00:  /* HSI used as system clock */
;;;925          RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
000006  4b21              LDR      r3,|L13.140|
000008  f011010c          ANDS     r1,r1,#0xc            ;920
00000c  d003              BEQ      |L13.22|
00000e  2904              CMP      r1,#4                 ;922
000010  d001              BEQ      |L13.22|
000012  2908              CMP      r1,#8                 ;922
000014  d001              BEQ      |L13.26|
                  |L13.22|
;;;926          break;
000016  6003              STR      r3,[r0,#0]
000018  e012              B        |L13.64|
                  |L13.26|
;;;927        case 0x04:  /* HSE used as system clock */
;;;928          RCC_Clocks->SYSCLK_Frequency = HSE_VALUE;
;;;929          break;
;;;930        case 0x08:  /* PLL used as system clock */
;;;931    
;;;932          /* Get PLL clock source and multiplication factor ----------------------*/
;;;933          pllmull = RCC->CFGR & CFGR_PLLMull_Mask;
00001a  6851              LDR      r1,[r2,#4]
;;;934          pllsource = RCC->CFGR & CFGR_PLLSRC_Mask;
00001c  6853              LDR      r3,[r2,#4]
00001e  f4011170          AND      r1,r1,#0x3c0000       ;933
;;;935          
;;;936    #ifndef STM32F10X_CL      
;;;937          pllmull = ( pllmull >> 18) + 2;
000022  f04f0402          MOV      r4,#2
000026  f4133f80          TST      r3,#0x10000           ;934
00002a  eb044191          ADD      r1,r4,r1,LSR #18
;;;938          
;;;939          if (pllsource == 0x00)
00002e  d002              BEQ      |L13.54|
;;;940          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;941            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;942          }
;;;943          else
;;;944          {
;;;945     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || defined (STM32F10X_HD_VL)
;;;946           prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;947           /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;948           RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull; 
;;;949     #else
;;;950            /* HSE selected as PLL clock entry */
;;;951            if ((RCC->CFGR & CFGR_PLLXTPRE_Mask) != (uint32_t)RESET)
000030  6853              LDR      r3,[r2,#4]
000032  039b              LSLS     r3,r3,#14
000034  d501              BPL      |L13.58|
                  |L13.54|
000036  4b16              LDR      r3,|L13.144|
000038  e000              B        |L13.60|
                  |L13.58|
;;;952            {/* HSE oscillator clock divided by 2 */
;;;953              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE >> 1) * pllmull;
;;;954            }
;;;955            else
;;;956            {
;;;957              RCC_Clocks->SYSCLK_Frequency = HSE_VALUE * pllmull;
00003a  4b14              LDR      r3,|L13.140|
                  |L13.60|
00003c  4359              MULS     r1,r3,r1              ;953
00003e  6001              STR      r1,[r0,#0]            ;953
                  |L13.64|
;;;958            }
;;;959     #endif
;;;960          }
;;;961    #else
;;;962          pllmull = pllmull >> 18;
;;;963          
;;;964          if (pllmull != 0x0D)
;;;965          {
;;;966             pllmull += 2;
;;;967          }
;;;968          else
;;;969          { /* PLL multiplication factor = PLL input clock * 6.5 */
;;;970            pllmull = 13 / 2; 
;;;971          }
;;;972                
;;;973          if (pllsource == 0x00)
;;;974          {/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;975            RCC_Clocks->SYSCLK_Frequency = (HSI_VALUE >> 1) * pllmull;
;;;976          }
;;;977          else
;;;978          {/* PREDIV1 selected as PLL clock entry */
;;;979            
;;;980            /* Get PREDIV1 clock source and division factor */
;;;981            prediv1source = RCC->CFGR2 & CFGR2_PREDIV1SRC;
;;;982            prediv1factor = (RCC->CFGR2 & CFGR2_PREDIV1) + 1;
;;;983            
;;;984            if (prediv1source == 0)
;;;985            { /* HSE oscillator clock selected as PREDIV1 clock entry */
;;;986              RCC_Clocks->SYSCLK_Frequency = (HSE_VALUE / prediv1factor) * pllmull;          
;;;987            }
;;;988            else
;;;989            {/* PLL2 clock selected as PREDIV1 clock entry */
;;;990              
;;;991              /* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;992              prediv2factor = ((RCC->CFGR2 & CFGR2_PREDIV2) >> 4) + 1;
;;;993              pll2mull = ((RCC->CFGR2 & CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;994              RCC_Clocks->SYSCLK_Frequency = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;995            }
;;;996          }
;;;997    #endif /* STM32F10X_CL */ 
;;;998          break;
;;;999    
;;;1000       default:
;;;1001         RCC_Clocks->SYSCLK_Frequency = HSI_VALUE;
;;;1002         break;
;;;1003     }
;;;1004   
;;;1005     /* Compute HCLK, PCLK1, PCLK2 and ADCCLK clocks frequencies ----------------*/
;;;1006     /* Get HCLK prescaler */
;;;1007     tmp = RCC->CFGR & CFGR_HPRE_Set_Mask;
000040  6851              LDR      r1,[r2,#4]
;;;1008     tmp = tmp >> 4;
;;;1009     presc = APBAHBPrescTable[tmp];
000042  4b14              LDR      r3,|L13.148|
000044  f00101f0          AND      r1,r1,#0xf0           ;1007
000048  0909              LSRS     r1,r1,#4              ;1008
00004a  5c5c              LDRB     r4,[r3,r1]
;;;1010     /* HCLK clock frequency */
;;;1011     RCC_Clocks->HCLK_Frequency = RCC_Clocks->SYSCLK_Frequency >> presc;
00004c  6801              LDR      r1,[r0,#0]
00004e  40e1              LSRS     r1,r1,r4
;;;1012     /* Get PCLK1 prescaler */
;;;1013     tmp = RCC->CFGR & CFGR_PPRE1_Set_Mask;
000050  6041              STR      r1,[r0,#4]
000052  6854              LDR      r4,[r2,#4]
000054  f40464e0          AND      r4,r4,#0x700
;;;1014     tmp = tmp >> 8;
000058  0a24              LSRS     r4,r4,#8
;;;1015     presc = APBAHBPrescTable[tmp];
00005a  5d1c              LDRB     r4,[r3,r4]
;;;1016     /* PCLK1 clock frequency */
;;;1017     RCC_Clocks->PCLK1_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00005c  fa21f404          LSR      r4,r1,r4
;;;1018     /* Get PCLK2 prescaler */
;;;1019     tmp = RCC->CFGR & CFGR_PPRE2_Set_Mask;
000060  6084              STR      r4,[r0,#8]
000062  6854              LDR      r4,[r2,#4]
000064  f4045460          AND      r4,r4,#0x3800
;;;1020     tmp = tmp >> 11;
000068  0ae4              LSRS     r4,r4,#11
;;;1021     presc = APBAHBPrescTable[tmp];
00006a  5d1b              LDRB     r3,[r3,r4]
;;;1022     /* PCLK2 clock frequency */
;;;1023     RCC_Clocks->PCLK2_Frequency = RCC_Clocks->HCLK_Frequency >> presc;
00006c  40d9              LSRS     r1,r1,r3
;;;1024     /* Get ADCCLK prescaler */
;;;1025     tmp = RCC->CFGR & CFGR_ADCPRE_Set_Mask;
00006e  60c1              STR      r1,[r0,#0xc]
000070  6852              LDR      r2,[r2,#4]
;;;1026     tmp = tmp >> 14;
;;;1027     presc = ADCPrescTable[tmp];
000072  4b08              LDR      r3,|L13.148|
000074  f4024240          AND      r2,r2,#0xc000         ;1025
000078  0b92              LSRS     r2,r2,#14             ;1026
00007a  1f1b              SUBS     r3,r3,#4
00007c  5c9a              LDRB     r2,[r3,r2]
;;;1028     /* ADCCLK clock frequency */
;;;1029     RCC_Clocks->ADCCLK_Frequency = RCC_Clocks->PCLK2_Frequency / presc;
00007e  fbb1f1f2          UDIV     r1,r1,r2
000082  6101              STR      r1,[r0,#0x10]
;;;1030   }
000084  bd10              POP      {r4,pc}
;;;1031   
                          ENDP

000086  0000              DCW      0x0000
                  |L13.136|
                          DCD      0x40021000
                  |L13.140|
                          DCD      0x007a1200
                  |L13.144|
                          DCD      0x003d0900
                  |L13.148|
                          DCD      ||.data||+0x4

                          AREA ||i.RCC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetFlagStatus PROC
;;;1324     */
;;;1325   FlagStatus RCC_GetFlagStatus(uint8_t RCC_FLAG)
000000  4603              MOV      r3,r0
;;;1326   {
;;;1327     uint32_t tmp = 0;
;;;1328     uint32_t statusreg = 0;
;;;1329     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1330     /* Check the parameters */
;;;1331     assert_param(IS_RCC_FLAG(RCC_FLAG));
;;;1332   
;;;1333     /* Get the RCC register index */
;;;1334     tmp = RCC_FLAG >> 5;
000004  0959              LSRS     r1,r3,#5
;;;1335     if (tmp == 1)               /* The flag to check is in CR register */
;;;1336     {
;;;1337       statusreg = RCC->CR;
000006  4a09              LDR      r2,|L14.44|
000008  2901              CMP      r1,#1                 ;1335
00000a  d00a              BEQ      |L14.34|
;;;1338     }
;;;1339     else if (tmp == 2)          /* The flag to check is in BDCR register */
00000c  2902              CMP      r1,#2
00000e  d00a              BEQ      |L14.38|
;;;1340     {
;;;1341       statusreg = RCC->BDCR;
;;;1342     }
;;;1343     else                       /* The flag to check is in CSR register */
;;;1344     {
;;;1345       statusreg = RCC->CSR;
000010  6a51              LDR      r1,[r2,#0x24]
                  |L14.18|
;;;1346     }
;;;1347   
;;;1348     /* Get the flag position */
;;;1349     tmp = RCC_FLAG & FLAG_Mask;
000012  f003021f          AND      r2,r3,#0x1f
;;;1350     if ((statusreg & ((uint32_t)1 << tmp)) != (uint32_t)RESET)
000016  2301              MOVS     r3,#1
000018  4093              LSLS     r3,r3,r2
00001a  420b              TST      r3,r1
00001c  d000              BEQ      |L14.32|
;;;1351     {
;;;1352       bitstatus = SET;
00001e  2001              MOVS     r0,#1
                  |L14.32|
;;;1353     }
;;;1354     else
;;;1355     {
;;;1356       bitstatus = RESET;
;;;1357     }
;;;1358   
;;;1359     /* Return the flag status */
;;;1360     return bitstatus;
;;;1361   }
000020  4770              BX       lr
                  |L14.34|
000022  6811              LDR      r1,[r2,#0]            ;1337
000024  e7f5              B        |L14.18|
                  |L14.38|
000026  6a11              LDR      r1,[r2,#0x20]         ;1341
000028  e7f3              B        |L14.18|
;;;1362   
                          ENDP

00002a  0000              DCW      0x0000
                  |L14.44|
                          DCD      0x40021000

                          AREA ||i.RCC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RCC_GetITStatus PROC
;;;1400     */
;;;1401   ITStatus RCC_GetITStatus(uint8_t RCC_IT)
000000  4a03              LDR      r2,|L15.16|
;;;1402   {
000002  4601              MOV      r1,r0
;;;1403     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1404     /* Check the parameters */
;;;1405     assert_param(IS_RCC_GET_IT(RCC_IT));
;;;1406   
;;;1407     /* Check the status of the specified RCC interrupt */
;;;1408     if ((RCC->CIR & RCC_IT) != (uint32_t)RESET)
000006  6892              LDR      r2,[r2,#8]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L15.14|
;;;1409     {
;;;1410       bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L15.14|
;;;1411     }
;;;1412     else
;;;1413     {
;;;1414       bitstatus = RESET;
;;;1415     }
;;;1416   
;;;1417     /* Return the RCC_IT status */
;;;1418     return  bitstatus;
;;;1419   }
00000e  4770              BX       lr
;;;1420   
                          ENDP

                  |L15.16|
                          DCD      0x40021000

                          AREA ||i.RCC_GetSYSCLKSource||, CODE, READONLY, ALIGN=2

                  RCC_GetSYSCLKSource PROC
;;;585      */
;;;586    uint8_t RCC_GetSYSCLKSource(void)
000000  4802              LDR      r0,|L16.12|
;;;587    {
;;;588      return ((uint8_t)(RCC->CFGR & CFGR_SWS_Mask));
000002  6840              LDR      r0,[r0,#4]
000004  f000000c          AND      r0,r0,#0xc
;;;589    }
000008  4770              BX       lr
;;;590    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x40021000

                          AREA ||i.RCC_HCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_HCLKConfig PROC
;;;606      */
;;;607    void RCC_HCLKConfig(uint32_t RCC_SYSCLK)
000000  4a03              LDR      r2,|L17.16|
;;;608    {
;;;609      uint32_t tmpreg = 0;
;;;610      /* Check the parameters */
;;;611      assert_param(IS_RCC_HCLK(RCC_SYSCLK));
;;;612      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;613      /* Clear HPRE[3:0] bits */
;;;614      tmpreg &= CFGR_HPRE_Reset_Mask;
000004  f02101f0          BIC      r1,r1,#0xf0
;;;615      /* Set HPRE[3:0] bits according to RCC_SYSCLK value */
;;;616      tmpreg |= RCC_SYSCLK;
000008  4301              ORRS     r1,r1,r0
;;;617      /* Store the new value */
;;;618      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;619    }
00000c  4770              BX       lr
;;;620    
                          ENDP

00000e  0000              DCW      0x0000
                  |L17.16|
                          DCD      0x40021000

                          AREA ||i.RCC_HSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_HSEConfig PROC
;;;268      */
;;;269    void RCC_HSEConfig(uint32_t RCC_HSE)
000000  490b              LDR      r1,|L18.48|
;;;270    {
;;;271      /* Check the parameters */
;;;272      assert_param(IS_RCC_HSE(RCC_HSE));
;;;273      /* Reset HSEON and HSEBYP bits before configuring the HSE ------------------*/
;;;274      /* Reset HSEON bit */
;;;275      RCC->CR &= CR_HSEON_Reset;
000002  680a              LDR      r2,[r1,#0]
000004  f4223280          BIC      r2,r2,#0x10000
000008  600a              STR      r2,[r1,#0]
;;;276      /* Reset HSEBYP bit */
;;;277      RCC->CR &= CR_HSEBYP_Reset;
00000a  680a              LDR      r2,[r1,#0]
00000c  f4222280          BIC      r2,r2,#0x40000
000010  600a              STR      r2,[r1,#0]
;;;278      /* Configure HSE (RCC_HSE_OFF is already covered by the code section above) */
;;;279      switch(RCC_HSE)
000012  f5b03f80          CMP      r0,#0x10000
000016  d007              BEQ      |L18.40|
000018  f5b02f80          CMP      r0,#0x40000
00001c  d103              BNE      |L18.38|
;;;280      {
;;;281        case RCC_HSE_ON:
;;;282          /* Set HSEON bit */
;;;283          RCC->CR |= CR_HSEON_Set;
;;;284          break;
;;;285          
;;;286        case RCC_HSE_Bypass:
;;;287          /* Set HSEBYP and HSEON bits */
;;;288          RCC->CR |= CR_HSEBYP_Set | CR_HSEON_Set;
00001e  6808              LDR      r0,[r1,#0]
000020  f44020a0          ORR      r0,r0,#0x50000
                  |L18.36|
000024  6008              STR      r0,[r1,#0]
                  |L18.38|
;;;289          break;
;;;290          
;;;291        default:
;;;292          break;
;;;293      }
;;;294    }
000026  4770              BX       lr
                  |L18.40|
000028  6808              LDR      r0,[r1,#0]            ;283
00002a  f4403080          ORR      r0,r0,#0x10000        ;283
00002e  e7f9              B        |L18.36|
;;;295    
                          ENDP

                  |L18.48|
                          DCD      0x40021000

                          AREA ||i.RCC_HSICmd||, CODE, READONLY, ALIGN=2

                  RCC_HSICmd PROC
;;;352      */
;;;353    void RCC_HSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L19.8|
;;;354    {
;;;355      /* Check the parameters */
;;;356      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;357      *(__IO uint32_t *) CR_HSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;358    }
000004  4770              BX       lr
;;;359    
                          ENDP

000006  0000              DCW      0x0000
                  |L19.8|
                          DCD      0x42420000

                          AREA ||i.RCC_ITConfig||, CODE, READONLY, ALIGN=2

                  RCC_ITConfig PROC
;;;698      */
;;;699    void RCC_ITConfig(uint8_t RCC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L20.20|
;;;700    {
;;;701      /* Check the parameters */
;;;702      assert_param(IS_RCC_IT(RCC_IT));
;;;703      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;704      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;705      {
;;;706        /* Perform Byte access to RCC_CIR bits to enable the selected interrupts */
;;;707        *(__IO uint8_t *) CIR_BYTE2_ADDRESS |= RCC_IT;
;;;708      }
;;;709      else
;;;710      {
;;;711        /* Perform Byte access to RCC_CIR bits to disable the selected interrupts */
;;;712        *(__IO uint8_t *) CIR_BYTE2_ADDRESS &= (uint8_t)~RCC_IT;
000004  7a51              LDRB     r1,[r2,#9]
000006  d001              BEQ      |L20.12|
000008  4301              ORRS     r1,r1,r0              ;707
00000a  e000              B        |L20.14|
                  |L20.12|
00000c  4381              BICS     r1,r1,r0
                  |L20.14|
00000e  7251              STRB     r1,[r2,#9]            ;707
;;;713      }
;;;714    }
000010  4770              BX       lr
;;;715    
                          ENDP

000012  0000              DCW      0x0000
                  |L20.20|
                          DCD      0x40021000

                          AREA ||i.RCC_LSEConfig||, CODE, READONLY, ALIGN=2

                  RCC_LSEConfig PROC
;;;827      */
;;;828    void RCC_LSEConfig(uint8_t RCC_LSE)
000000  4906              LDR      r1,|L21.28|
;;;829    {
;;;830      /* Check the parameters */
;;;831      assert_param(IS_RCC_LSE(RCC_LSE));
;;;832      /* Reset LSEON and LSEBYP bits before configuring the LSE ------------------*/
;;;833      /* Reset LSEON bit */
;;;834      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000002  2200              MOVS     r2,#0
000004  700a              STRB     r2,[r1,#0]
;;;835      /* Reset LSEBYP bit */
;;;836      *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_OFF;
000006  f8012920          STRB     r2,[r1],#-0x20
;;;837      /* Configure LSE (RCC_LSE_OFF is already covered by the code section above) */
;;;838      switch(RCC_LSE)
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L21.20|
00000e  2804              CMP      r0,#4
000010  d102              BNE      |L21.24|
;;;839      {
;;;840        case RCC_LSE_ON:
;;;841          /* Set LSEON bit */
;;;842          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_ON;
;;;843          break;
;;;844          
;;;845        case RCC_LSE_Bypass:
;;;846          /* Set LSEBYP and LSEON bits */
;;;847          *(__IO uint8_t *) BDCR_ADDRESS = RCC_LSE_Bypass | RCC_LSE_ON;
000012  2005              MOVS     r0,#5
                  |L21.20|
000014  f8810020          STRB     r0,[r1,#0x20]
                  |L21.24|
;;;848          break;            
;;;849          
;;;850        default:
;;;851          break;      
;;;852      }
;;;853    }
000018  4770              BX       lr
;;;854    
                          ENDP

00001a  0000              DCW      0x0000
                  |L21.28|
                          DCD      0x40021020

                          AREA ||i.RCC_LSICmd||, CODE, READONLY, ALIGN=2

                  RCC_LSICmd PROC
;;;860      */
;;;861    void RCC_LSICmd(FunctionalState NewState)
000000  4901              LDR      r1,|L22.8|
;;;862    {
;;;863      /* Check the parameters */
;;;864      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;865      *(__IO uint32_t *) CSR_LSION_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;866    }
000004  4770              BX       lr
;;;867    
                          ENDP

000006  0000              DCW      0x0000
                  |L22.8|
                          DCD      0x42420480

                          AREA ||i.RCC_MCOConfig||, CODE, READONLY, ALIGN=2

                  RCC_MCOConfig PROC
;;;1280     */
;;;1281   void RCC_MCOConfig(uint8_t RCC_MCO)
000000  4901              LDR      r1,|L23.8|
;;;1282   {
;;;1283     /* Check the parameters */
;;;1284     assert_param(IS_RCC_MCO(RCC_MCO));
;;;1285   
;;;1286     /* Perform Byte access to MCO bits to select the MCO source */
;;;1287     *(__IO uint8_t *) CFGR_BYTE4_ADDRESS = RCC_MCO;
000002  71c8              STRB     r0,[r1,#7]
;;;1288   }
000004  4770              BX       lr
;;;1289   
                          ENDP

000006  0000              DCW      0x0000
                  |L23.8|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK1Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK1Config PROC
;;;632      */
;;;633    void RCC_PCLK1Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L24.16|
;;;634    {
;;;635      uint32_t tmpreg = 0;
;;;636      /* Check the parameters */
;;;637      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;638      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;639      /* Clear PPRE1[2:0] bits */
;;;640      tmpreg &= CFGR_PPRE1_Reset_Mask;
000004  f42161e0          BIC      r1,r1,#0x700
;;;641      /* Set PPRE1[2:0] bits according to RCC_HCLK value */
;;;642      tmpreg |= RCC_HCLK;
000008  4301              ORRS     r1,r1,r0
;;;643      /* Store the new value */
;;;644      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;645    }
00000c  4770              BX       lr
;;;646    
                          ENDP

00000e  0000              DCW      0x0000
                  |L24.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PCLK2Config||, CODE, READONLY, ALIGN=2

                  RCC_PCLK2Config PROC
;;;658      */
;;;659    void RCC_PCLK2Config(uint32_t RCC_HCLK)
000000  4a03              LDR      r2,|L25.16|
;;;660    {
;;;661      uint32_t tmpreg = 0;
;;;662      /* Check the parameters */
;;;663      assert_param(IS_RCC_PCLK(RCC_HCLK));
;;;664      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;665      /* Clear PPRE2[2:0] bits */
;;;666      tmpreg &= CFGR_PPRE2_Reset_Mask;
000004  f4215160          BIC      r1,r1,#0x3800
;;;667      /* Set PPRE2[2:0] bits according to RCC_HCLK value */
;;;668      tmpreg |= RCC_HCLK << 3;
000008  ea4100c0          ORR      r0,r1,r0,LSL #3
;;;669      /* Store the new value */
;;;670      RCC->CFGR = tmpreg;
00000c  6050              STR      r0,[r2,#4]
;;;671    }
00000e  4770              BX       lr
;;;672    
                          ENDP

                  |L25.16|
                          DCD      0x40021000

                          AREA ||i.RCC_PLLCmd||, CODE, READONLY, ALIGN=2

                  RCC_PLLCmd PROC
;;;399      */
;;;400    void RCC_PLLCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L26.8|
;;;401    {
;;;402      /* Check the parameters */
;;;403      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;404    
;;;405      *(__IO uint32_t *) CR_PLLON_BB = (uint32_t)NewState;
000002  6608              STR      r0,[r1,#0x60]
;;;406    }
000004  4770              BX       lr
;;;407    
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      0x42420000

                          AREA ||i.RCC_PLLConfig||, CODE, READONLY, ALIGN=2

                  RCC_PLLConfig PROC
;;;376      */
;;;377    void RCC_PLLConfig(uint32_t RCC_PLLSource, uint32_t RCC_PLLMul)
000000  4b03              LDR      r3,|L27.16|
;;;378    {
;;;379      uint32_t tmpreg = 0;
;;;380    
;;;381      /* Check the parameters */
;;;382      assert_param(IS_RCC_PLL_SOURCE(RCC_PLLSource));
;;;383      assert_param(IS_RCC_PLL_MUL(RCC_PLLMul));
;;;384    
;;;385      tmpreg = RCC->CFGR;
000002  685a              LDR      r2,[r3,#4]
;;;386      /* Clear PLLSRC, PLLXTPRE and PLLMUL[3:0] bits */
;;;387      tmpreg &= CFGR_PLL_Mask;
;;;388      /* Set the PLL configuration bits */
;;;389      tmpreg |= RCC_PLLSource | RCC_PLLMul;
000004  4308              ORRS     r0,r0,r1
000006  f422127c          BIC      r2,r2,#0x3f0000       ;387
00000a  4310              ORRS     r0,r0,r2
;;;390      /* Store the new value */
;;;391      RCC->CFGR = tmpreg;
00000c  6058              STR      r0,[r3,#4]
;;;392    }
00000e  4770              BX       lr
;;;393    
                          ENDP

                  |L27.16|
                          DCD      0x40021000

                          AREA ||i.RCC_RTCCLKCmd||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKCmd PROC
;;;891      */
;;;892    void RCC_RTCCLKCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L28.8|
;;;893    {
;;;894      /* Check the parameters */
;;;895      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;896      *(__IO uint32_t *) BDCR_RTCEN_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
;;;897    }
000004  4770              BX       lr
;;;898    
                          ENDP

000006  0000              DCW      0x0000
                  |L28.8|
                          DCD      0x4242043c

                          AREA ||i.RCC_RTCCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_RTCCLKConfig PROC
;;;877      */
;;;878    void RCC_RTCCLKConfig(uint32_t RCC_RTCCLKSource)
000000  4902              LDR      r1,|L29.12|
;;;879    {
;;;880      /* Check the parameters */
;;;881      assert_param(IS_RCC_RTCCLK_SOURCE(RCC_RTCCLKSource));
;;;882      /* Select the RTC clock source */
;;;883      RCC->BDCR |= RCC_RTCCLKSource;
000002  6a0a              LDR      r2,[r1,#0x20]
000004  4302              ORRS     r2,r2,r0
000006  620a              STR      r2,[r1,#0x20]
;;;884    }
000008  4770              BX       lr
;;;885    
                          ENDP

00000a  0000              DCW      0x0000
                  |L29.12|
                          DCD      0x40021000

                          AREA ||i.RCC_SYSCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_SYSCLKConfig PROC
;;;562      */
;;;563    void RCC_SYSCLKConfig(uint32_t RCC_SYSCLKSource)
000000  4a03              LDR      r2,|L30.16|
;;;564    {
;;;565      uint32_t tmpreg = 0;
;;;566      /* Check the parameters */
;;;567      assert_param(IS_RCC_SYSCLK_SOURCE(RCC_SYSCLKSource));
;;;568      tmpreg = RCC->CFGR;
000002  6851              LDR      r1,[r2,#4]
;;;569      /* Clear SW[1:0] bits */
;;;570      tmpreg &= CFGR_SW_Mask;
000004  f0210103          BIC      r1,r1,#3
;;;571      /* Set SW[1:0] bits according to RCC_SYSCLKSource value */
;;;572      tmpreg |= RCC_SYSCLKSource;
000008  4301              ORRS     r1,r1,r0
;;;573      /* Store the new value */
;;;574      RCC->CFGR = tmpreg;
00000a  6051              STR      r1,[r2,#4]
;;;575    }
00000c  4770              BX       lr
;;;576    
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      0x40021000

                          AREA ||i.RCC_USBCLKConfig||, CODE, READONLY, ALIGN=2

                  RCC_USBCLKConfig PROC
;;;726      */
;;;727    void RCC_USBCLKConfig(uint32_t RCC_USBCLKSource)
000000  4901              LDR      r1,|L31.8|
;;;728    {
;;;729      /* Check the parameters */
;;;730      assert_param(IS_RCC_USBCLK_SOURCE(RCC_USBCLKSource));
;;;731    
;;;732      *(__IO uint32_t *) CFGR_USBPRE_BB = RCC_USBCLKSource;
000002  6008              STR      r0,[r1,#0]
;;;733    }
000004  4770              BX       lr
;;;734    #else
                          ENDP

000006  0000              DCW      0x0000
                  |L31.8|
                          DCD      0x424200d8

                          AREA ||i.RCC_WaitForHSEStartUp||, CODE, READONLY, ALIGN=1

                  RCC_WaitForHSEStartUp PROC
;;;302      */
;;;303    ErrorStatus RCC_WaitForHSEStartUp(void)
000000  b530              PUSH     {r4,r5,lr}
;;;304    {
;;;305      __IO uint32_t StartUpCounter = 0;
000002  2400              MOVS     r4,#0
;;;306      ErrorStatus status = ERROR;
;;;307      FlagStatus HSEStatus = RESET;
;;;308      
;;;309      /* Wait till HSE is ready and if Time out is reached exit */
;;;310      do
;;;311      {
;;;312        HSEStatus = RCC_GetFlagStatus(RCC_FLAG_HSERDY);
;;;313        StartUpCounter++;  
;;;314      } while((StartUpCounter != HSE_STARTUP_TIMEOUT) && (HSEStatus == RESET));
000004  f44f65a0          MOV      r5,#0x500
                  |L32.8|
000008  2031              MOVS     r0,#0x31              ;312
00000a  f7fffffe          BL       RCC_GetFlagStatus
00000e  1c64              ADDS     r4,r4,#1              ;313
000010  42ac              CMP      r4,r5
000012  d001              BEQ      |L32.24|
000014  2800              CMP      r0,#0
000016  d0f7              BEQ      |L32.8|
                  |L32.24|
;;;315      
;;;316      if (RCC_GetFlagStatus(RCC_FLAG_HSERDY) != RESET)
000018  2031              MOVS     r0,#0x31
00001a  f7fffffe          BL       RCC_GetFlagStatus
00001e  2800              CMP      r0,#0
000020  d000              BEQ      |L32.36|
;;;317      {
;;;318        status = SUCCESS;
000022  2001              MOVS     r0,#1
                  |L32.36|
;;;319      }
;;;320      else
;;;321      {
;;;322        status = ERROR;
;;;323      }  
;;;324      return (status);
;;;325    }
000024  bd30              POP      {r4,r5,pc}
;;;326    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=0

                  ADCPrescTable
000000  02040608          DCB      0x02,0x04,0x06,0x08
                  APBAHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  01020304          DCB      0x01,0x02,0x03,0x04
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_rcc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_rcc_c_49e27980____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_rcc_c_49e27980____REVSH|
#line 128
|__asm___15_stm32f10x_rcc_c_49e27980____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
