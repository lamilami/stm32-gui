; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\os_mbox.o --depend=.\ouput\os_mbox.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\os_mbox.crf Source\uCOS-II\Source\os_mbox.c]
                          THUMB

                          AREA ||i.OSMboxAccept||, CODE, READONLY, ALIGN=1

                  OSMboxAccept PROC
;;;46     #if OS_MBOX_ACCEPT_EN > 0u
;;;47     void  *OSMboxAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;48     {
000002  0004              MOVS     r4,r0
;;;49         void      *pmsg;
;;;50     #if OS_CRITICAL_METHOD == 3u                              /* Allocate storage for CPU status register  */
;;;51         OS_CPU_SR  cpu_sr = 0u;
;;;52     #endif
;;;53     
;;;54     
;;;55     
;;;56     #if OS_ARG_CHK_EN > 0u
;;;57         if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
000004  d002              BEQ      |L1.12|
;;;58             return ((void *)0);
;;;59         }
;;;60     #endif
;;;61         if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
000006  7820              LDRB     r0,[r4,#0]
000008  2801              CMP      r0,#1
00000a  d001              BEQ      |L1.16|
                  |L1.12|
;;;62             return ((void *)0);
00000c  2000              MOVS     r0,#0
;;;63         }
;;;64         OS_ENTER_CRITICAL();
;;;65         pmsg               = pevent->OSEventPtr;
;;;66         pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
;;;67         OS_EXIT_CRITICAL();
;;;68         return (pmsg);                                        /* Return the message received (or NULL)     */
;;;69     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  2100              MOVS     r1,#0                 ;66
000016  6865              LDR      r5,[r4,#4]            ;66
000018  6061              STR      r1,[r4,#4]            ;67
00001a  f7fffffe          BL       OS_CPU_SR_Restore
00001e  4628              MOV      r0,r5                 ;68
000020  bd70              POP      {r4-r6,pc}
;;;70     #endif
                          ENDP


                          AREA ||i.OSMboxCreate||, CODE, READONLY, ALIGN=2

                  OSMboxCreate PROC
;;;87     
;;;88     OS_EVENT  *OSMboxCreate (void *pmsg)
000000  b570              PUSH     {r4-r6,lr}
;;;89     {
000002  4605              MOV      r5,r0
;;;90         OS_EVENT  *pevent;
;;;91     #if OS_CRITICAL_METHOD == 3u                     /* Allocate storage for CPU status register           */
;;;92         OS_CPU_SR  cpu_sr = 0u;
;;;93     #endif
;;;94     
;;;95     
;;;96     
;;;97     #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;98         if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;99             OS_SAFETY_CRITICAL_EXCEPTION();
;;;100        }
;;;101    #endif
;;;102    
;;;103        if (OSIntNesting > 0u) {                     /* See if called from ISR ...                         */
000004  480d              LDR      r0,|L2.60|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000008  b108              CBZ      r0,|L2.14|
;;;104            return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
00000a  2000              MOVS     r0,#0
;;;105        }
;;;106        OS_ENTER_CRITICAL();
;;;107        pevent = OSEventFreeList;                    /* Get next free event control block                  */
;;;108        if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
;;;109            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;110        }
;;;111        OS_EXIT_CRITICAL();
;;;112        if (pevent != (OS_EVENT *)0) {
;;;113            pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
;;;114            pevent->OSEventCnt     = 0u;
;;;115            pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
;;;116    #if OS_EVENT_NAME_EN > 0u
;;;117            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;118    #endif
;;;119            OS_EventWaitListInit(pevent);
;;;120        }
;;;121        return (pevent);                             /* Return pointer to event control block              */
;;;122    }
00000c  bd70              POP      {r4-r6,pc}
                  |L2.14|
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  490b              LDR      r1,|L2.64|
000014  680c              LDR      r4,[r1,#0]            ;108  ; OSEventFreeList
000016  b10c              CBZ      r4,|L2.28|
000018  6862              LDR      r2,[r4,#4]            ;109
00001a  600a              STR      r2,[r1,#0]            ;109  ; OSEventFreeList
                  |L2.28|
00001c  f7fffffe          BL       OS_CPU_SR_Restore
000020  b14c              CBZ      r4,|L2.54|
000022  2001              MOVS     r0,#1                 ;113
000024  7020              STRB     r0,[r4,#0]            ;113
000026  2000              MOVS     r0,#0                 ;114
000028  8120              STRH     r0,[r4,#8]            ;114
00002a  a006              ADR      r0,|L2.68|
00002c  6065              STR      r5,[r4,#4]            ;119
00002e  6160              STR      r0,[r4,#0x14]         ;119
000030  4620              MOV      r0,r4                 ;119
000032  f7fffffe          BL       OS_EventWaitListInit
                  |L2.54|
000036  4620              MOV      r0,r4                 ;121
000038  bd70              POP      {r4-r6,pc}
;;;123    /*$PAGE*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      OSIntNesting
                  |L2.64|
                          DCD      OSEventFreeList
                  |L2.68|
000044  3f00              DCB      "?",0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.OSMboxPend||, CODE, READONLY, ALIGN=2

                  OSMboxPend PROC
;;;281    /*$PAGE*/
;;;282    void  *OSMboxPend (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;283                       INT32U     timeout,
;;;284                       INT8U     *perr)
;;;285    {
000004  0005              MOVS     r5,r0
000006  468a              MOV      r10,r1
000008  4614              MOV      r4,r2
;;;286        void      *pmsg;
;;;287    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;288        OS_CPU_SR  cpu_sr = 0u;
;;;289    #endif
;;;290    
;;;291    
;;;292    
;;;293    #ifdef OS_SAFETY_CRITICAL
;;;294        if (perr == (INT8U *)0) {
;;;295            OS_SAFETY_CRITICAL_EXCEPTION();
;;;296        }
;;;297    #endif
;;;298    
;;;299    #if OS_ARG_CHK_EN > 0u
;;;300        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00000a  d004              BEQ      |L3.22|
;;;301            *perr = OS_ERR_PEVENT_NULL;
;;;302            return ((void *)0);
;;;303        }
;;;304    #endif
;;;305        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2801              CMP      r0,#1
000010  d003              BEQ      |L3.26|
;;;306            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
;;;307            return ((void *)0);
000014  e00a              B        |L3.44|
                  |L3.22|
000016  2004              MOVS     r0,#4                 ;301
000018  e008              B        |L3.44|
                  |L3.26|
;;;308        }
;;;309        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00001a  482b              LDR      r0,|L3.200|
00001c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001e  b108              CBZ      r0,|L3.36|
;;;310            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
000020  2002              MOVS     r0,#2
;;;311            return ((void *)0);
000022  e003              B        |L3.44|
                  |L3.36|
;;;312        }
;;;313        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000024  4829              LDR      r0,|L3.204|
000026  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000028  b120              CBZ      r0,|L3.52|
;;;314            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002a  200d              MOVS     r0,#0xd
                  |L3.44|
00002c  7010              STRB     r0,[r2,#0]
;;;315            return ((void *)0);
00002e  2000              MOVS     r0,#0
                  |L3.48|
;;;316        }
;;;317        OS_ENTER_CRITICAL();
;;;318        pmsg = pevent->OSEventPtr;
;;;319        if (pmsg != (void *)0) {                          /* See if there is already a message             */
;;;320            pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
;;;321            OS_EXIT_CRITICAL();
;;;322            *perr = OS_ERR_NONE;
;;;323            return (pmsg);                                /* Return the message received (or NULL)         */
;;;324        }
;;;325        OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
;;;326        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;327        OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
;;;328        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;329        OS_EXIT_CRITICAL();
;;;330        OS_Sched();                                       /* Find next highest priority task ready to run  */
;;;331        OS_ENTER_CRITICAL();
;;;332        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;333            case OS_STAT_PEND_OK:
;;;334                 pmsg =  OSTCBCur->OSTCBMsg;
;;;335                *perr =  OS_ERR_NONE;
;;;336                 break;
;;;337    
;;;338            case OS_STAT_PEND_ABORT:
;;;339                 pmsg = (void *)0;
;;;340                *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;341                 break;
;;;342    
;;;343            case OS_STAT_PEND_TO:
;;;344            default:
;;;345                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;346                 pmsg = (void *)0;
;;;347                *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;348                 break;
;;;349        }
;;;350        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;351        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;352        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;353    #if (OS_EVENT_MULTI_EN > 0u)
;;;354        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;355    #endif
;;;356        OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
;;;357        OS_EXIT_CRITICAL();
;;;358        return (pmsg);                                    /* Return received message                       */
;;;359    }
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L3.52|
000034  f7fffffe          BL       OS_CPU_SR_Save
000038  686e              LDR      r6,[r5,#4]            ;319
00003a  4607              MOV      r7,r0                 ;317
00003c  2100              MOVS     r1,#0                 ;288
00003e  b13e              CBZ      r6,|L3.80|
000040  4688              MOV      r8,r1                 ;320
000042  4638              MOV      r0,r7                 ;321
000044  6069              STR      r1,[r5,#4]            ;321
000046  f7fffffe          BL       OS_CPU_SR_Restore
00004a  f8848000          STRB     r8,[r4,#0]            ;322
00004e  e038              B        |L3.194|
                  |L3.80|
000050  f8df907c          LDR      r9,|L3.208|
000054  4688              MOV      r8,r1                 ;326
000056  f8d90000          LDR      r0,[r9,#0]            ;325  ; OSTCBCur
00005a  f8102f28          LDRB     r2,[r0,#0x28]!        ;325
00005e  f0420202          ORR      r2,r2,#2              ;325
000062  7002              STRB     r2,[r0,#0]            ;325
000064  7041              STRB     r1,[r0,#1]            ;326
000066  f840ac04          STR      r10,[r0,#-4]          ;327
00006a  4628              MOV      r0,r5                 ;328
00006c  f7fffffe          BL       OS_EventTaskWait
000070  4638              MOV      r0,r7                 ;329
000072  f7fffffe          BL       OS_CPU_SR_Restore
000076  f7fffffe          BL       OS_Sched
00007a  f7fffffe          BL       OS_CPU_SR_Save
00007e  4607              MOV      r7,r0                 ;331
000080  f8d90000          LDR      r0,[r9,#0]            ;332  ; OSTCBCur
000084  f8901029          LDRB     r1,[r0,#0x29]         ;332
000088  b131              CBZ      r1,|L3.152|
00008a  2902              CMP      r1,#2                 ;332
00008c  d008              BEQ      |L3.160|
00008e  4629              MOV      r1,r5                 ;345
000090  f7fffffe          BL       OS_EventTaskRemove
000094  200a              MOVS     r0,#0xa               ;347
000096  e004              B        |L3.162|
                  |L3.152|
000098  6a06              LDR      r6,[r0,#0x20]         ;335
00009a  f8848000          STRB     r8,[r4,#0]            ;335
00009e  e001              B        |L3.164|
                  |L3.160|
0000a0  200e              MOVS     r0,#0xe               ;340
                  |L3.162|
0000a2  7020              STRB     r0,[r4,#0]            ;340
                  |L3.164|
0000a4  f8d90000          LDR      r0,[r9,#0]            ;350  ; OSTCBCur
0000a8  f100001c          ADD      r0,r0,#0x1c           ;350
0000ac  f880800c          STRB     r8,[r0,#0xc]          ;350
0000b0  f880800d          STRB     r8,[r0,#0xd]          ;351
0000b4  f8c08000          STR      r8,[r0,#0]            ;356
0000b8  f8c08004          STR      r8,[r0,#4]            ;357
0000bc  4638              MOV      r0,r7                 ;357
0000be  f7fffffe          BL       OS_CPU_SR_Restore
                  |L3.194|
0000c2  4630              MOV      r0,r6                 ;358
0000c4  e7b4              B        |L3.48|
;;;360    /*$PAGE*/
                          ENDP

0000c6  0000              DCW      0x0000
                  |L3.200|
                          DCD      OSIntNesting
                  |L3.204|
                          DCD      OSLockNesting
                  |L3.208|
                          DCD      OSTCBCur

                          AREA ||i.OSMboxPendAbort||, CODE, READONLY, ALIGN=1

                  OSMboxPendAbort PROC
;;;393    #if OS_MBOX_PEND_ABORT_EN > 0u
;;;394    INT8U  OSMboxPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;395                            INT8U      opt,
;;;396                            INT8U     *perr)
;;;397    {
000004  0005              MOVS     r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;398        INT8U      nbr_tasks;
;;;399    #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;400        OS_CPU_SR  cpu_sr = 0u;
;;;401    #endif
;;;402    
;;;403    
;;;404    
;;;405    #ifdef OS_SAFETY_CRITICAL
;;;406        if (perr == (INT8U *)0) {
;;;407            OS_SAFETY_CRITICAL_EXCEPTION();
;;;408        }
;;;409    #endif
;;;410    
;;;411    #if OS_ARG_CHK_EN > 0u
;;;412        if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
00000a  d005              BEQ      |L4.24|
;;;413            *perr = OS_ERR_PEVENT_NULL;
;;;414            return (0u);
;;;415        }
;;;416    #endif
;;;417        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
00000c  7829              LDRB     r1,[r5,#0]
00000e  2001              MOVS     r0,#1
000010  2901              CMP      r1,#1
000012  d003              BEQ      |L4.28|
                  |L4.20|
;;;418            *perr = OS_ERR_EVENT_TYPE;
000014  7010              STRB     r0,[r2,#0]
;;;419            return (0u);
000016  e02b              B        |L4.112|
                  |L4.24|
000018  2004              MOVS     r0,#4                 ;413
00001a  e7fb              B        |L4.20|
                  |L4.28|
;;;420        }
;;;421        OS_ENTER_CRITICAL();
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0
;;;422        if (pevent->OSEventGrp != 0u) {                        /* See if any task waiting on mailbox?      */
000022  7aa8              LDRB     r0,[r5,#0xa]
000024  b1f8              CBZ      r0,|L4.102|
;;;423            nbr_tasks = 0u;
000026  2400              MOVS     r4,#0
;;;424            switch (opt) {
000028  2f01              CMP      r7,#1
00002a  d010              BEQ      |L4.78|
;;;425                case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
;;;426                     while (pevent->OSEventGrp != 0u) {        /* Yes, ready ALL tasks waiting on mailbox  */
;;;427                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
;;;428                         nbr_tasks++;
;;;429                     }
;;;430                     break;
;;;431    
;;;432                case OS_PEND_OPT_NONE:
;;;433                default:                                       /* No,  ready HPT       waiting on mailbox  */
;;;434                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
00002c  2302              MOVS     r3,#2
00002e  461a              MOV      r2,r3
000030  2100              MOVS     r1,#0
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       OS_EventTaskRdy
;;;435                     nbr_tasks++;
000038  2401              MOVS     r4,#1
                  |L4.58|
;;;436                     break;
;;;437            }
;;;438            OS_EXIT_CRITICAL();
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       OS_CPU_SR_Restore
;;;439            OS_Sched();                                        /* Find HPT ready to run                    */
000040  f7fffffe          BL       OS_Sched
;;;440            *perr = OS_ERR_PEND_ABORT;
000044  200e              MOVS     r0,#0xe
000046  7030              STRB     r0,[r6,#0]
;;;441            return (nbr_tasks);
000048  4620              MOV      r0,r4
                  |L4.74|
;;;442        }
;;;443        OS_EXIT_CRITICAL();
;;;444        *perr = OS_ERR_NONE;
;;;445        return (0u);                                           /* No tasks waiting on mailbox              */
;;;446    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.78|
00004e  2302              MOVS     r3,#2                 ;427
000050  461a              MOV      r2,r3                 ;427
000052  2100              MOVS     r1,#0                 ;427
000054  4628              MOV      r0,r5                 ;427
000056  f7fffffe          BL       OS_EventTaskRdy
00005a  1c64              ADDS     r4,r4,#1              ;428
00005c  7aa8              LDRB     r0,[r5,#0xa]          ;426
00005e  b2e4              UXTB     r4,r4                 ;428
000060  2800              CMP      r0,#0                 ;426
000062  d1f4              BNE      |L4.78|
000064  e7e9              B        |L4.58|
                  |L4.102|
000066  4640              MOV      r0,r8                 ;443
000068  f7fffffe          BL       OS_CPU_SR_Restore
00006c  2000              MOVS     r0,#0                 ;444
00006e  7030              STRB     r0,[r6,#0]            ;444
                  |L4.112|
000070  2000              MOVS     r0,#0                 ;445
000072  e7ea              B        |L4.74|
;;;447    #endif
                          ENDP


                          AREA ||i.OSMboxPost||, CODE, READONLY, ALIGN=1

                  OSMboxPost PROC
;;;472    #if OS_MBOX_POST_EN > 0u
;;;473    INT8U  OSMboxPost (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;474                       void      *pmsg)
;;;475    {
000002  0004              MOVS     r4,r0
000004  460d              MOV      r5,r1
;;;476    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;477        OS_CPU_SR  cpu_sr = 0u;
;;;478    #endif
;;;479    
;;;480    
;;;481    
;;;482    #if OS_ARG_CHK_EN > 0u
;;;483        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000006  d005              BEQ      |L5.20|
;;;484            return (OS_ERR_PEVENT_NULL);
;;;485        }
;;;486        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
000008  b135              CBZ      r5,|L5.24|
;;;487            return (OS_ERR_POST_NULL_PTR);
;;;488        }
;;;489    #endif
;;;490        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2801              CMP      r0,#1
00000e  d005              BEQ      |L5.28|
;;;491            return (OS_ERR_EVENT_TYPE);
000010  2001              MOVS     r0,#1
;;;492        }
;;;493        OS_ENTER_CRITICAL();
;;;494        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;495                                                          /* Ready HPT waiting on event                    */
;;;496            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;497            OS_EXIT_CRITICAL();
;;;498            OS_Sched();                                   /* Find highest priority task ready to run       */
;;;499            return (OS_ERR_NONE);
;;;500        }
;;;501        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;502            OS_EXIT_CRITICAL();
;;;503            return (OS_ERR_MBOX_FULL);
;;;504        }
;;;505        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;506        OS_EXIT_CRITICAL();
;;;507        return (OS_ERR_NONE);
;;;508    }
000012  bd70              POP      {r4-r6,pc}
                  |L5.20|
000014  2004              MOVS     r0,#4                 ;484
000016  bd70              POP      {r4-r6,pc}
                  |L5.24|
000018  2003              MOVS     r0,#3                 ;487
00001a  bd70              POP      {r4-r6,pc}
                  |L5.28|
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4606              MOV      r6,r0                 ;493
000022  7aa0              LDRB     r0,[r4,#0xa]          ;494
000024  b158              CBZ      r0,|L5.62|
000026  2300              MOVS     r3,#0                 ;496
000028  2202              MOVS     r2,#2                 ;496
00002a  4629              MOV      r1,r5                 ;496
00002c  4620              MOV      r0,r4                 ;496
00002e  f7fffffe          BL       OS_EventTaskRdy
000032  4630              MOV      r0,r6                 ;497
000034  f7fffffe          BL       OS_CPU_SR_Restore
000038  f7fffffe          BL       OS_Sched
00003c  e00a              B        |L5.84|
                  |L5.62|
00003e  6860              LDR      r0,[r4,#4]            ;501
000040  b120              CBZ      r0,|L5.76|
000042  4630              MOV      r0,r6                 ;502
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  2014              MOVS     r0,#0x14              ;503
00004a  bd70              POP      {r4-r6,pc}
                  |L5.76|
00004c  4630              MOV      r0,r6                 ;506
00004e  6065              STR      r5,[r4,#4]            ;506
000050  f7fffffe          BL       OS_CPU_SR_Restore
                  |L5.84|
000054  2000              MOVS     r0,#0                 ;507
000056  bd70              POP      {r4-r6,pc}
;;;509    #endif
                          ENDP


                          AREA ||i.OSMboxPostOpt||, CODE, READONLY, ALIGN=1

                  OSMboxPostOpt PROC
;;;544    #if OS_MBOX_POST_OPT_EN > 0u
;;;545    INT8U  OSMboxPostOpt (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;546                          void      *pmsg,
;;;547                          INT8U      opt)
;;;548    {
000004  0004              MOVS     r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
;;;549    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;550        OS_CPU_SR  cpu_sr = 0u;
;;;551    #endif
;;;552    
;;;553    
;;;554    
;;;555    #if OS_ARG_CHK_EN > 0u
;;;556        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00000a  d006              BEQ      |L6.26|
;;;557            return (OS_ERR_PEVENT_NULL);
;;;558        }
;;;559        if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
00000c  b13d              CBZ      r5,|L6.30|
;;;560            return (OS_ERR_POST_NULL_PTR);
;;;561        }
;;;562    #endif
;;;563        if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
00000e  7820              LDRB     r0,[r4,#0]
000010  2801              CMP      r0,#1
000012  d006              BEQ      |L6.34|
;;;564            return (OS_ERR_EVENT_TYPE);
000014  2001              MOVS     r0,#1
                  |L6.22|
;;;565        }
;;;566        OS_ENTER_CRITICAL();
;;;567        if (pevent->OSEventGrp != 0u) {                   /* See if any task pending on mailbox            */
;;;568            if ((opt & OS_POST_OPT_BROADCAST) != 0x00u) { /* Do we need to post msg to ALL waiting tasks ? */
;;;569                while (pevent->OSEventGrp != 0u) {        /* Yes, Post to ALL tasks waiting on mailbox     */
;;;570                    (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;571                }
;;;572            } else {                                      /* No,  Post to HPT waiting on mbox              */
;;;573                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
;;;574            }
;;;575            OS_EXIT_CRITICAL();
;;;576            if ((opt & OS_POST_OPT_NO_SCHED) == 0u) {     /* See if scheduler needs to be invoked          */
;;;577                OS_Sched();                               /* Find HPT ready to run                         */
;;;578            }
;;;579            return (OS_ERR_NONE);
;;;580        }
;;;581        if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
;;;582            OS_EXIT_CRITICAL();
;;;583            return (OS_ERR_MBOX_FULL);
;;;584        }
;;;585        pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
;;;586        OS_EXIT_CRITICAL();
;;;587        return (OS_ERR_NONE);
;;;588    }
000016  e8bd81f0          POP      {r4-r8,pc}
                  |L6.26|
00001a  2004              MOVS     r0,#4                 ;557
00001c  e7fb              B        |L6.22|
                  |L6.30|
00001e  2003              MOVS     r0,#3                 ;560
000020  e7f9              B        |L6.22|
                  |L6.34|
000022  f7fffffe          BL       OS_CPU_SR_Save
000026  4607              MOV      r7,r0                 ;566
000028  7aa0              LDRB     r0,[r4,#0xa]          ;567
00002a  b1d0              CBZ      r0,|L6.98|
00002c  07f0              LSLS     r0,r6,#31             ;568
00002e  d009              BEQ      |L6.68|
                  |L6.48|
000030  2300              MOVS     r3,#0                 ;570
000032  2202              MOVS     r2,#2                 ;570
000034  4629              MOV      r1,r5                 ;570
000036  4620              MOV      r0,r4                 ;570
000038  f7fffffe          BL       OS_EventTaskRdy
00003c  7aa0              LDRB     r0,[r4,#0xa]          ;569
00003e  2800              CMP      r0,#0                 ;569
000040  d1f6              BNE      |L6.48|
000042  e005              B        |L6.80|
                  |L6.68|
000044  2300              MOVS     r3,#0                 ;573
000046  2202              MOVS     r2,#2                 ;573
000048  4629              MOV      r1,r5                 ;573
00004a  4620              MOV      r0,r4                 ;573
00004c  f7fffffe          BL       OS_EventTaskRdy
                  |L6.80|
000050  4638              MOV      r0,r7                 ;575
000052  f7fffffe          BL       OS_CPU_SR_Restore
000056  0770              LSLS     r0,r6,#29             ;576
000058  d401              BMI      |L6.94|
00005a  f7fffffe          BL       OS_Sched
                  |L6.94|
00005e  2000              MOVS     r0,#0                 ;579
000060  e7d9              B        |L6.22|
                  |L6.98|
000062  6860              LDR      r0,[r4,#4]            ;581
000064  b120              CBZ      r0,|L6.112|
000066  4638              MOV      r0,r7                 ;582
000068  f7fffffe          BL       OS_CPU_SR_Restore
00006c  2014              MOVS     r0,#0x14              ;583
00006e  e7d2              B        |L6.22|
                  |L6.112|
000070  4638              MOV      r0,r7                 ;586
000072  6065              STR      r5,[r4,#4]            ;586
000074  f7fffffe          BL       OS_CPU_SR_Restore
000078  e7f1              B        |L6.94|
;;;589    #endif
                          ENDP

