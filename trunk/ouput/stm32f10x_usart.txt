; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_usart.o --depend=.\ouput\stm32f10x_usart.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_usart.crf Source\FWLib\src\stm32f10x_usart.c]
                          THUMB

                          AREA ||i.USART_ClearFlag||, CODE, READONLY, ALIGN=1

                  USART_ClearFlag PROC
;;;919      */
;;;920    void USART_ClearFlag(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  43c9              MVNS     r1,r1
;;;921    {
;;;922      /* Check the parameters */
;;;923      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;924      assert_param(IS_USART_CLEAR_FLAG(USART_FLAG));
;;;925      /* The CTS flag is not available for UART4 and UART5 */
;;;926      if ((USART_FLAG & USART_FLAG_CTS) == USART_FLAG_CTS)
;;;927      {
;;;928        assert_param(IS_USART_123_PERIPH(USARTx));
;;;929      } 
;;;930       
;;;931      USARTx->SR = (uint16_t)~USART_FLAG;
000002  8001              STRH     r1,[r0,#0]
;;;932    }
000004  4770              BX       lr
;;;933    
                          ENDP


                          AREA ||i.USART_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  USART_ClearITPendingBit PROC
;;;1026     */
;;;1027   void USART_ClearITPendingBit(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  0a0a              LSRS     r2,r1,#8
;;;1028   {
;;;1029     uint16_t bitpos = 0x00, itmask = 0x00;
;;;1030     /* Check the parameters */
;;;1031     assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;1032     assert_param(IS_USART_CLEAR_IT(USART_IT));
;;;1033     /* The CTS interrupt is not available for UART4 and UART5 */
;;;1034     if (USART_IT == USART_IT_CTS)
;;;1035     {
;;;1036       assert_param(IS_USART_123_PERIPH(USARTx));
;;;1037     }   
;;;1038     
;;;1039     bitpos = USART_IT >> 0x08;
;;;1040     itmask = ((uint16_t)0x01 << (uint16_t)bitpos);
000002  2101              MOVS     r1,#1
000004  4091              LSLS     r1,r1,r2
;;;1041     USARTx->SR = (uint16_t)~itmask;
000006  43c9              MVNS     r1,r1
000008  8001              STRH     r1,[r0,#0]
;;;1042   }
00000a  4770              BX       lr
;;;1043   /**
                          ENDP


                          AREA ||i.USART_ClockInit||, CODE, READONLY, ALIGN=1

                  USART_ClockInit PROC
;;;298      */
;;;299    void USART_ClockInit(USART_TypeDef* USARTx, USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  b510              PUSH     {r4,lr}
;;;300    {
;;;301      uint32_t tmpreg = 0x00;
;;;302      /* Check the parameters */
;;;303      assert_param(IS_USART_123_PERIPH(USARTx));
;;;304      assert_param(IS_USART_CLOCK(USART_ClockInitStruct->USART_Clock));
;;;305      assert_param(IS_USART_CPOL(USART_ClockInitStruct->USART_CPOL));
;;;306      assert_param(IS_USART_CPHA(USART_ClockInitStruct->USART_CPHA));
;;;307      assert_param(IS_USART_LASTBIT(USART_ClockInitStruct->USART_LastBit));
;;;308      
;;;309    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;310      tmpreg = USARTx->CR2;
000002  8a02              LDRH     r2,[r0,#0x10]
;;;311      /* Clear CLKEN, CPOL, CPHA and LBCL bits */
;;;312      tmpreg &= CR2_CLOCK_CLEAR_Mask;
000004  f24f03ff          MOV      r3,#0xf0ff
000008  401a              ANDS     r2,r2,r3
;;;313      /* Configure the USART Clock, CPOL, CPHA and LastBit ------------*/
;;;314      /* Set CLKEN bit according to USART_Clock value */
;;;315      /* Set CPOL bit according to USART_CPOL value */
;;;316      /* Set CPHA bit according to USART_CPHA value */
;;;317      /* Set LBCL bit according to USART_LastBit value */
;;;318      tmpreg |= (uint32_t)USART_ClockInitStruct->USART_Clock | USART_ClockInitStruct->USART_CPOL | 
00000a  880b              LDRH     r3,[r1,#0]
00000c  884c              LDRH     r4,[r1,#2]
00000e  4323              ORRS     r3,r3,r4
000010  888c              LDRH     r4,[r1,#4]
000012  88c9              LDRH     r1,[r1,#6]
000014  430c              ORRS     r4,r4,r1
000016  4323              ORRS     r3,r3,r4
000018  4313              ORRS     r3,r3,r2
;;;319                     USART_ClockInitStruct->USART_CPHA | USART_ClockInitStruct->USART_LastBit;
;;;320      /* Write to USART CR2 */
;;;321      USARTx->CR2 = (uint16_t)tmpreg;
00001a  8203              STRH     r3,[r0,#0x10]
;;;322    }
00001c  bd10              POP      {r4,pc}
;;;323    
                          ENDP


                          AREA ||i.USART_ClockStructInit||, CODE, READONLY, ALIGN=1

                  USART_ClockStructInit PROC
;;;329      */
;;;330    void USART_ClockStructInit(USART_ClockInitTypeDef* USART_ClockInitStruct)
000000  2100              MOVS     r1,#0
;;;331    {
;;;332      /* USART_ClockInitStruct members default value */
;;;333      USART_ClockInitStruct->USART_Clock = USART_Clock_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;334      USART_ClockInitStruct->USART_CPOL = USART_CPOL_Low;
000004  8041              STRH     r1,[r0,#2]
;;;335      USART_ClockInitStruct->USART_CPHA = USART_CPHA_1Edge;
000006  8081              STRH     r1,[r0,#4]
;;;336      USART_ClockInitStruct->USART_LastBit = USART_LastBit_Disable;
000008  80c1              STRH     r1,[r0,#6]
;;;337    }
00000a  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.USART_Cmd||, CODE, READONLY, ALIGN=1

                  USART_Cmd PROC
;;;347      */
;;;348    void USART_Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;349    {
;;;350      /* Check the parameters */
;;;351      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;352      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;353      
;;;354      if (NewState != DISABLE)
;;;355      {
;;;356        /* Enable the selected USART by setting the UE bit in the CR1 register */
;;;357        USARTx->CR1 |= CR1_UE_Set;
;;;358      }
;;;359      else
;;;360      {
;;;361        /* Disable the selected USART by clearing the UE bit in the CR1 register */
;;;362        USARTx->CR1 &= CR1_UE_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L5.12|
000006  f4415100          ORR      r1,r1,#0x2000         ;357
00000a  e001              B        |L5.16|
                  |L5.12|
00000c  f4215100          BIC      r1,r1,#0x2000
                  |L5.16|
000010  8181              STRH     r1,[r0,#0xc]          ;357
;;;363      }
;;;364    }
000012  4770              BX       lr
;;;365    
                          ENDP


                          AREA ||i.USART_DMACmd||, CODE, READONLY, ALIGN=1

                  USART_DMACmd PROC
;;;444      */
;;;445    void USART_DMACmd(USART_TypeDef* USARTx, uint16_t USART_DMAReq, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;446    {
;;;447      /* Check the parameters */
;;;448      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;449      assert_param(IS_USART_DMAREQ(USART_DMAReq));  
;;;450      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;451      if (NewState != DISABLE)
;;;452      {
;;;453        /* Enable the DMA transfer for selected requests by setting the DMAT and/or
;;;454           DMAR bits in the USART CR3 register */
;;;455        USARTx->CR3 |= USART_DMAReq;
;;;456      }
;;;457      else
;;;458      {
;;;459        /* Disable the DMA transfer for selected requests by clearing the DMAT and/or
;;;460           DMAR bits in the USART CR3 register */
;;;461        USARTx->CR3 &= (uint16_t)~USART_DMAReq;
000002  8a82              LDRH     r2,[r0,#0x14]
000004  d001              BEQ      |L6.10|
000006  430a              ORRS     r2,r2,r1              ;455
000008  e000              B        |L6.12|
                  |L6.10|
00000a  438a              BICS     r2,r2,r1
                  |L6.12|
00000c  8282              STRH     r2,[r0,#0x14]         ;455
;;;462      }
;;;463    }
00000e  4770              BX       lr
;;;464    
                          ENDP


                          AREA ||i.USART_DeInit||, CODE, READONLY, ALIGN=2

                  USART_DeInit PROC
;;;127      */
;;;128    void USART_DeInit(USART_TypeDef* USARTx)
000000  4917              LDR      r1,|L7.96|
;;;129    {
000002  b510              PUSH     {r4,lr}
;;;130      /* Check the parameters */
;;;131      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;132    
;;;133      if (USARTx == USART1)
000004  4288              CMP      r0,r1
000006  d10a              BNE      |L7.30|
;;;134      {
;;;135        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  038c              LSLS     r4,r1,#14
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;136        RCC_APB2PeriphResetCmd(RCC_APB2Periph_USART1, DISABLE);
000012  4620              MOV      r0,r4
000014  e8bd4010          POP      {r4,lr}
000018  2100              MOVS     r1,#0
00001a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L7.30|
;;;137      }
;;;138      else if (USARTx == USART2)
00001e  4911              LDR      r1,|L7.100|
000020  4288              CMP      r0,r1
000022  d102              BNE      |L7.42|
;;;139      {
;;;140        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, ENABLE);
000024  2101              MOVS     r1,#1
000026  044c              LSLS     r4,r1,#17
;;;141        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART2, DISABLE);
000028  e010              B        |L7.76|
                  |L7.42|
;;;142      }
;;;143      else if (USARTx == USART3)
00002a  490f              LDR      r1,|L7.104|
00002c  4288              CMP      r0,r1
00002e  d102              BNE      |L7.54|
;;;144      {
;;;145        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, ENABLE);
000030  2101              MOVS     r1,#1
000032  048c              LSLS     r4,r1,#18
;;;146        RCC_APB1PeriphResetCmd(RCC_APB1Periph_USART3, DISABLE);
000034  e00a              B        |L7.76|
                  |L7.54|
;;;147      }    
;;;148      else if (USARTx == UART4)
000036  490d              LDR      r1,|L7.108|
000038  4288              CMP      r0,r1
00003a  d102              BNE      |L7.66|
;;;149      {
;;;150        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  04cc              LSLS     r4,r1,#19
;;;151        RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART4, DISABLE);
000040  e004              B        |L7.76|
                  |L7.66|
;;;152      }    
;;;153      else
;;;154      {
;;;155        if (USARTx == UART5)
000042  490b              LDR      r1,|L7.112|
000044  4288              CMP      r0,r1
000046  d10a              BNE      |L7.94|
;;;156        { 
;;;157          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, ENABLE);
000048  2101              MOVS     r1,#1
00004a  050c              LSLS     r4,r1,#20
                  |L7.76|
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;158          RCC_APB1PeriphResetCmd(RCC_APB1Periph_UART5, DISABLE);
000052  4620              MOV      r0,r4
000054  e8bd4010          POP      {r4,lr}
000058  2100              MOVS     r1,#0
00005a  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L7.94|
;;;159        }
;;;160      }
;;;161    }
00005e  bd10              POP      {r4,pc}
;;;162    
                          ENDP

                  |L7.96|
                          DCD      0x40013800
                  |L7.100|
                          DCD      0x40004400
                  |L7.104|
                          DCD      0x40004800
                  |L7.108|
                          DCD      0x40004c00
                  |L7.112|
                          DCD      0x40005000

                          AREA ||i.USART_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  USART_GetFlagStatus PROC
;;;870      */
;;;871    FlagStatus USART_GetFlagStatus(USART_TypeDef* USARTx, uint16_t USART_FLAG)
000000  4602              MOV      r2,r0
;;;872    {
;;;873      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;874      /* Check the parameters */
;;;875      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;876      assert_param(IS_USART_FLAG(USART_FLAG));
;;;877      /* The CTS flag is not available for UART4 and UART5 */
;;;878      if (USART_FLAG == USART_FLAG_CTS)
;;;879      {
;;;880        assert_param(IS_USART_123_PERIPH(USARTx));
;;;881      }  
;;;882      
;;;883      if ((USARTx->SR & USART_FLAG) != (uint16_t)RESET)
000004  8812              LDRH     r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L8.12|
;;;884      {
;;;885        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L8.12|
;;;886      }
;;;887      else
;;;888      {
;;;889        bitstatus = RESET;
;;;890      }
;;;891      return bitstatus;
;;;892    }
00000c  4770              BX       lr
;;;893    
                          ENDP


                          AREA ||i.USART_GetITStatus||, CODE, READONLY, ALIGN=1

                  USART_GetITStatus PROC
;;;952      */
;;;953    ITStatus USART_GetITStatus(USART_TypeDef* USARTx, uint16_t USART_IT)
000000  b570              PUSH     {r4-r6,lr}
;;;954    {
;;;955      uint32_t bitpos = 0x00, itmask = 0x00, usartreg = 0x00;
;;;956      ITStatus bitstatus = RESET;
;;;957      /* Check the parameters */
;;;958      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;959      assert_param(IS_USART_GET_IT(USART_IT));
;;;960      /* The CTS interrupt is not available for UART4 and UART5 */ 
;;;961      if (USART_IT == USART_IT_CTS)
;;;962      {
;;;963        assert_param(IS_USART_123_PERIPH(USARTx));
;;;964      }   
;;;965      
;;;966      /* Get the USART register index */
;;;967      usartreg = (((uint8_t)USART_IT) >> 0x05);
;;;968      /* Get the interrupt position */
;;;969      itmask = USART_IT & IT_Mask;
000002  f001061f          AND      r6,r1,#0x1f
;;;970      itmask = (uint32_t)0x01 << itmask;
000006  2501              MOVS     r5,#1
000008  2400              MOVS     r4,#0                 ;956
00000a  f3c11342          UBFX     r3,r1,#5,#3           ;967
00000e  fa05f206          LSL      r2,r5,r6
;;;971      
;;;972      if (usartreg == 0x01) /* The IT  is in CR1 register */
000012  2b01              CMP      r3,#1
000014  d00f              BEQ      |L9.54|
;;;973      {
;;;974        itmask &= USARTx->CR1;
;;;975      }
;;;976      else if (usartreg == 0x02) /* The IT  is in CR2 register */
000016  2b02              CMP      r3,#2
000018  d00f              BEQ      |L9.58|
;;;977      {
;;;978        itmask &= USARTx->CR2;
;;;979      }
;;;980      else /* The IT  is in CR3 register */
;;;981      {
;;;982        itmask &= USARTx->CR3;
00001a  8a83              LDRH     r3,[r0,#0x14]
                  |L9.28|
;;;983      }
;;;984      
;;;985      bitpos = USART_IT >> 0x08;
00001c  ea4f2111          LSR      r1,r1,#8
;;;986      bitpos = (uint32_t)0x01 << bitpos;
;;;987      bitpos &= USARTx->SR;
000020  8800              LDRH     r0,[r0,#0]
000022  4213              TST      r3,r2                 ;978
000024  fa05f501          LSL      r5,r5,r1              ;986
000028  ea000005          AND      r0,r0,r5
;;;988      if ((itmask != (uint16_t)RESET)&&(bitpos != (uint16_t)RESET))
00002c  d001              BEQ      |L9.50|
00002e  b100              CBZ      r0,|L9.50|
;;;989      {
;;;990        bitstatus = SET;
000030  2401              MOVS     r4,#1
                  |L9.50|
;;;991      }
;;;992      else
;;;993      {
;;;994        bitstatus = RESET;
;;;995      }
;;;996      
;;;997      return bitstatus;  
000032  4620              MOV      r0,r4
;;;998    }
000034  bd70              POP      {r4-r6,pc}
                  |L9.54|
000036  8983              LDRH     r3,[r0,#0xc]          ;974
000038  e7f0              B        |L9.28|
                  |L9.58|
00003a  8a03              LDRH     r3,[r0,#0x10]         ;978
00003c  e7ee              B        |L9.28|
;;;999    
                          ENDP


                          AREA ||i.USART_HalfDuplexCmd||, CODE, READONLY, ALIGN=1

                  USART_HalfDuplexCmd PROC
;;;727      */
;;;728    void USART_HalfDuplexCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;729    {
;;;730      /* Check the parameters */
;;;731      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;732      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;733      
;;;734      if (NewState != DISABLE)
;;;735      {
;;;736        /* Enable the Half-Duplex mode by setting the HDSEL bit in the CR3 register */
;;;737        USARTx->CR3 |= CR3_HDSEL_Set;
;;;738      }
;;;739      else
;;;740      {
;;;741        /* Disable the Half-Duplex mode by clearing the HDSEL bit in the CR3 register */
;;;742        USARTx->CR3 &= CR3_HDSEL_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L10.12|
000006  f0410108          ORR      r1,r1,#8              ;737
00000a  e001              B        |L10.16|
                  |L10.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L10.16|
000010  8281              STRH     r1,[r0,#0x14]         ;737
;;;743      }
;;;744    }
000012  4770              BX       lr
;;;745    
                          ENDP


                          AREA ||i.USART_ITConfig||, CODE, READONLY, ALIGN=1

                  USART_ITConfig PROC
;;;384      */
;;;385    void USART_ITConfig(USART_TypeDef* USARTx, uint16_t USART_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;386    {
;;;387      uint32_t usartreg = 0x00, itpos = 0x00, itmask = 0x00;
;;;388      uint32_t usartxbase = 0x00;
;;;389      /* Check the parameters */
;;;390      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;391      assert_param(IS_USART_CONFIG_IT(USART_IT));
;;;392      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;393      /* The CTS interrupt is not available for UART4 and UART5 */
;;;394      if (USART_IT == USART_IT_CTS)
;;;395      {
;;;396        assert_param(IS_USART_123_PERIPH(USARTx));
;;;397      }   
;;;398      
;;;399      usartxbase = (uint32_t)USARTx;
;;;400    
;;;401      /* Get the USART register index */
;;;402      usartreg = (((uint8_t)USART_IT) >> 0x05);
000002  f3c11342          UBFX     r3,r1,#5,#3
;;;403    
;;;404      /* Get the interrupt position */
;;;405      itpos = USART_IT & IT_Mask;
000006  f001041f          AND      r4,r1,#0x1f
;;;406      itmask = (((uint32_t)0x01) << itpos);
00000a  2101              MOVS     r1,#1
00000c  40a1              LSLS     r1,r1,r4
;;;407        
;;;408      if (usartreg == 0x01) /* The IT is in CR1 register */
00000e  2b01              CMP      r3,#1
000010  d007              BEQ      |L11.34|
;;;409      {
;;;410        usartxbase += 0x0C;
;;;411      }
;;;412      else if (usartreg == 0x02) /* The IT is in CR2 register */
000012  2b02              CMP      r3,#2
000014  d007              BEQ      |L11.38|
;;;413      {
;;;414        usartxbase += 0x10;
;;;415      }
;;;416      else /* The IT is in CR3 register */
;;;417      {
;;;418        usartxbase += 0x14; 
000016  3014              ADDS     r0,r0,#0x14
                  |L11.24|
;;;419      }
;;;420      if (NewState != DISABLE)
000018  2a00              CMP      r2,#0
;;;421      {
;;;422        *(__IO uint32_t*)usartxbase  |= itmask;
;;;423      }
;;;424      else
;;;425      {
;;;426        *(__IO uint32_t*)usartxbase &= ~itmask;
00001a  6802              LDR      r2,[r0,#0]
00001c  d005              BEQ      |L11.42|
00001e  430a              ORRS     r2,r2,r1              ;422
000020  e004              B        |L11.44|
                  |L11.34|
000022  300c              ADDS     r0,r0,#0xc            ;410
000024  e7f8              B        |L11.24|
                  |L11.38|
000026  3010              ADDS     r0,r0,#0x10           ;414
000028  e7f6              B        |L11.24|
                  |L11.42|
00002a  438a              BICS     r2,r2,r1
                  |L11.44|
00002c  6002              STR      r2,[r0,#0]            ;422
;;;427      }
;;;428    }
00002e  bd10              POP      {r4,pc}
;;;429    
                          ENDP


                          AREA ||i.USART_Init||, CODE, READONLY, ALIGN=2

                  USART_Init PROC
;;;172      */
;;;173    void USART_Init(USART_TypeDef* USARTx, USART_InitTypeDef* USART_InitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;174    {
000002  460d              MOV      r5,r1
;;;175      uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;176      uint32_t integerdivider = 0x00;
;;;177      uint32_t fractionaldivider = 0x00;
;;;178      uint32_t usartxbase = 0;
;;;179      RCC_ClocksTypeDef RCC_ClocksStatus;
;;;180      /* Check the parameters */
;;;181      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;182      assert_param(IS_USART_BAUDRATE(USART_InitStruct->USART_BaudRate));  
;;;183      assert_param(IS_USART_WORD_LENGTH(USART_InitStruct->USART_WordLength));
;;;184      assert_param(IS_USART_STOPBITS(USART_InitStruct->USART_StopBits));
;;;185      assert_param(IS_USART_PARITY(USART_InitStruct->USART_Parity));
;;;186      assert_param(IS_USART_MODE(USART_InitStruct->USART_Mode));
;;;187      assert_param(IS_USART_HARDWARE_FLOW_CONTROL(USART_InitStruct->USART_HardwareFlowControl));
;;;188      /* The hardware flow control is available only for USART1, USART2 and USART3 */
;;;189      if (USART_InitStruct->USART_HardwareFlowControl != USART_HardwareFlowControl_None)
;;;190      {
;;;191        assert_param(IS_USART_123_PERIPH(USARTx));
;;;192      }
;;;193    
;;;194      usartxbase = (uint32_t)USARTx;
;;;195    
;;;196    /*---------------------------- USART CR2 Configuration -----------------------*/
;;;197      tmpreg = USARTx->CR2;
000004  8a01              LDRH     r1,[r0,#0x10]
000006  b085              SUB      sp,sp,#0x14           ;174
000008  4604              MOV      r4,r0                 ;174
;;;198      /* Clear STOP[13:12] bits */
;;;199      tmpreg &= CR2_STOP_CLEAR_Mask;
00000a  f64c70ff          MOV      r0,#0xcfff
00000e  4001              ANDS     r1,r1,r0
;;;200      /* Configure the USART Stop Bits, Clock, CPOL, CPHA and LastBit ------------*/
;;;201      /* Set STOP[13:12] bits according to USART_StopBits value */
;;;202      tmpreg |= (uint32_t)USART_InitStruct->USART_StopBits;
000010  88e8              LDRH     r0,[r5,#6]
000012  4308              ORRS     r0,r0,r1
;;;203      
;;;204      /* Write to USART CR2 */
;;;205      USARTx->CR2 = (uint16_t)tmpreg;
000014  8220              STRH     r0,[r4,#0x10]
;;;206    
;;;207    /*---------------------------- USART CR1 Configuration -----------------------*/
;;;208      tmpreg = USARTx->CR1;
000016  89a0              LDRH     r0,[r4,#0xc]
;;;209      /* Clear M, PCE, PS, TE and RE bits */
;;;210      tmpreg &= CR1_CLEAR_Mask;
000018  f64e11f3          MOV      r1,#0xe9f3
00001c  4008              ANDS     r0,r0,r1
;;;211      /* Configure the USART Word Length, Parity and mode ----------------------- */
;;;212      /* Set the M bits according to USART_WordLength value */
;;;213      /* Set PCE and PS bits according to USART_Parity value */
;;;214      /* Set TE and RE bits according to USART_Mode value */
;;;215      tmpreg |= (uint32_t)USART_InitStruct->USART_WordLength | USART_InitStruct->USART_Parity |
00001e  88a9              LDRH     r1,[r5,#4]
000020  892a              LDRH     r2,[r5,#8]
000022  4311              ORRS     r1,r1,r2
000024  896a              LDRH     r2,[r5,#0xa]
000026  4302              ORRS     r2,r2,r0
000028  4311              ORRS     r1,r1,r2
;;;216                USART_InitStruct->USART_Mode;
;;;217      /* Write to USART CR1 */
;;;218      USARTx->CR1 = (uint16_t)tmpreg;
00002a  81a1              STRH     r1,[r4,#0xc]
;;;219    
;;;220    /*---------------------------- USART CR3 Configuration -----------------------*/  
;;;221      tmpreg = USARTx->CR3;
00002c  8aa1              LDRH     r1,[r4,#0x14]
;;;222      /* Clear CTSE and RTSE bits */
;;;223      tmpreg &= CR3_CLEAR_Mask;
00002e  f64f40ff          MOV      r0,#0xfcff
000032  4001              ANDS     r1,r1,r0
;;;224      /* Configure the USART HFC -------------------------------------------------*/
;;;225      /* Set CTSE and RTSE bits according to USART_HardwareFlowControl value */
;;;226      tmpreg |= USART_InitStruct->USART_HardwareFlowControl;
000034  89a8              LDRH     r0,[r5,#0xc]
000036  4308              ORRS     r0,r0,r1
;;;227      /* Write to USART CR3 */
;;;228      USARTx->CR3 = (uint16_t)tmpreg;
000038  82a0              STRH     r0,[r4,#0x14]
;;;229    
;;;230    /*---------------------------- USART BRR Configuration -----------------------*/
;;;231      /* Configure the USART Baud Rate -------------------------------------------*/
;;;232      RCC_GetClocksFreq(&RCC_ClocksStatus);
00003a  4668              MOV      r0,sp
00003c  f7fffffe          BL       RCC_GetClocksFreq
;;;233      if (usartxbase == USART1_BASE)
000040  481b              LDR      r0,|L12.176|
000042  4284              CMP      r4,r0
000044  d101              BNE      |L12.74|
;;;234      {
;;;235        apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000046  9803              LDR      r0,[sp,#0xc]
000048  e000              B        |L12.76|
                  |L12.74|
;;;236      }
;;;237      else
;;;238      {
;;;239        apbclock = RCC_ClocksStatus.PCLK1_Frequency;
00004a  9802              LDR      r0,[sp,#8]
                  |L12.76|
;;;240      }
;;;241      
;;;242      /* Determine the integer part */
;;;243      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
00004c  89a1              LDRH     r1,[r4,#0xc]
00004e  0409              LSLS     r1,r1,#16
000050  2900              CMP      r1,#0
;;;244      {
;;;245        /* Integer part computing in case Oversampling mode is 8 Samples */
;;;246        integerdivider = ((25 * apbclock) / (2 * (USART_InitStruct->USART_BaudRate)));    
;;;247      }
;;;248      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;249      {
;;;250        /* Integer part computing in case Oversampling mode is 16 Samples */
;;;251        integerdivider = ((25 * apbclock) / (4 * (USART_InitStruct->USART_BaudRate)));    
000052  eb0001c0          ADD      r1,r0,r0,LSL #3
000056  eb011000          ADD      r0,r1,r0,LSL #4
00005a  6829              LDR      r1,[r5,#0]            ;243
00005c  da02              BGE      |L12.100|
00005e  ea4f0141          LSL      r1,r1,#1              ;246
000062  e001              B        |L12.104|
                  |L12.100|
000064  ea4f0181          LSL      r1,r1,#2
                  |L12.104|
000068  fbb0f0f1          UDIV     r0,r0,r1
;;;252      }
;;;253      tmpreg = (integerdivider / 100) << 4;
00006c  2264              MOVS     r2,#0x64
00006e  fbb0f1f2          UDIV     r1,r0,r2
000072  ea4f1101          LSL      r1,r1,#4
;;;254    
;;;255      /* Determine the fractional part */
;;;256      fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
000076  ea4f1311          LSR      r3,r1,#4
00007a  f06f0518          MVN      r5,#0x18
00007e  436b              MULS     r3,r5,r3
000080  eb000083          ADD      r0,r0,r3,LSL #2
;;;257    
;;;258      /* Implement the fractional part in the register */
;;;259      if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
000084  89a3              LDRH     r3,[r4,#0xc]
000086  041d              LSLS     r5,r3,#16
;;;260      {
;;;261        tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
000088  f04f0332          MOV      r3,#0x32
00008c  d506              BPL      |L12.156|
00008e  eb0300c0          ADD      r0,r3,r0,LSL #3
000092  fbb0f0f2          UDIV     r0,r0,r2
000096  f0000007          AND      r0,r0,#7
00009a  e005              B        |L12.168|
                  |L12.156|
;;;262      }
;;;263      else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;264      {
;;;265        tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
00009c  eb031000          ADD      r0,r3,r0,LSL #4
0000a0  fbb0f0f2          UDIV     r0,r0,r2
0000a4  f000000f          AND      r0,r0,#0xf
                  |L12.168|
0000a8  4308              ORRS     r0,r0,r1
;;;266      }
;;;267      
;;;268      /* Write to USART BRR */
;;;269      USARTx->BRR = (uint16_t)tmpreg;
0000aa  8120              STRH     r0,[r4,#8]
;;;270    }
0000ac  b005              ADD      sp,sp,#0x14
0000ae  bd30              POP      {r4,r5,pc}
;;;271    
                          ENDP

                  |L12.176|
                          DCD      0x40013800

                          AREA ||i.USART_IrDACmd||, CODE, READONLY, ALIGN=1

                  USART_IrDACmd PROC
;;;833      */
;;;834    void USART_IrDACmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;835    {
;;;836      /* Check the parameters */
;;;837      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;838      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;839        
;;;840      if (NewState != DISABLE)
;;;841      {
;;;842        /* Enable the IrDA mode by setting the IREN bit in the CR3 register */
;;;843        USARTx->CR3 |= CR3_IREN_Set;
;;;844      }
;;;845      else
;;;846      {
;;;847        /* Disable the IrDA mode by clearing the IREN bit in the CR3 register */
;;;848        USARTx->CR3 &= CR3_IREN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L13.12|
000006  f0410102          ORR      r1,r1,#2              ;843
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L13.16|
000010  8281              STRH     r1,[r0,#0x14]         ;843
;;;849      }
;;;850    }
000012  4770              BX       lr
;;;851    
                          ENDP


                          AREA ||i.USART_IrDAConfig||, CODE, READONLY, ALIGN=1

                  USART_IrDAConfig PROC
;;;814      */
;;;815    void USART_IrDAConfig(USART_TypeDef* USARTx, uint16_t USART_IrDAMode)
000000  8a82              LDRH     r2,[r0,#0x14]
;;;816    {
;;;817      /* Check the parameters */
;;;818      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;819      assert_param(IS_USART_IRDA_MODE(USART_IrDAMode));
;;;820        
;;;821      USARTx->CR3 &= CR3_IRLP_Mask;
000002  f0220204          BIC      r2,r2,#4
000006  8282              STRH     r2,[r0,#0x14]
;;;822      USARTx->CR3 |= USART_IrDAMode;
000008  8a82              LDRH     r2,[r0,#0x14]
00000a  430a              ORRS     r2,r2,r1
00000c  8282              STRH     r2,[r0,#0x14]
;;;823    }
00000e  4770              BX       lr
;;;824    
                          ENDP


                          AREA ||i.USART_LINBreakDetectLengthConfig||, CODE, READONLY, ALIGN=1

                  USART_LINBreakDetectLengthConfig PROC
;;;543      */
;;;544    void USART_LINBreakDetectLengthConfig(USART_TypeDef* USARTx, uint16_t USART_LINBreakDetectLength)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;545    {
;;;546      /* Check the parameters */
;;;547      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;548      assert_param(IS_USART_LIN_BREAK_DETECT_LENGTH(USART_LINBreakDetectLength));
;;;549      
;;;550      USARTx->CR2 &= CR2_LBDL_Mask;
000002  f0220220          BIC      r2,r2,#0x20
000006  8202              STRH     r2,[r0,#0x10]
;;;551      USARTx->CR2 |= USART_LINBreakDetectLength;  
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;552    }
00000e  4770              BX       lr
;;;553    
                          ENDP


                          AREA ||i.USART_LINCmd||, CODE, READONLY, ALIGN=1

                  USART_LINCmd PROC
;;;562      */
;;;563    void USART_LINCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;564    {
;;;565      /* Check the parameters */
;;;566      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;567      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;568      
;;;569      if (NewState != DISABLE)
;;;570      {
;;;571        /* Enable the LIN mode by setting the LINEN bit in the CR2 register */
;;;572        USARTx->CR2 |= CR2_LINEN_Set;
;;;573      }
;;;574      else
;;;575      {
;;;576        /* Disable the LIN mode by clearing the LINEN bit in the CR2 register */
;;;577        USARTx->CR2 &= CR2_LINEN_Reset;
000002  8a01              LDRH     r1,[r0,#0x10]
000004  d002              BEQ      |L16.12|
000006  f4414180          ORR      r1,r1,#0x4000         ;572
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  f4214180          BIC      r1,r1,#0x4000
                  |L16.16|
000010  8201              STRH     r1,[r0,#0x10]         ;572
;;;578      }
;;;579    }
000012  4770              BX       lr
;;;580    
                          ENDP


                          AREA ||i.USART_OneBitMethodCmd||, CODE, READONLY, ALIGN=1

                  USART_OneBitMethodCmd PROC
;;;785      */
;;;786    void USART_OneBitMethodCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;787    {
;;;788      /* Check the parameters */
;;;789      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;790      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;791      
;;;792      if (NewState != DISABLE)
;;;793      {
;;;794        /* Enable the one bit method by setting the ONEBITE bit in the CR3 register */
;;;795        USARTx->CR3 |= CR3_ONEBITE_Set;
;;;796      }
;;;797      else
;;;798      {
;;;799        /* Disable tthe one bit method by clearing the ONEBITE bit in the CR3 register */
;;;800        USARTx->CR3 &= CR3_ONEBITE_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L17.12|
000006  f4416100          ORR      r1,r1,#0x800          ;795
00000a  e001              B        |L17.16|
                  |L17.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L17.16|
000010  8281              STRH     r1,[r0,#0x14]         ;795
;;;801      }
;;;802    }
000012  4770              BX       lr
;;;803    
                          ENDP


                          AREA ||i.USART_OverSampling8Cmd||, CODE, READONLY, ALIGN=1

                  USART_OverSampling8Cmd PROC
;;;758      */
;;;759    void USART_OverSampling8Cmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;760    {
;;;761      /* Check the parameters */
;;;762      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;763      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;764      
;;;765      if (NewState != DISABLE)
;;;766      {
;;;767        /* Enable the 8x Oversampling mode by setting the OVER8 bit in the CR1 register */
;;;768        USARTx->CR1 |= CR1_OVER8_Set;
;;;769      }
;;;770      else
;;;771      {
;;;772        /* Disable the 8x Oversampling mode by clearing the OVER8 bit in the CR1 register */
;;;773        USARTx->CR1 &= CR1_OVER8_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L18.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;768
00000a  e001              B        |L18.16|
                  |L18.12|
00000c  f3c1010e          UBFX     r1,r1,#0,#15
                  |L18.16|
000010  8181              STRH     r1,[r0,#0xc]          ;768
;;;774      }
;;;775    }
000012  4770              BX       lr
;;;776    
                          ENDP


                          AREA ||i.USART_ReceiveData||, CODE, READONLY, ALIGN=1

                  USART_ReceiveData PROC
;;;605      */
;;;606    uint16_t USART_ReceiveData(USART_TypeDef* USARTx)
000000  8880              LDRH     r0,[r0,#4]
;;;607    {
;;;608      /* Check the parameters */
;;;609      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;610      
;;;611      /* Receive Data */
;;;612      return (uint16_t)(USARTx->DR & (uint16_t)0x01FF);
000002  f3c00008          UBFX     r0,r0,#0,#9
;;;613    }
000006  4770              BX       lr
;;;614    
                          ENDP


                          AREA ||i.USART_ReceiverWakeUpCmd||, CODE, READONLY, ALIGN=1

                  USART_ReceiverWakeUpCmd PROC
;;;514      */
;;;515    void USART_ReceiverWakeUpCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;516    {
;;;517      /* Check the parameters */
;;;518      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;519      assert_param(IS_FUNCTIONAL_STATE(NewState)); 
;;;520      
;;;521      if (NewState != DISABLE)
;;;522      {
;;;523        /* Enable the USART mute mode  by setting the RWU bit in the CR1 register */
;;;524        USARTx->CR1 |= CR1_RWU_Set;
;;;525      }
;;;526      else
;;;527      {
;;;528        /* Disable the USART mute mode by clearing the RWU bit in the CR1 register */
;;;529        USARTx->CR1 &= CR1_RWU_Reset;
000002  8981              LDRH     r1,[r0,#0xc]
000004  d002              BEQ      |L20.12|
000006  f0410102          ORR      r1,r1,#2              ;524
00000a  e001              B        |L20.16|
                  |L20.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L20.16|
000010  8181              STRH     r1,[r0,#0xc]          ;524
;;;530      }
;;;531    }
000012  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.USART_SendBreak||, CODE, READONLY, ALIGN=1

                  USART_SendBreak PROC
;;;621      */
;;;622    void USART_SendBreak(USART_TypeDef* USARTx)
000000  8981              LDRH     r1,[r0,#0xc]
;;;623    {
;;;624      /* Check the parameters */
;;;625      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;626      
;;;627      /* Send break characters */
;;;628      USARTx->CR1 |= CR1_SBK_Set;
000002  f0410101          ORR      r1,r1,#1
000006  8181              STRH     r1,[r0,#0xc]
;;;629    }
000008  4770              BX       lr
;;;630    
                          ENDP


                          AREA ||i.USART_SendData||, CODE, READONLY, ALIGN=1

                  USART_SendData PROC
;;;588      */
;;;589    void USART_SendData(USART_TypeDef* USARTx, uint16_t Data)
000000  f3c10108          UBFX     r1,r1,#0,#9
;;;590    {
;;;591      /* Check the parameters */
;;;592      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;593      assert_param(IS_USART_DATA(Data)); 
;;;594        
;;;595      /* Transmit Data */
;;;596      USARTx->DR = (Data & (uint16_t)0x01FF);
000004  8081              STRH     r1,[r0,#4]
;;;597    }
000006  4770              BX       lr
;;;598    
                          ENDP


                          AREA ||i.USART_SetAddress||, CODE, READONLY, ALIGN=1

                  USART_SetAddress PROC
;;;472      */
;;;473    void USART_SetAddress(USART_TypeDef* USARTx, uint8_t USART_Address)
000000  8a02              LDRH     r2,[r0,#0x10]
;;;474    {
;;;475      /* Check the parameters */
;;;476      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;477      assert_param(IS_USART_ADDRESS(USART_Address)); 
;;;478        
;;;479      /* Clear the USART address */
;;;480      USARTx->CR2 &= CR2_Address_Mask;
000002  f022020f          BIC      r2,r2,#0xf
000006  8202              STRH     r2,[r0,#0x10]
;;;481      /* Set the USART address node */
;;;482      USARTx->CR2 |= USART_Address;
000008  8a02              LDRH     r2,[r0,#0x10]
00000a  430a              ORRS     r2,r2,r1
00000c  8202              STRH     r2,[r0,#0x10]
;;;483    }
00000e  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.USART_SetGuardTime||, CODE, READONLY, ALIGN=1

                  USART_SetGuardTime PROC
;;;637      */
;;;638    void USART_SetGuardTime(USART_TypeDef* USARTx, uint8_t USART_GuardTime)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;639    {    
;;;640      /* Check the parameters */
;;;641      assert_param(IS_USART_123_PERIPH(USARTx));
;;;642      
;;;643      /* Clear the USART Guard time */
;;;644      USARTx->GTPR &= GTPR_LSB_Mask;
000002  b2d2              UXTB     r2,r2
000004  8302              STRH     r2,[r0,#0x18]
;;;645      /* Set the USART guard time */
;;;646      USARTx->GTPR |= (uint16_t)((uint16_t)USART_GuardTime << 0x08);
000006  8b02              LDRH     r2,[r0,#0x18]
000008  ea422101          ORR      r1,r2,r1,LSL #8
00000c  8301              STRH     r1,[r0,#0x18]
;;;647    }
00000e  4770              BX       lr
;;;648    
                          ENDP


                          AREA ||i.USART_SetPrescaler||, CODE, READONLY, ALIGN=1

                  USART_SetPrescaler PROC
;;;657      */
;;;658    void USART_SetPrescaler(USART_TypeDef* USARTx, uint8_t USART_Prescaler)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;659    { 
;;;660      /* Check the parameters */
;;;661      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;662      
;;;663      /* Clear the USART prescaler */
;;;664      USARTx->GTPR &= GTPR_MSB_Mask;
000002  f402427f          AND      r2,r2,#0xff00
000006  8302              STRH     r2,[r0,#0x18]
;;;665      /* Set the USART prescaler */
;;;666      USARTx->GTPR |= USART_Prescaler;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;667    }
00000e  4770              BX       lr
;;;668    
                          ENDP


                          AREA ||i.USART_SmartCardCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardCmd PROC
;;;676      */
;;;677    void USART_SmartCardCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;678    {
;;;679      /* Check the parameters */
;;;680      assert_param(IS_USART_123_PERIPH(USARTx));
;;;681      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;682      if (NewState != DISABLE)
;;;683      {
;;;684        /* Enable the SC mode by setting the SCEN bit in the CR3 register */
;;;685        USARTx->CR3 |= CR3_SCEN_Set;
;;;686      }
;;;687      else
;;;688      {
;;;689        /* Disable the SC mode by clearing the SCEN bit in the CR3 register */
;;;690        USARTx->CR3 &= CR3_SCEN_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L26.12|
000006  f0410120          ORR      r1,r1,#0x20           ;685
00000a  e001              B        |L26.16|
                  |L26.12|
00000c  f0210120          BIC      r1,r1,#0x20
                  |L26.16|
000010  8281              STRH     r1,[r0,#0x14]         ;685
;;;691      }
;;;692    }
000012  4770              BX       lr
;;;693    
                          ENDP


                          AREA ||i.USART_SmartCardNACKCmd||, CODE, READONLY, ALIGN=1

                  USART_SmartCardNACKCmd PROC
;;;701      */
;;;702    void USART_SmartCardNACKCmd(USART_TypeDef* USARTx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;703    {
;;;704      /* Check the parameters */
;;;705      assert_param(IS_USART_123_PERIPH(USARTx));  
;;;706      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;707      if (NewState != DISABLE)
;;;708      {
;;;709        /* Enable the NACK transmission by setting the NACK bit in the CR3 register */
;;;710        USARTx->CR3 |= CR3_NACK_Set;
;;;711      }
;;;712      else
;;;713      {
;;;714        /* Disable the NACK transmission by clearing the NACK bit in the CR3 register */
;;;715        USARTx->CR3 &= CR3_NACK_Reset;
000002  8a81              LDRH     r1,[r0,#0x14]
000004  d002              BEQ      |L27.12|
000006  f0410110          ORR      r1,r1,#0x10           ;710
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f0210110          BIC      r1,r1,#0x10
                  |L27.16|
000010  8281              STRH     r1,[r0,#0x14]         ;710
;;;716      }
;;;717    }
000012  4770              BX       lr
;;;718    
                          ENDP


                          AREA ||i.USART_StructInit||, CODE, READONLY, ALIGN=1

                  USART_StructInit PROC
;;;277      */
;;;278    void USART_StructInit(USART_InitTypeDef* USART_InitStruct)
000000  f44f5116          MOV      r1,#0x2580
;;;279    {
;;;280      /* USART_InitStruct members default value */
;;;281      USART_InitStruct->USART_BaudRate = 9600;
;;;282      USART_InitStruct->USART_WordLength = USART_WordLength_8b;
000004  6001              STR      r1,[r0,#0]
000006  2100              MOVS     r1,#0
000008  8081              STRH     r1,[r0,#4]
;;;283      USART_InitStruct->USART_StopBits = USART_StopBits_1;
00000a  80c1              STRH     r1,[r0,#6]
;;;284      USART_InitStruct->USART_Parity = USART_Parity_No ;
00000c  8101              STRH     r1,[r0,#8]
;;;285      USART_InitStruct->USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00000e  220c              MOVS     r2,#0xc
000010  8142              STRH     r2,[r0,#0xa]
;;;286      USART_InitStruct->USART_HardwareFlowControl = USART_HardwareFlowControl_None;  
000012  8181              STRH     r1,[r0,#0xc]
;;;287    }
000014  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.USART_WakeUpConfig||, CODE, READONLY, ALIGN=1

                  USART_WakeUpConfig PROC
;;;495      */
;;;496    void USART_WakeUpConfig(USART_TypeDef* USARTx, uint16_t USART_WakeUp)
000000  8982              LDRH     r2,[r0,#0xc]
;;;497    {
;;;498      /* Check the parameters */
;;;499      assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;500      assert_param(IS_USART_WAKEUP(USART_WakeUp));
;;;501      
;;;502      USARTx->CR1 &= CR1_WAKE_Mask;
000002  f4226200          BIC      r2,r2,#0x800
000006  8182              STRH     r2,[r0,#0xc]
;;;503      USARTx->CR1 |= USART_WakeUp;
000008  8982              LDRH     r2,[r0,#0xc]
00000a  430a              ORRS     r2,r2,r1
00000c  8182              STRH     r2,[r0,#0xc]
;;;504    }
00000e  4770              BX       lr
;;;505    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_usart.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_stm32f10x_usart_c_9565154b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___17_stm32f10x_usart_c_9565154b____REVSH|
#line 128
|__asm___17_stm32f10x_usart_c_9565154b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
