; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\touch.o --depend=.\ouput\touch.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\touch.crf Source\uCGUI\LCDDriver\Touch\Touch.c]
                          THUMB

                          AREA ||i.Pen_Int_Set||, CODE, READONLY, ALIGN=2

                  Pen_Int_Set PROC
;;;243    *****************************************************************************/	 
;;;244    void Pen_Int_Set(u8 en)
000000  4906              LDR      r1,|L1.28|
;;;245    {
;;;246    	if(en)EXTI->IMR|=1<<7;   //开启line13上的中断	  	
000002  2800              CMP      r0,#0
;;;247    	else EXTI->IMR&=~(1<<7); //关闭line13上的中断	   
000004  f8d10400          LDR      r0,[r1,#0x400]
000008  d002              BEQ      |L1.16|
00000a  f0400080          ORR      r0,r0,#0x80           ;246
00000e  e001              B        |L1.20|
                  |L1.16|
000010  f0200080          BIC      r0,r0,#0x80
                  |L1.20|
000014  f8c10400          STR      r0,[r1,#0x400]        ;246
;;;248    }
000018  4770              BX       lr
;;;249    /*****************************************************************************
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40010000

                          AREA ||i.SPI_WriteByte||, CODE, READONLY, ALIGN=2

                  SPI_WriteByte PROC
;;;348    
;;;349    unsigned char SPI_WriteByte(unsigned char data) 
000000  b570              PUSH     {r4-r6,lr}
;;;350    { 
;;;351     unsigned char Data01 = 0; 
;;;352    
;;;353       //Wait until the transmit buffer is empty 
;;;354      while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_TXE)==RESET); 
000002  4c0d              LDR      r4,|L2.56|
000004  4605              MOV      r5,r0                 ;350
                  |L2.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L2.6|
;;;355      // Send the byte  
;;;356      SPI_I2S_ReceiveData(SPI1);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       SPI_I2S_ReceiveData
;;;357      SPI_I2S_SendData(SPI1,data); 
000018  4629              MOV      r1,r5
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       SPI_I2S_SendData
                  |L2.32|
;;;358    
;;;359       //Wait until a data is received 
;;;360      while(SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE)==RESET); 
000020  2101              MOVS     r1,#1
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       SPI_I2S_GetFlagStatus
000028  2800              CMP      r0,#0
00002a  d0f9              BEQ      |L2.32|
;;;361      // Get the received data 
;;;362      Data01 = SPI_I2S_ReceiveData(SPI1); 
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       SPI_I2S_ReceiveData
000032  b2c0              UXTB     r0,r0
;;;363    
;;;364      // Return the shifted data 
;;;365      return Data01; 
;;;366    }  
000034  bd70              POP      {r4-r6,pc}
;;;367    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      0x40013000

                          AREA ||i.SpiDelay||, CODE, READONLY, ALIGN=1

                  SpiDelay PROC
;;;368    
;;;369    void SpiDelay(unsigned int DelayCnt)
000000  2100              MOVS     r1,#0
;;;370    {
;;;371     unsigned int i;
;;;372     for(i=0;i<DelayCnt;i++);
000002  e000              B        |L3.6|
                  |L3.4|
000004  1c49              ADDS     r1,r1,#1
                  |L3.6|
000006  4281              CMP      r1,r0
000008  d3fc              BCC      |L3.4|
;;;373    }
00000a  4770              BX       lr
;;;374    
                          ENDP


                          AREA ||i.TOUCH_DataFilter||, CODE, READONLY, ALIGN=1

                  TOUCH_DataFilter PROC
;;;440    //
;;;441    uint16_t TOUCH_DataFilter(uint8_t xy)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;442    {
;;;443    	uint16_t i, j;
;;;444        uint16_t buf[ADC_READ_TIME];
;;;445        uint16_t usSum;
;;;446        uint16_t usTemp;
;;;447    	usSum = 0;
000004  2400              MOVS     r4,#0
000006  4607              MOV      r7,r0                 ;442
;;;448    	
;;;449        for(i=0; i < ADC_READ_TIME; i++)
000008  4626              MOV      r6,r4
00000a  466d              MOV      r5,sp                 ;444
                  |L4.12|
;;;450        {
;;;451         	if(xy == 1)
00000c  2f01              CMP      r7,#1
00000e  d00b              BEQ      |L4.40|
;;;452    		{
;;;453            buf[i] = TPReadX();
;;;454    		}else{
;;;455    		buf[i] = TPReadY();
000010  f7fffffe          BL       TPReadY
                  |L4.20|
000014  f8250016          STRH     r0,[r5,r6,LSL #1]
000018  1c76              ADDS     r6,r6,#1              ;449
00001a  b2b6              UXTH     r6,r6                 ;449
00001c  2e08              CMP      r6,#8                 ;449
00001e  d3f5              BCC      |L4.12|
;;;456    		}
;;;457        }
;;;458                            
;;;459        for(i = 0; i < ADC_READ_TIME - 1; i++)
000020  2100              MOVS     r1,#0
                  |L4.34|
;;;460        {
;;;461            for(j = i + 1; j < ADC_READ_TIME; j++)
000022  1c4e              ADDS     r6,r1,#1
000024  b2b0              UXTH     r0,r6
000026  e00e              B        |L4.70|
                  |L4.40|
000028  f7fffffe          BL       TPReadX
00002c  e7f2              B        |L4.20|
                  |L4.46|
;;;462            {
;;;463                if(buf[i] > buf[j])
00002e  f8353011          LDRH     r3,[r5,r1,LSL #1]
000032  f8352010          LDRH     r2,[r5,r0,LSL #1]
000036  4293              CMP      r3,r2
000038  d903              BLS      |L4.66|
;;;464                {
;;;465                    usTemp = buf[i];
;;;466                    buf[i] = buf[j];
00003a  f8252011          STRH     r2,[r5,r1,LSL #1]
;;;467                    buf[j] = usTemp;
00003e  f8253010          STRH     r3,[r5,r0,LSL #1]
                  |L4.66|
000042  1c40              ADDS     r0,r0,#1              ;461
000044  b280              UXTH     r0,r0                 ;461
                  |L4.70|
000046  2808              CMP      r0,#8                 ;461
000048  d3f1              BCC      |L4.46|
00004a  b2b1              UXTH     r1,r6                 ;459
00004c  2907              CMP      r1,#7                 ;459
00004e  d3e8              BCC      |L4.34|
;;;468                }
;;;469            }
;;;470        }     
;;;471        
;;;472     
;;;473        for(i = DISCARD_No; i < ADC_READ_TIME - DISCARD_No; i++)
000050  2002              MOVS     r0,#2
                  |L4.82|
;;;474        {
;;;475            usSum += buf[i];
000052  f8351010          LDRH     r1,[r5,r0,LSL #1]
000056  1c40              ADDS     r0,r0,#1              ;473
000058  4421              ADD      r1,r1,r4
00005a  b280              UXTH     r0,r0                 ;473
00005c  b28c              UXTH     r4,r1
00005e  2806              CMP      r0,#6                 ;473
000060  d3f7              BCC      |L4.82|
;;;476        }
;;;477       
;;;478        usTemp = usSum / (ADC_READ_TIME - 2 * DISCARD_No);
;;;479    
;;;480        return usTemp; 
;;;481    }
000062  b004              ADD      sp,sp,#0x10
000064  08a0              LSRS     r0,r4,#2              ;478
000066  e8bd81f0          POP      {r4-r8,pc}
;;;482    
                          ENDP


                          AREA ||i.TOUCH_ReadAdcXY||, CODE, READONLY, ALIGN=1

                  TOUCH_ReadAdcXY PROC
;;;483     
;;;484    uint8_t TOUCH_ReadAdcXY(uint16_t *_usX, uint16_t *_usY) 
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;485    {
000004  4607              MOV      r7,r0
000006  4688              MOV      r8,r1
;;;486        uint16_t iX1, iY1;
;;;487        uint16_t iX2, iY2;
;;;488        uint16_t iX, iY;
;;;489    
;;;490        iY1 = TOUCH_DataFilter(ADC_CH_Y);
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       TOUCH_DataFilter
00000e  4605              MOV      r5,r0
;;;491        iX1 = TOUCH_DataFilter(ADC_CH_X);
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       TOUCH_DataFilter
000016  4604              MOV      r4,r0
;;;492        iY2 = TOUCH_DataFilter(ADC_CH_Y);
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       TOUCH_DataFilter
00001e  4606              MOV      r6,r0
;;;493        iX2 = TOUCH_DataFilter(ADC_CH_X);
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       TOUCH_DataFilter
000026  4601              MOV      r1,r0
;;;494    
;;;495        iX = abs(iX1 - iX2);
000028  1a20              SUBS     r0,r4,r0
00002a  d501              BPL      |L5.48|
00002c  f1c00000          RSB      r0,r0,#0
                  |L5.48|
000030  b282              UXTH     r2,r0
;;;496        iY = abs(iY1 - iY2); 
000032  1ba8              SUBS     r0,r5,r6
000034  d500              BPL      |L5.56|
000036  4240              RSBS     r0,r0,#0
                  |L5.56|
000038  b280              UXTH     r0,r0
;;;497    
;;;498        /* 前后两次采样在+-ADC_ERR_RANGE内 */  
;;;499        if ((iX <= ADC_ERR_RANGE) && (iY <= ADC_ERR_RANGE))
00003a  2a0c              CMP      r2,#0xc
00003c  d80b              BHI      |L5.86|
00003e  280c              CMP      r0,#0xc
000040  d809              BHI      |L5.86|
;;;500        {       
;;;501            *_usX = (iX1 + iX2) / 2;
000042  1860              ADDS     r0,r4,r1
000044  0840              LSRS     r0,r0,#1
000046  8038              STRH     r0,[r7,#0]
;;;502            *_usY = (iY1 + iY2) / 2;
000048  19a8              ADDS     r0,r5,r6
00004a  0841              LSRS     r1,r0,#1
00004c  f8a81000          STRH     r1,[r8,#0]
;;;503    
;;;504            return 1;
000050  2001              MOVS     r0,#1
                  |L5.82|
;;;505        }
;;;506        else 
;;;507        {
;;;508            return 0;
;;;509        }      
;;;510    } 
000052  e8bd81f0          POP      {r4-r8,pc}
                  |L5.86|
000056  2000              MOVS     r0,#0                 ;508
000058  e7fb              B        |L5.82|
;;;511    
                          ENDP


                          AREA ||i.TOUCH_Scan||, CODE, READONLY, ALIGN=2

                  TOUCH_Scan PROC
;;;513    
;;;514    void TOUCH_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;515    {
;;;516    
;;;517        uint8_t s_invalid_count = 0;
000002  2400              MOVS     r4,#0
;;;518    	uint8_t flag;
;;;519    	
;;;520       
;;;521        if (TOUCH_PRESSING == 0)
000004  2110              MOVS     r1,#0x10
000006  4811              LDR      r0,|L6.76|
000008  f7fffffe          BL       GPIO_ReadInputDataBit
;;;522        {   
;;;523    	              
;;;524            while(!TOUCH_ReadAdcXY(&g_tTP.usAdcNowX, &g_tTP.usAdcNowY)&&(s_invalid_count<5));
00000c  4e10              LDR      r6,|L6.80|
00000e  2500              MOVS     r5,#0                 ;517
000010  b950              CBNZ     r0,|L6.40|
                  |L6.18|
000012  1cb1              ADDS     r1,r6,#2
000014  480e              LDR      r0,|L6.80|
000016  f7fffffe          BL       TOUCH_ReadAdcXY
00001a  b908              CBNZ     r0,|L6.32|
00001c  2c05              CMP      r4,#5
00001e  d3f8              BCC      |L6.18|
                  |L6.32|
;;;525            {
;;;526                s_invalid_count++;
000020  1c64              ADDS     r4,r4,#1
000022  b2e0              UXTB     r0,r4
;;;527            }
;;;528            
;;;529            if(s_invalid_count >= 5)
000024  2805              CMP      r0,#5
000026  d301              BCC      |L6.44|
                  |L6.40|
;;;530            {
;;;531                g_tTP.usAdcNowX = 0;
000028  8035              STRH     r5,[r6,#0]
;;;532                g_tTP.usAdcNowY = 0;    
00002a  8075              STRH     r5,[r6,#2]
                  |L6.44|
;;;533            }
;;;534        }
;;;535        else
;;;536        {
;;;537            g_tTP.usAdcNowX = 0;
;;;538            g_tTP.usAdcNowY = 0;
;;;539        }
;;;540    	GUI_DispDecAt( g_tTP.usAdcNowX, 400, 400, 5);
00002c  f44f71c8          MOV      r1,#0x190
000030  8830              LDRH     r0,[r6,#0]  ; g_tTP
000032  2305              MOVS     r3,#5
000034  460a              MOV      r2,r1
000036  f7fffffe          BL       GUI_DispDecAt
;;;541    	GUI_DispDecAt( g_tTP.usAdcNowY, 450, 450, 5);
00003a  8870              LDRH     r0,[r6,#2]  ; g_tTP
00003c  e8bd4070          POP      {r4-r6,lr}
000040  f44f71e1          MOV      r1,#0x1c2
000044  2305              MOVS     r3,#5
000046  460a              MOV      r2,r1
000048  f7ffbffe          B.W      GUI_DispDecAt
;;;542    }
;;;543    
                          ENDP

                  |L6.76|
                          DCD      0x40011000
                  |L6.80|
                          DCD      ||area_number.17||

                          AREA ||i.TPReadX||, CODE, READONLY, ALIGN=2

                  TPReadX PROC
;;;374    
;;;375    u16 TPReadX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;376    { 
;;;377       u16 x=0;
;;;378       TP_CS();
000002  4d14              LDR      r5,|L7.84|
000004  2108              MOVS     r1,#8
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       GPIO_ResetBits
;;;379       SpiDelay(10);
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       SpiDelay
;;;380       SPI_WriteByte(0xd0);
000012  20d0              MOVS     r0,#0xd0
000014  f7fffffe          BL       SPI_WriteByte
;;;381       SpiDelay(10);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       SpiDelay
;;;382       x=SPI_WriteByte(0x00);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SPI_WriteByte
;;;383       x<<=8;
000024  0204              LSLS     r4,r0,#8
;;;384       x+=SPI_WriteByte(0x00);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       SPI_WriteByte
00002c  4420              ADD      r0,r0,r4
00002e  b284              UXTH     r4,r0
;;;385       SpiDelay(20);
000030  2014              MOVS     r0,#0x14
000032  f7fffffe          BL       SpiDelay
;;;386       TP_DCS();
000036  2108              MOVS     r1,#8
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_SetBits
;;;387       //x = 3671 - x; 
;;;388       x = x>>3;
00003e  08e4              LSRS     r4,r4,#3
;;;389    
;;;390      GUI_DispDecAt(x, 300, 300, 5);
000040  f44f7196          MOV      r1,#0x12c
000044  2305              MOVS     r3,#5
000046  460a              MOV      r2,r1
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       GUI_DispDecAt
;;;391      return (x);
00004e  4620              MOV      r0,r4
;;;392    }
000050  bd70              POP      {r4-r6,pc}
;;;393    
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      0x40011000

                          AREA ||i.TPReadY||, CODE, READONLY, ALIGN=2

                  TPReadY PROC
;;;393    
;;;394    u16 TPReadY(void)
000000  b570              PUSH     {r4-r6,lr}
;;;395    {
;;;396     u16 y=0;
;;;397      TP_CS();
000002  4d14              LDR      r5,|L8.84|
000004  2108              MOVS     r1,#8
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       GPIO_ResetBits
;;;398      SpiDelay(10);
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       SpiDelay
;;;399      SPI_WriteByte(0x90);
000012  2090              MOVS     r0,#0x90
000014  f7fffffe          BL       SPI_WriteByte
;;;400      SpiDelay(10);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       SpiDelay
;;;401      y=SPI_WriteByte(0x00);
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SPI_WriteByte
;;;402      y<<=8;
000024  0204              LSLS     r4,r0,#8
;;;403      y+=SPI_WriteByte(0x00);
000026  2000              MOVS     r0,#0
000028  f7fffffe          BL       SPI_WriteByte
00002c  4420              ADD      r0,r0,r4
00002e  b284              UXTH     r4,r0
;;;404      SpiDelay(20);
000030  2014              MOVS     r0,#0x14
000032  f7fffffe          BL       SpiDelay
;;;405      TP_DCS();
000036  2108              MOVS     r1,#8
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       GPIO_SetBits
;;;406      //y = 3601 - y;
;;;407      y = y>>3;
00003e  08e4              LSRS     r4,r4,#3
;;;408       
;;;409      GUI_DispDecAt(y, 350, 300, 5);
000040  2305              MOVS     r3,#5
000042  f44f7296          MOV      r2,#0x12c
000046  f44f71af          MOV      r1,#0x15e
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       GUI_DispDecAt
;;;410    
;;;411      return (y);
000050  4620              MOV      r0,r4
;;;412    }
000052  bd70              POP      {r4-r6,pc}
;;;413    
                          ENDP

                  |L8.84|
                          DCD      0x40011000

                          AREA ||i.Touch_Configuration||, CODE, READONLY, ALIGN=1

                  Touch_Configuration PROC
;;;167    
;;;168    void Touch_Configuration()	//bsp.c中配置
000000  4770              BX       lr
;;;169    {	
;;;170     #if 0
;;;171    	GPIO_InitTypeDef GPIO_InitStructure;
;;;172    
;;;173    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_GPIOG | RCC_APB2Periph_AFIO
;;;174    							, ENABLE );  //重要！！
;;;175    
;;;176    	//下面是SPI相关GPIO初始化	sck mosi
;;;177    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_15;
;;;178    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //通用推挽输出
;;;179    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;180    	GPIO_Init(GPIOB,&GPIO_InitStructure);
;;;181    
;;;182    	//下面是SPI相关GPIO初始化	miso
;;;183    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_14;
;;;184    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  //上拉输入
;;;185    	GPIO_Init(GPIOB,&GPIO_InitStructure);
;;;186    
;;;187    	//Configure PB12 pin: TP_CS pin 
;;;188    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12; 
;;;189    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 	//通用推挽输出
;;;190    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;191    	GPIO_Init(GPIOB,&GPIO_InitStructure);
;;;192    //sd_cs
;;;193    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_15; 
;;;194    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 	//通用推挽输出
;;;195    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;196    	GPIO_Init(GPIOG,&GPIO_InitStructure);
;;;197    
;;;198    //flash_cs 
;;;199    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11; 
;;;200    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 	//通用推挽输出
;;;201    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
;;;202    	GPIO_Init(GPIOG,&GPIO_InitStructure);
;;;203    
;;;204    	GPIO_SetBits(GPIOG,GPIO_Pin_15);     //不选中SD卡
;;;205        GPIO_SetBits(GPIOG,GPIO_Pin_11);     //不选中FLASH卡
;;;206    
;;;207    	//Configure PG7 pin: TP_INT pin 
;;;208    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7; 
;;;209    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU; 	//上拉输入
;;;210    	GPIO_Init(GPIOG,&GPIO_InitStructure);
;;;211    
;;;212    
;;;213    	/*********gan**********/
;;;214    	{
;;;215    		SPI_InitTypeDef   SPI_InitStructure; 
;;;216       		//SPI2 Periph clock enable 
;;;217      		RCC_APB1PeriphClockCmd( RCC_APB1Periph_SPI2, ENABLE );
;;;218    
;;;219    		// SPI2 Config  
;;;220      		SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
;;;221    	  	SPI_InitStructure.SPI_Mode = SPI_Mode_Master; 
;;;222    	  	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; 
;;;223    	  	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low; 
;;;224    	  	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; 
;;;225    	  	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;   
;;;226    	  	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64; 
;;;227    	  	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; 
;;;228    	  	SPI_InitStructure.SPI_CRCPolynomial = 7; 
;;;229    	  	SPI_Init(SPI2,&SPI_InitStructure); 
;;;230    
;;;231      		// SPI2 enable  
;;;232      		SPI_Cmd(SPI2,ENABLE);
;;;233    	}
;;;234    	#endif
;;;235    }
;;;236    /*****************************************************************************
                          ENDP


                          AREA ||i.get_calibrate_data||, CODE, READONLY, ALIGN=2

                  get_calibrate_data PROC
;;;420    
;;;421    void get_calibrate_data(uint16_t* cal_data)
000000  4a05              LDR      r2,|L10.24|
;;;422    {
;;;423    	int i;
;;;424    	for(i=0;i<5;i++)
000002  2100              MOVS     r1,#0
                  |L10.4|
;;;425    	{
;;;426    	cal_data[i]= (*(__IO uint16_t*)(BANK511_WRITE_START_ADDR+i*2)); 
000004  eb020341          ADD      r3,r2,r1,LSL #1
000008  f8b33800          LDRH     r3,[r3,#0x800]
00000c  f8203011          STRH     r3,[r0,r1,LSL #1]
000010  1c49              ADDS     r1,r1,#1              ;424
000012  2905              CMP      r1,#5                 ;424
000014  dbf6              BLT      |L10.4|
;;;427        } 
;;;428    }
000016  4770              BX       lr
;;;429    
                          ENDP

                  |L10.24|
                          DCD      0x080ff000

                          AREA ||i.get_calibrate_state||, CODE, READONLY, ALIGN=2

                  get_calibrate_state PROC
;;;414    
;;;415    unsigned int get_calibrate_state(void)
000000  4801              LDR      r0,|L11.8|
;;;416    {
;;;417       return  (*(__IO uint16_t*)CAL_STATE_ADDR); 
000002  8800              LDRH     r0,[r0,#0]
;;;418    
;;;419    }
000004  4770              BX       lr
;;;420    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      0x080ff800

                          AREA ||i.save_calibrate_to_flash||, CODE, READONLY, ALIGN=2

                  save_calibrate_to_flash PROC
;;;429    
;;;430    FLASH_Status  save_calibrate_to_flash(uint16_t* data)
000000  4601              MOV      r1,r0
;;;431    {
;;;432    
;;;433        return flash_pro(CAL_STATE_ADDR, data,5);
000002  2205              MOVS     r2,#5
000004  4801              LDR      r0,|L12.12|
000006  f7ffbffe          B.W      flash_pro
;;;434    }
;;;435    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      0x080ff800

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  Pen_Point
                          %        24

                          AREA ||.data||, DATA, ALIGN=2

                  EXTI_InitStructure
                          %        8

                          AREA ||area_number.17||, DATA, ALIGN=1

                          EXPORTAS ||area_number.17||, ||.data||
                  g_tTP
                          DCDU     0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\uCGUI\\LCDDriver\\Touch\\Touch.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_Touch_c_19cd3ab2____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_Touch_c_19cd3ab2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___7_Touch_c_19cd3ab2____REVSH|
#line 128
|__asm___7_Touch_c_19cd3ab2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
