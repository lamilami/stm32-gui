; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\bsp.o --depend=.\ouput\bsp.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\bsp.crf Source\BSP\bsp.c]
                          THUMB

                          AREA ||i.BSP_Init||, CODE, READONLY, ALIGN=2

                  BSP_Init PROC
;;;112    extern LCD_Clear(u16 c);
;;;113    void  BSP_Init(void)
000000  b508              PUSH     {r3,lr}
;;;114    {
;;;115    	unsigned int delay;
;;;116        /* Initialize the uC/OS-II tick interrupt    */
;;;117    	RCC_Config();
000002  f7fffffe          BL       RCC_Config
;;;118    	GPIO_Config();
000006  f7fffffe          BL       GPIO_Config
;;;119    	SPI_Config();
00000a  f7fffffe          BL       SPI_Config
;;;120    	UART_Config();
00000e  f7fffffe          BL       UART_Config
;;;121    	FSMC_Config();
000012  f7fffffe          BL       FSMC_Config
;;;122    	Lcd_Init();
000016  f7fffffe          BL       Lcd_Init
;;;123    	
;;;124    	MMA845x_Init();
00001a  f7fffffe          BL       MMA845x_Init
;;;125    	MMA845X_TIM6_Init(); 
00001e  f7fffffe          BL       MMA845X_TIM6_Init
;;;126    	
;;;127    //	SDCard_Init();
;;;128    	disk_initialize(0);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       disk_initialize
;;;129    
;;;130    	RTC_Config_Init();
000028  f7fffffe          BL       RTC_Config_Init
;;;131      	
;;;132    	EXTI_Config();
;;;133    	NVIC_Configuration();
00002c  f7fffffe          BL       NVIC_Configuration
;;;134    
;;;135    	SPI_Enc28j60_Init();
000030  f7fffffe          BL       SPI_Enc28j60_Init
;;;136    	tftp_init();
000034  f7fffffe          BL       tftp_init
;;;137        
;;;138    	GUI_Init();//初始化GUI
000038  f7fffffe          BL       GUI_Init
;;;139    	GUI_SetBkColor(GUI_BLACK);//设置背景颜色为白色
00003c  2000              MOVS     r0,#0
00003e  f7fffffe          BL       GUI_SetBkColor
;;;140    	GUI_FillRect(0,0,320,240);//清屏
000042  2100              MOVS     r1,#0
000044  23f0              MOVS     r3,#0xf0
000046  f44f72a0          MOV      r2,#0x140
00004a  4608              MOV      r0,r1
00004c  f7fffffe          BL       GUI_FillRect
;;;141    	LCD_Clear(GUI_BLACK);
000050  2000              MOVS     r0,#0
000052  f7fffffe          BL       LCD_Clear
;;;142    	GUI_Line(1, 45, 80, 100,(u16)GUI_BLUE);
000056  2300              MOVS     r3,#0
000058  9300              STR      r3,[sp,#0]
00005a  2364              MOVS     r3,#0x64
00005c  2250              MOVS     r2,#0x50
00005e  212d              MOVS     r1,#0x2d
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       GUI_Line
;;;143    	
;;;144    	GUI_DispString("Hello world!");
000066  a005              ADR      r0,|L1.124|
000068  f7fffffe          BL       GUI_DispString
;;;145    	LCD_Clear(GUI_WHITE);
00006c  f64f70ff          MOV      r0,#0xffff
000070  f7fffffe          BL       LCD_Clear
;;;146    //while(1);
;;;147    //Touch_Configuration();
;;;148       	OS_CPU_SysTickInit();
000074  e8bd4008          POP      {r3,lr}
000078  f7ffbffe          B.W      OS_CPU_SysTickInit
;;;149      
;;;150      //spi_at45db161d_initial(); 
;;;151    }
;;;152    
                          ENDP

                  |L1.124|
00007c  48656c6c          DCB      "Hello world!",0
000080  6f20776f
000084  726c6421
000088  00      
000089  00                DCB      0
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.BSP_IntDisAll||, CODE, READONLY, ALIGN=1

                  BSP_IntDisAll PROC
;;;170    */
;;;171    void  BSP_IntDisAll (void)
000000  4770              BX       lr
;;;172    {
;;;173      // CPU_IntDis();
;;;174    }
;;;175    
                          ENDP


                          AREA ||i.EXTI_Config||, CODE, READONLY, ALIGN=1

                  EXTI_Config PROC
;;;541    /*配置中断引脚*/
;;;542    void EXTI_Config(void)
000000  4770              BX       lr
;;;543    {
;;;544    
;;;545    }
;;;546    
                          ENDP


                          AREA ||i.FSMC_Config||, CODE, READONLY, ALIGN=1

                  FSMC_Config PROC
;;;410    
;;;411    void FSMC_Config(void)
000000  b500              PUSH     {lr}
;;;412    {
000002  b097              SUB      sp,sp,#0x5c
;;;413    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;414      	FSMC_NORSRAMTimingInitTypeDef  p;
;;;415    
;;;416    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;417      	p.FSMC_AddressSetupTime = 0;
000004  2000              MOVS     r0,#0
;;;418      	p.FSMC_AddressHoldTime = 0;
;;;419      	p.FSMC_DataSetupTime = 1;
000006  2101              MOVS     r1,#1
000008  9010              STR      r0,[sp,#0x40]
00000a  e9cd0111          STRD     r0,r1,[sp,#0x44]
;;;420      	p.FSMC_BusTurnAroundDuration = 0;
;;;421      	p.FSMC_CLKDivision = 0;
00000e  9013              STR      r0,[sp,#0x4c]
;;;422      	p.FSMC_DataLatency = 0;
;;;423      	p.FSMC_AccessMode = FSMC_AccessMode_B;
000010  0709              LSLS     r1,r1,#28
000012  9014              STR      r0,[sp,#0x50]
000014  e9cd0115          STRD     r0,r1,[sp,#0x54]
;;;424    
;;;425      	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM1;   //
;;;426      	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;	// 关闭总线复用
;;;427      	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_NOR;		 //fsmc储存模式
000018  2108              MOVS     r1,#8
00001a  e9cd0102          STRD     r0,r1,[sp,#8]
;;;428      	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;   // 数据宽度
00001e  2110              MOVS     r1,#0x10
000020  e9cd1004          STRD     r1,r0,[sp,#0x10]
000024  9001              STR      r0,[sp,#4]            ;427
;;;429      	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;  // 关闭突发访问模式
;;;430      	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;	//	等待信号为低电平
;;;431      	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;	   // 关闭环绕模式
000026  9007              STR      r0,[sp,#0x1c]
;;;432      	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState; //
;;;433      	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;	   //  写操作使能
000028  0209              LSLS     r1,r1,#8
00002a  9008              STR      r0,[sp,#0x20]
00002c  e9cd0109          STRD     r0,r1,[sp,#0x24]
;;;434      	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;	   //	关闭等待信号
;;;435      	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;	 //	关闭扩展方式
000030  900b              STR      r0,[sp,#0x2c]
;;;436     	// FSMC_NORSRAMInitStructure.FSMC_AsyncWait = FSMC_AsyncWait_Disable;	  // 关闭异步等待 //gan 2012-07-22
;;;437      	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait =FSMC_AsynchronousWait_Disable;//gan 2012-07-22
000032  900c              STR      r0,[sp,#0x30]
;;;438      	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;	  // 关闭突发写
000034  9006              STR      r0,[sp,#0x18]
;;;439      	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;		 //
000036  900d              STR      r0,[sp,#0x34]
000038  a810              ADD      r0,sp,#0x40
;;;440      	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;		   //
00003a  900e              STR      r0,[sp,#0x38]
;;;441      
;;;442      	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure); 
00003c  900f              STR      r0,[sp,#0x3c]
00003e  a801              ADD      r0,sp,#4
000040  f7fffffe          BL       FSMC_NORSRAMInit
;;;443    
;;;444      	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM1, ENABLE); 	
000044  2101              MOVS     r1,#1
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       FSMC_NORSRAMCmd
;;;445    }
00004c  b017              ADD      sp,sp,#0x5c
00004e  bd00              POP      {pc}
;;;446    
                          ENDP


                          AREA ||i.GPIO_Config||, CODE, READONLY, ALIGN=2

                  GPIO_Config PROC
;;;205    
;;;206    void GPIO_Config(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;207    {
;;;208    	GPIO_InitTypeDef GPIO_InitStructure;
;;;209    	/************   串口1     ***************/
;;;210    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000004  f04f0902          MOV      r9,#2
000008  f88d9002          STRB     r9,[sp,#2]
;;;211    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;	//TX         
00000c  f44f7000          MOV      r0,#0x200
000010  f8ad0000          STRH     r0,[sp,#0]
;;;212    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  
000014  2618              MOVS     r6,#0x18
000016  f88d6003          STRB     r6,[sp,#3]
;;;213    	GPIO_Init(GPIOA, &GPIO_InitStructure);		   
00001a  4669              MOV      r1,sp
00001c  4887              LDR      r0,|L5.572|
00001e  f7fffffe          BL       GPIO_Init
;;;214    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;	 //RX       
000022  f44f6080          MOV      r0,#0x400
000026  f8ad0000          STRH     r0,[sp,#0]
;;;215    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   
00002a  2504              MOVS     r5,#4
00002c  f88d5003          STRB     r5,[sp,#3]
;;;216    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000030  4669              MOV      r1,sp
000032  4882              LDR      r0,|L5.572|
000034  f7fffffe          BL       GPIO_Init
;;;217    
;;;218    	/**************  串口2    *******************/
;;;219    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000038  f88d9002          STRB     r9,[sp,#2]
;;;220    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;	//TX         
00003c  f8ad5000          STRH     r5,[sp,#0]
;;;221    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  
000040  f88d6003          STRB     r6,[sp,#3]
;;;222    	GPIO_Init(GPIOA, &GPIO_InitStructure);		   
000044  4669              MOV      r1,sp
000046  487d              LDR      r0,|L5.572|
000048  f7fffffe          BL       GPIO_Init
;;;223    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;	 //RX       
00004c  f04f0808          MOV      r8,#8
000050  f8ad8000          STRH     r8,[sp,#0]
;;;224    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;   
000054  f88d5003          STRB     r5,[sp,#3]
;;;225    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000058  4669              MOV      r1,sp
00005a  4878              LDR      r0,|L5.572|
00005c  f7fffffe          BL       GPIO_Init
;;;226    	//#if defined	 RS485_EN
;;;227       	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000060  2403              MOVS     r4,#3
000062  f88d4002          STRB     r4,[sp,#2]
;;;228    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;  //RS485方向选择
000066  f44f7b80          MOV      r11,#0x100
00006a  f8adb000          STRH     r11,[sp,#0]
;;;229    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  
00006e  2048              MOVS     r0,#0x48
000070  f88d0003          STRB     r0,[sp,#3]
;;;230    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000074  4669              MOV      r1,sp
000076  4871              LDR      r0,|L5.572|
000078  f7fffffe          BL       GPIO_Init
;;;231        //Delay(200);
;;;232    	//GPIO_ResetBits(GPIOA, GPIO_Pin_8);    
;;;233    	//Delay(200);
;;;234    	GPIO_SetBits(GPIOA, GPIO_Pin_8);   
00007c  4659              MOV      r1,r11
00007e  486f              LDR      r0,|L5.572|
000080  f7fffffe          BL       GPIO_SetBits
;;;235    	
;;;236    	//#endif
;;;237    
;;;238    	/********   串口3   *******************/
;;;239    
;;;240    	/****************  触摸板   SPI1  ******************/
;;;241      	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;  //Configure SPI1 pins: SCK, MISO and MOSI 
000084  20e0              MOVS     r0,#0xe0
000086  f8ad0000          STRH     r0,[sp,#0]
;;;242      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
00008a  f88d4002          STRB     r4,[sp,#2]
;;;243      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   //复用推挽输出
00008e  f88d6003          STRB     r6,[sp,#3]
;;;244      	GPIO_Init(GPIOA,&GPIO_InitStructure); 
000092  4669              MOV      r1,sp
000094  4869              LDR      r0,|L5.572|
000096  f7fffffe          BL       GPIO_Init
;;;245    
;;;246    	#ifdef RED_BULL  //红牛开发板
;;;247    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;  //触摸板片选
;;;248    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  
;;;249    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;250    	#else 
;;;251    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;  //触摸板片选
00009a  f8ad8000          STRH     r8,[sp,#0]
;;;252    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  
00009e  2710              MOVS     r7,#0x10
0000a0  f88d7003          STRB     r7,[sp,#3]
;;;253    	GPIO_Init(GPIOC, &GPIO_InitStructure); 
0000a4  4669              MOV      r1,sp
0000a6  4866              LDR      r0,|L5.576|
0000a8  f7fffffe          BL       GPIO_Init
;;;254    	#endif
;;;255    
;;;256    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6;  //触摸板中断
0000ac  f04f0a40          MOV      r10,#0x40
0000b0  f8ada000          STRH     r10,[sp,#0]
;;;257    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  
0000b4  f88d5003          STRB     r5,[sp,#3]
;;;258    	GPIO_Init(GPIOD, &GPIO_InitStructure); 
0000b8  4669              MOV      r1,sp
0000ba  4862              LDR      r0,|L5.580|
0000bc  f7fffffe          BL       GPIO_Init
;;;259    
;;;260    	/*************   网络  SPI2    ***********************/
;;;261      	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15; 	//Configure SPI2 pins: SCK, MISO and MOSI 
0000c0  f44f4060          MOV      r0,#0xe000
0000c4  f8ad0000          STRH     r0,[sp,#0]
;;;262      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
0000c8  f88d4002          STRB     r4,[sp,#2]
;;;263      	GPIO_InitStructure.GPIO_Mode  = GPIO_Mode_AF_PP;   //复用推挽输出
0000cc  f88d6003          STRB     r6,[sp,#3]
;;;264      	GPIO_Init(GPIOA,&GPIO_InitStructure); 
0000d0  4669              MOV      r1,sp
0000d2  485a              LDR      r0,|L5.572|
0000d4  f7fffffe          BL       GPIO_Init
;;;265    
;;;266    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_6;  //网络中断
0000d8  f8ada000          STRH     r10,[sp,#0]
;;;267    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;  
0000dc  f88d5003          STRB     r5,[sp,#3]
;;;268    	GPIO_Init(GPIOD, &GPIO_InitStructure); 
0000e0  4669              MOV      r1,sp
0000e2  4858              LDR      r0,|L5.580|
0000e4  f7fffffe          BL       GPIO_Init
;;;269    
;;;270    	GPIO_InitStructure.GPIO_Pin  = GPIO_Pin_12;  //网口片选
0000e8  02a8              LSLS     r0,r5,#10
0000ea  f8ad0000          STRH     r0,[sp,#0]
;;;271    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  
0000ee  f88d7003          STRB     r7,[sp,#3]
;;;272    	GPIO_Init(GPIOB, &GPIO_InitStructure); 
0000f2  4669              MOV      r1,sp
0000f4  4854              LDR      r0,|L5.584|
0000f6  f7fffffe          BL       GPIO_Init
;;;273    
;;;274    	#ifndef RED_BULL  //红牛开发板
;;;275    	/***********   AT45DB161D  SPI3    *********************/
;;;276    	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);    //JTAG-DP Disabled and SW-DP Enabled   
0000fa  2101              MOVS     r1,#1
0000fc  4853              LDR      r0,|L5.588|
0000fe  f7fffffe          BL       GPIO_PinRemapConfig
;;;277      	GPIO_InitStructure.GPIO_Pin   = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;  //Configure SPI3 pins: SCK, MISO and MOSI
000102  2038              MOVS     r0,#0x38
000104  f8ad0000          STRH     r0,[sp,#0]
;;;278      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; 
000108  f88d4002          STRB     r4,[sp,#2]
;;;279      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   //复用推挽输出
00010c  f88d6003          STRB     r6,[sp,#3]
;;;280      	GPIO_Init(GPIOB,&GPIO_InitStructure); 
000110  4669              MOV      r1,sp
000112  484d              LDR      r0,|L5.584|
000114  f7fffffe          BL       GPIO_Init
;;;281    
;;;282    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;  //AT45DB161片选
000118  f8ad8000          STRH     r8,[sp,#0]
;;;283    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  
00011c  f88d7003          STRB     r7,[sp,#3]
;;;284    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000120  4669              MOV      r1,sp
000122  484b              LDR      r0,|L5.592|
000124  f7fffffe          BL       GPIO_Init
;;;285        #endif
;;;286    
;;;287    	/***********    蜂鸣器    *******************/
;;;288    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; 
000128  f04f0801          MOV      r8,#1
00012c  f88d8002          STRB     r8,[sp,#2]
;;;289    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2; 
000130  f8ad5000          STRH     r5,[sp,#0]
;;;290    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;  
000134  f88d7003          STRB     r7,[sp,#3]
;;;291    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000138  4669              MOV      r1,sp
00013a  4845              LDR      r0,|L5.592|
00013c  f7fffffe          BL       GPIO_Init
;;;292    	 
;;;293    	/*********　　IIC1	***********/
;;;294    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_10MHz; 
000140  f88d8002          STRB     r8,[sp,#2]
;;;295    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7|GPIO_Pin_4; 
000144  f04f0ad0          MOV      r10,#0xd0
000148  f8ada000          STRH     r10,[sp,#0]
;;;296    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;  
00014c  2014              MOVS     r0,#0x14
00014e  f88d0003          STRB     r0,[sp,#3]
;;;297    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000152  4669              MOV      r1,sp
000154  483c              LDR      r0,|L5.584|
000156  f7fffffe          BL       GPIO_Init
;;;298    
;;;299    	/*********   SD卡  *********************/
;;;300    	     //在sdcard.c 文件中
;;;301    		 	 
;;;302        /****** TFT **********/
;;;303    #if 0		
;;;304    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
;;;305                                    GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 | 
;;;306                                    GPIO_Pin_15;
;;;307      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;308      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;309      	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;310    
;;;311      	/* Set PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;312         PE.14(D11), PE.15(D12) as alternate function push pull */
;;;313      	GPIO_InitStructure.GPIO_Pin =  /*GPIO_Pin_6 |*/ GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | 
;;;314                                    GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | 
;;;315                                    GPIO_Pin_15;
;;;316      	GPIO_Init(GPIOE, &GPIO_InitStructure);
;;;317    
;;;318     	// GPIO_WriteBit(GPIOE, GPIO_Pin_6, Bit_SET);
;;;319      	/* Set PF.00(A0 (RS)) as alternate function push pull */
;;;320      	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
;;;321      	//GPIO_Init(GPIOF, &GPIO_InitStructure);
;;;322      
;;;323      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;
;;;324      	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;325    
;;;326      	/* Set PG.12(NE4 (LCD/CS)) as alternate function push pull - CE3(LCD /CS) */
;;;327      	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;328      	//GPIO_Init(GPIOG, &GPIO_InitStructure);
;;;329      
;;;330        /* Set (NE1 (LCD/CS)) as alternate function push pull - CE3(LCD /CS) */
;;;331      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7;
;;;332      	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;333      
;;;334      	//reset 
;;;335      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;336    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8;  //RS485方向选择
;;;337    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;  
;;;338    	GPIO_Init(GPIOA, &GPIO_InitStructure);
;;;339    	TimeDelay(10);
;;;340    	GPIO_ResetBits(GPIOA, GPIO_Pin_8);    
;;;341    	TimeDelay(10);
;;;342    	GPIO_SetBits(GPIOA, GPIO_Pin_8); 
;;;343    #endif
;;;344    
;;;345       // AD5410 CS
;;;346    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
00015a  2020              MOVS     r0,#0x20
00015c  f8ad0000          STRH     r0,[sp,#0]
;;;347    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000160  f88d4002          STRB     r4,[sp,#2]
;;;348    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 
000164  f88d7003          STRB     r7,[sp,#3]
;;;349    	GPIO_Init(GPIOC, &GPIO_InitStructure);
000168  4669              MOV      r1,sp
00016a  4835              LDR      r0,|L5.576|
00016c  f7fffffe          BL       GPIO_Init
;;;350    
;;;351    	/**************TFT  数据地址片选   背光 TIM2等  **************/
;;;352    	     /*===GPIO For the LCD_Bus======*/	
;;;353        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000170  f24c7003          MOV      r0,#0xc703
000174  f8ad0000          STRH     r0,[sp,#0]
;;;354      								GPIO_Pin_14 | GPIO_Pin_15;
;;;355      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000178  f88d4002          STRB     r4,[sp,#2]
;;;356      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00017c  f88d6003          STRB     r6,[sp,#3]
;;;357      	GPIO_Init(GPIOD, &GPIO_InitStructure);
000180  4669              MOV      r1,sp
000182  4830              LDR      r0,|L5.580|
000184  f7fffffe          BL       GPIO_Init
;;;358    
;;;359      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7  | GPIO_Pin_8  | GPIO_Pin_9  | GPIO_Pin_10 | GPIO_Pin_11 |
000188  f64f7080          MOV      r0,#0xff80
00018c  f8ad0000          STRH     r0,[sp,#0]
;;;360      								  GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 | GPIO_Pin_15;
;;;361      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000190  f88d4002          STRB     r4,[sp,#2]
;;;362      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000194  f88d6003          STRB     r6,[sp,#3]
;;;363      	GPIO_Init(GPIOE, &GPIO_InitStructure);
000198  4669              MOV      r1,sp
00019a  482d              LDR      r0,|L5.592|
00019c  f7fffffe          BL       GPIO_Init
;;;364    
;;;365    	/*===========GPIO For the Control========================*/
;;;366    	/**	
;;;367     	*	PA0 -> Light  --可以pwm调光
;;;368     	*	PD4	-> OE	,	PD5	-> WE 
;;;369     	*	PD7	-> CS/NE1	,	PD13 -> RS 
;;;370     	*/	
;;;371      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
0001a0  f8ad8000          STRH     r8,[sp,#0]
;;;372      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001a4  f88d4002          STRB     r4,[sp,#2]
;;;373      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
0001a8  f88d7003          STRB     r7,[sp,#3]
;;;374      	GPIO_Init(GPIOA, &GPIO_InitStructure);
0001ac  4669              MOV      r1,sp
0001ae  4823              LDR      r0,|L5.572|
0001b0  f7fffffe          BL       GPIO_Init
;;;375    
;;;376      	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5 | GPIO_Pin_7 | GPIO_Pin_13;
0001b4  f24200b0          MOV      r0,#0x20b0
0001b8  f8ad0000          STRH     r0,[sp,#0]
;;;377      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001bc  f88d4002          STRB     r4,[sp,#2]
;;;378      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP; 	 
0001c0  f88d6003          STRB     r6,[sp,#3]
;;;379      	GPIO_Init(GPIOD, &GPIO_InitStructure); 
0001c4  4669              MOV      r1,sp
0001c6  481f              LDR      r0,|L5.580|
0001c8  f7fffffe          BL       GPIO_Init
;;;380        delay_asm(10);
0001cc  200a              MOVS     r0,#0xa
0001ce  f7fffffe          BL       delay_asm
;;;381    	GPIO_ResetBits(GPIOA, GPIO_Pin_8);    //ssd1963复位
0001d2  4659              MOV      r1,r11
0001d4  4819              LDR      r0,|L5.572|
0001d6  f7fffffe          BL       GPIO_ResetBits
;;;382    	delay_asm(10);
0001da  200a              MOVS     r0,#0xa
0001dc  f7fffffe          BL       delay_asm
;;;383    	GPIO_SetBits(GPIOA, GPIO_Pin_8); 
0001e0  4659              MOV      r1,r11
0001e2  4816              LDR      r0,|L5.572|
0001e4  f7fffffe          BL       GPIO_SetBits
;;;384    	
;;;385        GPIO_ResetBits(GPIOA, GPIO_Pin_0);    //打开背光LED
0001e8  2101              MOVS     r1,#1
0001ea  4814              LDR      r0,|L5.572|
0001ec  f7fffffe          BL       GPIO_ResetBits
;;;386    	GPIO_SetBits(GPIOA, GPIO_Pin_0);    //打开背光LED
0001f0  2101              MOVS     r1,#1
0001f2  4812              LDR      r0,|L5.572|
0001f4  f7fffffe          BL       GPIO_SetBits
;;;387    
;;;388    
;;;389    	//RTC
;;;390    	//PWM
;;;391    	
;;;392    	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 |GPIO_Pin_7;
;;;393    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_8 |GPIO_Pin_9;
0001f8  0220              LSLS     r0,r4,#8
0001fa  f8ad0000          STRH     r0,[sp,#0]
;;;394      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0001fe  f88d4002          STRB     r4,[sp,#2]
;;;395      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
000202  f88d5003          STRB     r5,[sp,#3]
;;;396      	GPIO_Init(GPIOB, &GPIO_InitStructure);
000206  4669              MOV      r1,sp
000208  480f              LDR      r0,|L5.584|
00020a  f7fffffe          BL       GPIO_Init
;;;397    	
;;;398    	/***其他输入引脚***/
;;;399    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 |GPIO_Pin_5 |GPIO_Pin_6;		 //SW3_IN SW1_IN SW2_IN
00020e  2070              MOVS     r0,#0x70
000210  f8ad0000          STRH     r0,[sp,#0]
;;;400      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000214  f88d4002          STRB     r4,[sp,#2]
;;;401      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
000218  f88d5003          STRB     r5,[sp,#3]
;;;402      	GPIO_Init(GPIOE, &GPIO_InitStructure);	
00021c  4669              MOV      r1,sp
00021e  480c              LDR      r0,|L5.592|
000220  f7fffffe          BL       GPIO_Init
;;;403    	
;;;404    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6|GPIO_Pin_7|GPIO_Pin_4;		 //TIM3_CH1,TIM3_CH2
000224  f8ada000          STRH     r10,[sp,#0]
;;;405      	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_2MHz;
000228  f88d9002          STRB     r9,[sp,#2]
;;;406      	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING; 	 
00022c  f88d5003          STRB     r5,[sp,#3]
;;;407      	GPIO_Init(GPIOC, &GPIO_InitStructure);
000230  4669              MOV      r1,sp
000232  4803              LDR      r0,|L5.576|
000234  f7fffffe          BL       GPIO_Init
;;;408    	
;;;409    }
000238  e8bd8ff8          POP      {r3-r11,pc}
;;;410    
                          ENDP

                  |L5.572|
                          DCD      0x40010800
                  |L5.576|
                          DCD      0x40011000
                  |L5.580|
                          DCD      0x40011400
                  |L5.584|
                          DCD      0x40010c00
                  |L5.588|
                          DCD      0x00300200
                  |L5.592|
                          DCD      0x40011800

                          AREA ||i.IIC_Config||, CODE, READONLY, ALIGN=1

                  IIC_Config PROC
;;;533    
;;;534    void IIC_Config(void)
000000  4770              BX       lr
;;;535    {
;;;536    
;;;537    }
;;;538    
                          ENDP


                          AREA ||i.MMA845X_TIM6_Init||, CODE, READONLY, ALIGN=2

                  MMA845X_TIM6_Init PROC
;;;672    
;;;673    void  MMA845X_TIM6_Init(void)
000000  b53e              PUSH     {r1-r5,lr}
;;;674    {
;;;675        TIM_TimeBaseInitTypeDef  tim_init;
;;;676    
;;;677        RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM6, ENABLE);	  //TIM2 --36MHZ  -- 72MHZ
000002  2101              MOVS     r1,#1
000004  2010              MOVS     r0,#0x10
000006  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;678        tim_init.TIM_Period        = 1000 - 1;			  // 800HZ
00000a  f24030e7          MOV      r0,#0x3e7
00000e  f8ad0004          STRH     r0,[sp,#4]
;;;679        tim_init.TIM_Prescaler     = 90 -1;	   //36M/45 = 0.8M
000012  2059              MOVS     r0,#0x59
000014  f8ad0000          STRH     r0,[sp,#0]
;;;680        tim_init.TIM_ClockDivision = 0x0;
000018  2000              MOVS     r0,#0
;;;681        tim_init.TIM_CounterMode   = TIM_CounterMode_Up;
;;;682    
;;;683        TIM_TimeBaseInit(TIM6, &tim_init);
00001a  4c0b              LDR      r4,|L7.72|
00001c  f8ad0006          STRH     r0,[sp,#6]            ;680
000020  f8ad0002          STRH     r0,[sp,#2]            ;681
000024  4669              MOV      r1,sp
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       TIM_TimeBaseInit
;;;684        TIM_SetCounter(TIM6, 0);
00002c  2100              MOVS     r1,#0
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       TIM_SetCounter
;;;685        TIM_ITConfig(TIM6, TIM_IT_Update, ENABLE);
000034  2201              MOVS     r2,#1
000036  4611              MOV      r1,r2
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       TIM_ITConfig
;;;686    	TIM_Cmd(TIM6, ENABLE);
00003e  2101              MOVS     r1,#1
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       TIM_Cmd
;;;687    }
000046  bd3e              POP      {r1-r5,pc}
;;;688    
                          ENDP

                  |L7.72|
                          DCD      0x40001000

                          AREA ||i.MMA845X_TIM6_interrupt_conf||, CODE, READONLY, ALIGN=2

                  MMA845X_TIM6_interrupt_conf PROC
;;;688    
;;;689    void MMA845X_TIM6_interrupt_conf(FunctionalState status)
000000  4602              MOV      r2,r0
;;;690    {
;;;691    	TIM_ITConfig(TIM6, TIM_IT_Update, status);
000002  2101              MOVS     r1,#1
000004  4801              LDR      r0,|L8.12|
000006  f7ffbffe          B.W      TIM_ITConfig
;;;692    }
;;;693    
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      0x40001000

                          AREA ||i.NVIC_Configuration||, CODE, READONLY, ALIGN=2

                  NVIC_Configuration PROC
;;;547    
;;;548    void NVIC_Configuration(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;549    {
;;;550    	NVIC_InitTypeDef NVIC_InitStructure;
;;;551      	int i;
;;;552      	static const uint8_t NVIC_IntSet[] = 
;;;553      	{
;;;554    	  SDIO_IRQn,        1, 1
;;;555        };
;;;556    
;;;557    	/* 优先组3, 从Preemption = 0 ~ 7   subpriority = 0 ~ 1 */
;;;558    	NVIC_PriorityGroupConfig(NVIC_PriorityGroup_3);
000002  f44f6080          MOV      r0,#0x400
000006  f7fffffe          BL       NVIC_PriorityGroupConfig
;;;559      
;;;560    	for (i = 0; i < sizeof(NVIC_IntSet); i += 3) 
00000a  2400              MOVS     r4,#0
;;;561    	{
;;;562    		NVIC_InitStructure.NVIC_IRQChannel = NVIC_IntSet[i];
00000c  4d0a              LDR      r5,|L9.56|
;;;563    		NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = NVIC_IntSet[i + 1];
;;;564           	NVIC_InitStructure.NVIC_IRQChannelSubPriority = NVIC_IntSet[i + 2];
;;;565          	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00000e  2601              MOVS     r6,#1
                  |L9.16|
000010  5d28              LDRB     r0,[r5,r4]            ;562
000012  f88d0000          STRB     r0,[sp,#0]            ;562
000016  1928              ADDS     r0,r5,r4              ;563
000018  7841              LDRB     r1,[r0,#1]            ;563
00001a  f88d1001          STRB     r1,[sp,#1]            ;563
00001e  7880              LDRB     r0,[r0,#2]            ;564
000020  f88d0002          STRB     r0,[sp,#2]            ;564
000024  f88d6003          STRB     r6,[sp,#3]
;;;566          	NVIC_Init(&NVIC_InitStructure);
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       NVIC_Init
00002e  1ce4              ADDS     r4,r4,#3              ;560
000030  2c03              CMP      r4,#3                 ;560
000032  d3ed              BCC      |L9.16|
;;;567      	}	  
;;;568    
;;;569    }
000034  bdf8              POP      {r3-r7,pc}
;;;570    
                          ENDP

000036  0000              DCW      0x0000
                  |L9.56|
                          DCD      ||.constdata||

                          AREA ||i.OS_CPU_SysTickClkFreq||, CODE, READONLY, ALIGN=1

                  OS_CPU_SysTickClkFreq PROC
;;;571    
;;;572    INT32U  OS_CPU_SysTickClkFreq (void)
000000  b500              PUSH     {lr}
;;;573    {	 
000002  b085              SUB      sp,sp,#0x14
;;;574    	RCC_ClocksTypeDef  rcc_clocks;
;;;575    
;;;576        RCC_GetClocksFreq(&rcc_clocks);
000004  4668              MOV      r0,sp
000006  f7fffffe          BL       RCC_GetClocksFreq
;;;577    
;;;578        return ((INT32U)rcc_clocks.HCLK_Frequency);
00000a  9801              LDR      r0,[sp,#4]
;;;579    }
00000c  b005              ADD      sp,sp,#0x14
00000e  bd00              POP      {pc}
;;;580    
                          ENDP


                          AREA ||i.RCC_Config||, CODE, READONLY, ALIGN=1

                  RCC_Config PROC
;;;183    
;;;184    void RCC_Config(void)
000000  b510              PUSH     {r4,lr}
;;;185    {
;;;186    	 /* Enable GPIOA, GPIOB, GPIOC, GPIOD, GPIOE, GPIOF, GPIOG and AFIO clocks */
;;;187    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOB |RCC_APB2Periph_GPIOC 
000002  2101              MOVS     r1,#1
000004  207d              MOVS     r0,#0x7d
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;188                           | RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE  | RCC_APB2Periph_AFIO, ENABLE);
;;;189    
;;;190    	RCC_APB2PeriphClockCmd( RCC_APB2Periph_USART1,ENABLE); //串口1
00000a  2101              MOVS     r1,#1
00000c  038c              LSLS     r4,r1,#14
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;191    	RCC_APB1PeriphClockCmd( RCC_APB1Periph_USART2,ENABLE); //串口2
000014  2101              MOVS     r1,#1
000016  0448              LSLS     r0,r1,#17
000018  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;192    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1,   ENABLE); //SPI1----触摸板
00001c  2101              MOVS     r1,#1
00001e  0308              LSLS     r0,r1,#12
000020  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;193    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2,   ENABLE); //SPI2----网络
000024  2101              MOVS     r1,#1
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;194    	#ifndef RED_BULL  //红牛开发板
;;;195    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI3,   ENABLE); //SPI3----spi接口flash AT45DB161D
00002c  2101              MOVS     r1,#1
00002e  03c8              LSLS     r0,r1,#15
000030  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;196        #endif
;;;197    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);	   //lcd
000034  2101              MOVS     r1,#1
000036  0208              LSLS     r0,r1,#8
000038  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;198    
;;;199    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4,   ENABLE);	 //TIM4 
00003c  2101              MOVS     r1,#1
00003e  e8bd4010          POP      {r4,lr}
000042  2004              MOVS     r0,#4
000044  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;200    }
;;;201    
                          ENDP


                          AREA ||i.SPI_Config||, CODE, READONLY, ALIGN=2

                  SPI_Config PROC
;;;446    
;;;447    void SPI_Config(void)
000000  b530              PUSH     {r4,r5,lr}
;;;448    {
000002  b085              SUB      sp,sp,#0x14
;;;449    	SPI_InitTypeDef   SPI_InitStructure;
;;;450    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex; 
000004  2400              MOVS     r4,#0
000006  f8ad4000          STRH     r4,[sp,#0]
;;;451      	SPI_InitStructure.SPI_Mode = SPI_Mode_Master; 
00000a  f44f7082          MOV      r0,#0x104
00000e  f8ad0002          STRH     r0,[sp,#2]
;;;452      	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b; 
;;;453      	SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low; 
;;;454      	SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge; 
000012  f8ad4008          STRH     r4,[sp,#8]
;;;455     	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;   
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad000a          STRH     r0,[sp,#0xa]
;;;456      	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64; 
00001e  2028              MOVS     r0,#0x28
000020  f8ad000c          STRH     r0,[sp,#0xc]
;;;457      	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB; 
;;;458        SPI_InitStructure.SPI_CRCPolynomial = 7; 
000024  2007              MOVS     r0,#7
;;;459    
;;;460    	#ifdef RED_BULL  //红牛开发板
;;;461    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; 		//36Mhz
;;;462    	#endif
;;;463        SPI_Init(SPI1,&SPI_InitStructure); 
000026  4d13              LDR      r5,|L12.116|
000028  f8ad4004          STRH     r4,[sp,#4]            ;452
00002c  f8ad0010          STRH     r0,[sp,#0x10]         ;458
000030  f8ad4006          STRH     r4,[sp,#6]            ;453
000034  f8ad400e          STRH     r4,[sp,#0xe]          ;457
000038  4669              MOV      r1,sp
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       SPI_Init
;;;464    	
;;;465    	SPI_Cmd(SPI1, ENABLE);//触摸板
000040  2101              MOVS     r1,#1
000042  4628              MOV      r0,r5
000044  f7fffffe          BL       SPI_Cmd
;;;466    
;;;467    	SPI_Init(SPI2,&SPI_InitStructure);
000048  4d0b              LDR      r5,|L12.120|
00004a  4669              MOV      r1,sp
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       SPI_Init
;;;468    	SPI_Cmd(SPI2, ENABLE);	//网口，配置待定
000052  2101              MOVS     r1,#1
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       SPI_Cmd
;;;469    
;;;470        #ifndef RED_BULL  //红牛开发板
;;;471    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2; 
00005a  f8ad400c          STRH     r4,[sp,#0xc]
;;;472    	SPI_Init(SPI3,&SPI_InitStructure); 
00005e  4c07              LDR      r4,|L12.124|
000060  4669              MOV      r1,sp
000062  4620              MOV      r0,r4
000064  f7fffffe          BL       SPI_Init
;;;473      	SPI_Cmd(SPI3,ENABLE); 	//at45db161d
000068  2101              MOVS     r1,#1
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       SPI_Cmd
;;;474    	#endif
;;;475    }
000070  b005              ADD      sp,sp,#0x14
000072  bd30              POP      {r4,r5,pc}
;;;476    
                          ENDP

                  |L12.116|
                          DCD      0x40013000
                  |L12.120|
                          DCD      0x40003800
                  |L12.124|
                          DCD      0x40003c00

                          AREA ||i.TIM3_Encoder_Init||, CODE, READONLY, ALIGN=1

                  TIM3_Encoder_Init PROC
;;;503    
;;;504    void TIM3_Encoder_Init(void)
000000  4770              BX       lr
;;;505    {
;;;506    /*
;;;507        TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;508    	TIM_ICInitTypeDef TIM_ICInitStructure;
;;;509    
;;;510    
;;;511    	TIM_TimeBaseStructure.TIM_Prescaler = 0x0; // No prescaling 
;;;512    	TIM_TimeBaseStructure.TIM_Period = 10000; //	 max=65536
;;;513    	TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;
;;;514    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;   
;;;515    	TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
;;;516    
;;;517    	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, 
;;;518                                 TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);
;;;519    	TIM_ICStructInit(&TIM_ICInitStructure);
;;;520    	TIM_ICInitStructure.TIM_ICFilter = 6;//ICx_FILTER;
;;;521    	TIM_ICInit(TIM8, &TIM_ICInitStructure);
;;;522    
;;;523    	// Clear all pending interrupts
;;;524    	TIM_ClearFlag(TIM4, TIM_FLAG_Update);
;;;525    	TIM_ITConfig(TIM4, TIM_IT_Update, ENABLE);
;;;526    	//Reset counter
;;;527    	TIM4->CNT = 0;
;;;528    
;;;529    	TIM_Cmd(TIM4, ENABLE); 	
;;;530    	*/
;;;531    }
;;;532    
                          ENDP


                          AREA ||i.UART_Config||, CODE, READONLY, ALIGN=2

                  UART_Config PROC
;;;476    
;;;477    void UART_Config(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;478    {
;;;479    	USART_InitTypeDef USART_InitStructure;
;;;480    
;;;481        USART_InitStructure.USART_BaudRate = 9600;
000002  f44f5016          MOV      r0,#0x2580
;;;482    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000006  9000              STR      r0,[sp,#0]
000008  2000              MOVS     r0,#0
00000a  f8ad0004          STRH     r0,[sp,#4]
;;;483    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
00000e  f8ad0006          STRH     r0,[sp,#6]
;;;484    	USART_InitStructure.USART_Parity = USART_Parity_No;
000012  f8ad0008          STRH     r0,[sp,#8]
;;;485    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
000016  f8ad000c          STRH     r0,[sp,#0xc]
;;;486    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
00001a  200c              MOVS     r0,#0xc
;;;487    	USART_Init(USART1, &USART_InitStructure); 
00001c  4c11              LDR      r4,|L14.100|
00001e  f8ad000a          STRH     r0,[sp,#0xa]          ;486
000022  4669              MOV      r1,sp
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       USART_Init
;;;488    
;;;489    //  USART_ClearITPendingBit(USART1,USART_FLAG_TC);
;;;490    //	USART_ClearFlag(USART1,USART_FLAG_TC);
;;;491    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);
00002a  2201              MOVS     r2,#1
00002c  f2405125          MOV      r1,#0x525
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       USART_ITConfig
;;;492    	USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
000036  2201              MOVS     r2,#1
000038  f2407127          MOV      r1,#0x727
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       USART_ITConfig
;;;493    
;;;494    	USART_Cmd(USART1, ENABLE);
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       USART_Cmd
;;;495    
;;;496    	USART_InitStructure.USART_BaudRate = 115200;
00004a  f44f34e1          MOV      r4,#0x1c200
;;;497    	USART_Cmd(USART2, ENABLE);
00004e  2101              MOVS     r1,#1
000050  4805              LDR      r0,|L14.104|
000052  9400              STR      r4,[sp,#0]
000054  f7fffffe          BL       USART_Cmd
;;;498    
;;;499    	USART_InitStructure.USART_BaudRate = 115200;
;;;500    	USART_Cmd(USART3, ENABLE);
000058  2101              MOVS     r1,#1
00005a  4804              LDR      r0,|L14.108|
00005c  9400              STR      r4,[sp,#0]
00005e  f7fffffe          BL       USART_Cmd
;;;501    }
000062  bd1f              POP      {r0-r4,pc}
;;;502    
                          ENDP

                  |L14.100|
                          DCD      0x40013800
                  |L14.104|
                          DCD      0x40004400
                  |L14.108|
                          DCD      0x40004800

                          AREA ||i.flash_pro||, CODE, READONLY, ALIGN=2

                  flash_pro PROC
;;;637    
;;;638    FLASH_Status flash_pro(uint32_t start_address, uint16_t* data,unsigned int lenth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;639    {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4690              MOV      r8,r2
;;;640      unsigned int i;
;;;641      FLASH_Status  flash_status;
;;;642      
;;;643      #ifdef STM32F10X_XL
;;;644      FLASH_UnlockBank2();
00000a  f7fffffe          BL       FLASH_UnlockBank2
;;;645      #endif
;;;646    
;;;647      #ifdef STM32F10X_HD
;;;648      FLASH_UnlockBank1();
;;;649      #endif
;;;650    
;;;651      flash_status = FLASH_ErasePage(BANK511_WRITE_START_ADDR );
00000e  480c              LDR      r0,|L15.64|
000010  f7fffffe          BL       FLASH_ErasePage
000014  4605              MOV      r5,r0
;;;652      if( flash_status != FLASH_COMPLETE)
000016  2804              CMP      r0,#4
000018  d110              BNE      |L15.60|
;;;653      return flash_status;
;;;654    
;;;655      for(i=0;i<lenth;i++)
00001a  2400              MOVS     r4,#0
00001c  e009              B        |L15.50|
                  |L15.30|
;;;656      {
;;;657      flash_status = FLASH_ProgramHalfWord(start_address+i*2, data[i]);
00001e  f8371014          LDRH     r1,[r7,r4,LSL #1]
000022  eb060044          ADD      r0,r6,r4,LSL #1
000026  f7fffffe          BL       FLASH_ProgramHalfWord
00002a  4605              MOV      r5,r0
;;;658      if( flash_status != FLASH_COMPLETE)
00002c  2804              CMP      r0,#4
00002e  d105              BNE      |L15.60|
000030  1c64              ADDS     r4,r4,#1              ;655
                  |L15.50|
000032  4544              CMP      r4,r8                 ;655
000034  d3f3              BCC      |L15.30|
;;;659      return flash_status;
;;;660      }
;;;661    
;;;662      #ifdef STM32F10X_XL
;;;663      FLASH_LockBank2();
000036  f7fffffe          BL       FLASH_LockBank2
;;;664      #endif
;;;665    
;;;666      #ifdef STM32F10X_HD
;;;667      FLASH_LockBank1();
;;;668      #endif
;;;669    
;;;670      return flash_status;
00003a  4628              MOV      r0,r5
                  |L15.60|
;;;671    }
00003c  e8bd81f0          POP      {r4-r8,pc}
;;;672    
                          ENDP

                  |L15.64|
                          DCD      0x080ff800

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  NVIC_IntSet
000000  310101            DCB      0x31,0x01,0x01

;*** Start embedded assembler ***

#line 1 "Source\\BSP\\bsp.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_bsp_c_BSP_Init____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_bsp_c_BSP_Init____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___5_bsp_c_BSP_Init____REVSH|
#line 128
|__asm___5_bsp_c_BSP_Init____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |delay_asm|
#line 153 "Source\\BSP\\bsp.c"
|delay_asm| PROC
#line 154

 subs R0, #1
 BNE delay_asm
 BX LR
	ENDP

;*** End   embedded assembler ***
