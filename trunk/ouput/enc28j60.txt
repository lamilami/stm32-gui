; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\enc28j60.o --depend=.\ouput\enc28j60.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\enc28j60.crf Source\Net\enc28j60.c]
                          THUMB

                          AREA ||i.enc28j60Init||, CODE, READONLY, ALIGN=2

                  enc28j60Init PROC
;;;135    
;;;136    void enc28j60Init(unsigned char* macaddr)
000000  b510              PUSH     {r4,lr}
;;;137    {   
;;;138        ENC28J60_CSH();	      
000002  494e              LDR      r1,|L1.316|
000004  4604              MOV      r4,r0                 ;137
000006  f44f5080          MOV      r0,#0x1000
00000a  6008              STR      r0,[r1,#0]
;;;139    
;;;140        // perform system reset
;;;141        enc28j60WriteOp(ENC28J60_SOFT_RESET, 0, ENC28J60_SOFT_RESET);
00000c  f04f02ff          MOV      r2,#0xff
000010  f04f0100          MOV      r1,#0
000014  4610              MOV      r0,r2
000016  f7fffffe          BL       enc28j60WriteOp
;;;142       
;;;143        // check CLKRDY bit to see if reset is complete
;;;144        // The CLKRDY does not work. See Rev. B4 Silicon Errata point. Just wait.
;;;145        //while(!(enc28j60Read(ESTAT) & ESTAT_CLKRDY));
;;;146        // do bank 0 stuff
;;;147        // initialize receive buffer
;;;148        // 16-bit transfers, must write low byte first
;;;149        // set receive buffer start address	   
;;;150        NextPacketPtr = RXSTART_INIT;
00001a  4949              LDR      r1,|L1.320|
00001c  2000              MOVS     r0,#0
;;;151        // Rx start    
;;;152        enc28j60Write(ERXSTL, RXSTART_INIT&0xFF);	 
00001e  6048              STR      r0,[r1,#4]  ; NextPacketPtr
000020  4601              MOV      r1,r0
000022  2008              MOVS     r0,#8
000024  f7fffffe          BL       enc28j60Write
;;;153        enc28j60Write(ERXSTH, RXSTART_INIT>>8);
000028  2100              MOVS     r1,#0
00002a  2009              MOVS     r0,#9
00002c  f7fffffe          BL       enc28j60Write
;;;154        // set receive pointer address     
;;;155        enc28j60Write(ERXRDPTL, RXSTART_INIT&0xFF);
000030  2100              MOVS     r1,#0
000032  200c              MOVS     r0,#0xc
000034  f7fffffe          BL       enc28j60Write
;;;156        enc28j60Write(ERXRDPTH, RXSTART_INIT>>8);
000038  2100              MOVS     r1,#0
00003a  200d              MOVS     r0,#0xd
00003c  f7fffffe          BL       enc28j60Write
;;;157        // RX end
;;;158        enc28j60Write(ERXNDL, RXSTOP_INIT&0xFF);
000040  21fe              MOVS     r1,#0xfe
000042  200a              MOVS     r0,#0xa
000044  f7fffffe          BL       enc28j60Write
;;;159        enc28j60Write(ERXNDH, RXSTOP_INIT>>8);
000048  2119              MOVS     r1,#0x19
00004a  200b              MOVS     r0,#0xb
00004c  f7fffffe          BL       enc28j60Write
;;;160        // TX start	  1500
;;;161        enc28j60Write(ETXSTL, TXSTART_INIT&0xFF);
000050  21ff              MOVS     r1,#0xff
000052  2004              MOVS     r0,#4
000054  f7fffffe          BL       enc28j60Write
;;;162        enc28j60Write(ETXSTH, TXSTART_INIT>>8);
000058  2119              MOVS     r1,#0x19
00005a  2005              MOVS     r0,#5
00005c  f7fffffe          BL       enc28j60Write
;;;163        // TX end
;;;164        enc28j60Write(ETXNDL, TXSTOP_INIT&0xFF);
000060  21ff              MOVS     r1,#0xff
000062  2006              MOVS     r0,#6
000064  f7fffffe          BL       enc28j60Write
;;;165        enc28j60Write(ETXNDH, TXSTOP_INIT>>8);
000068  211f              MOVS     r1,#0x1f
00006a  2007              MOVS     r0,#7
00006c  f7fffffe          BL       enc28j60Write
;;;166        // do bank 1 stuff, packet filter:
;;;167        // For broadcast packets we allow only ARP packtets
;;;168        // All other packets should be unicast only for our mac (MAADR)
;;;169        //
;;;170        // The pattern to match on is therefore
;;;171        // Type     ETH.DST
;;;172        // ARP      BROADCAST
;;;173        // 06 08 -- ff ff ff ff ff ff -> ip checksum for theses bytes=f7f9
;;;174        // in binary these poitions are:11 0000 0011 1111
;;;175        // This is hex 303F->EPMM0=0x3f,EPMM1=0x30
;;;176        
;;;177        enc28j60Write(ERXFCON, ERXFCON_UCEN|ERXFCON_CRCEN|ERXFCON_PMEN);
000070  21b0              MOVS     r1,#0xb0
000072  2038              MOVS     r0,#0x38
000074  f7fffffe          BL       enc28j60Write
;;;178        enc28j60Write(EPMM0, 0x3f);
000078  213f              MOVS     r1,#0x3f
00007a  2028              MOVS     r0,#0x28
00007c  f7fffffe          BL       enc28j60Write
;;;179        enc28j60Write(EPMM1, 0x30);
000080  2130              MOVS     r1,#0x30
000082  2029              MOVS     r0,#0x29
000084  f7fffffe          BL       enc28j60Write
;;;180        enc28j60Write(EPMCSL, 0xf9);
000088  21f9              MOVS     r1,#0xf9
00008a  2030              MOVS     r0,#0x30
00008c  f7fffffe          BL       enc28j60Write
;;;181        enc28j60Write(EPMCSH, 0xf7);    
000090  21f7              MOVS     r1,#0xf7
000092  2031              MOVS     r0,#0x31
000094  f7fffffe          BL       enc28j60Write
;;;182        enc28j60Write(MACON1, MACON1_MARXEN|MACON1_TXPAUS|MACON1_RXPAUS);
000098  210d              MOVS     r1,#0xd
00009a  20c0              MOVS     r0,#0xc0
00009c  f7fffffe          BL       enc28j60Write
;;;183        // bring MAC out of reset 
;;;184        enc28j60Write(MACON2, 0x00);
0000a0  2100              MOVS     r1,#0
0000a2  20c1              MOVS     r0,#0xc1
0000a4  f7fffffe          BL       enc28j60Write
;;;185        
;;;186        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, MACON3, MACON3_PADCFG0|MACON3_TXCRCEN|MACON3_FRMLNEN|MACON3_FULDPX);
0000a8  2233              MOVS     r2,#0x33
0000aa  21c2              MOVS     r1,#0xc2
0000ac  2080              MOVS     r0,#0x80
0000ae  f7fffffe          BL       enc28j60WriteOp
;;;187        // set inter-frame gap (non-back-to-back)
;;;188    
;;;189        enc28j60Write(MAIPGL, 0x12);
0000b2  2112              MOVS     r1,#0x12
0000b4  20c6              MOVS     r0,#0xc6
0000b6  f7fffffe          BL       enc28j60Write
;;;190        enc28j60Write(MAIPGH, 0x0C);
0000ba  210c              MOVS     r1,#0xc
0000bc  20c7              MOVS     r0,#0xc7
0000be  f7fffffe          BL       enc28j60Write
;;;191        // set inter-frame gap (back-to-back)
;;;192    
;;;193        enc28j60Write(MABBIPG, 0x15);
0000c2  2115              MOVS     r1,#0x15
0000c4  20c4              MOVS     r0,#0xc4
0000c6  f7fffffe          BL       enc28j60Write
;;;194        // Set the maximum packet size which the controller will accept
;;;195        // Do not send packets longer than MAX_FRAMELEN:
;;;196      
;;;197        enc28j60Write(MAMXFLL, MAX_FRAMELEN&0xFF);	
0000ca  21dc              MOVS     r1,#0xdc
0000cc  20ca              MOVS     r0,#0xca
0000ce  f7fffffe          BL       enc28j60Write
;;;198        enc28j60Write(MAMXFLH, MAX_FRAMELEN>>8);
0000d2  2105              MOVS     r1,#5
0000d4  20cb              MOVS     r0,#0xcb
0000d6  f7fffffe          BL       enc28j60Write
;;;199        // do bank 3 stuff
;;;200        // write MAC address
;;;201        // NOTE: MAC address in ENC28J60 is byte-backward
;;;202        enc28j60Write(MAADR5, macaddr[0]);	
0000da  7821              LDRB     r1,[r4,#0]
0000dc  20e4              MOVS     r0,#0xe4
0000de  f7fffffe          BL       enc28j60Write
;;;203        enc28j60Write(MAADR4, macaddr[1]);
0000e2  7861              LDRB     r1,[r4,#1]
0000e4  20e5              MOVS     r0,#0xe5
0000e6  f7fffffe          BL       enc28j60Write
;;;204        enc28j60Write(MAADR3, macaddr[2]);
0000ea  78a1              LDRB     r1,[r4,#2]
0000ec  20e2              MOVS     r0,#0xe2
0000ee  f7fffffe          BL       enc28j60Write
;;;205        enc28j60Write(MAADR2, macaddr[3]);
0000f2  78e1              LDRB     r1,[r4,#3]
0000f4  20e3              MOVS     r0,#0xe3
0000f6  f7fffffe          BL       enc28j60Write
;;;206        enc28j60Write(MAADR1, macaddr[4]);
0000fa  7921              LDRB     r1,[r4,#4]
0000fc  20e0              MOVS     r0,#0xe0
0000fe  f7fffffe          BL       enc28j60Write
;;;207        enc28j60Write(MAADR0, macaddr[5]);
000102  7961              LDRB     r1,[r4,#5]
000104  20e1              MOVS     r0,#0xe1
000106  f7fffffe          BL       enc28j60Write
;;;208    
;;;209        //配置PHY为全双工  LEDB为拉电流
;;;210        enc28j60PhyWrite(PHCON1, PHCON1_PDPXMD);    
00010a  f44f7480          MOV      r4,#0x100
00010e  4621              MOV      r1,r4
000110  2000              MOVS     r0,#0
000112  f7fffffe          BL       enc28j60PhyWrite
;;;211        
;;;212        // no loopback of transmitted frames
;;;213        enc28j60PhyWrite(PHCON2, PHCON2_HDLDIS);
000116  4621              MOV      r1,r4
000118  2010              MOVS     r0,#0x10
00011a  f7fffffe          BL       enc28j60PhyWrite
;;;214    
;;;215        // switch to bank 0    
;;;216        enc28j60SetBank(ECON1);
00011e  201f              MOVS     r0,#0x1f
000120  f7fffffe          BL       enc28j60SetBank
;;;217    
;;;218        // enable interrutps
;;;219        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, EIE, EIE_INTIE|EIE_PKTIE);
000124  22c0              MOVS     r2,#0xc0
000126  211b              MOVS     r1,#0x1b
000128  2080              MOVS     r0,#0x80
00012a  f7fffffe          BL       enc28j60WriteOp
;;;220    
;;;221        // enable packet reception
;;;222        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_RXEN);
00012e  2204              MOVS     r2,#4
000130  211f              MOVS     r1,#0x1f
000132  e8bd4010          POP      {r4,lr}
000136  2080              MOVS     r0,#0x80
000138  f7ffbffe          B.W      enc28j60WriteOp
;;;223    }
;;;224    
                          ENDP

                  |L1.316|
                          DCD      0x40010c10
                  |L1.320|
                          DCD      ||.data||

                          AREA ||i.enc28j60PacketReceive||, CODE, READONLY, ALIGN=2

                  enc28j60PacketReceive PROC
;;;264    // Returns: Packet length in bytes if a packet was retrieved, zero otherwise.
;;;265    unsigned int enc28j60PacketReceive(unsigned int maxlen, unsigned char* packet)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;266    {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;267        unsigned int rxstat;
;;;268        unsigned int len;
;;;269        
;;;270        // check if a packet has been received and buffered
;;;271        //if( !(enc28j60Read(EIR) & EIR_PKTIF) ){
;;;272        // The above does not work. See Rev. B4 Silicon Errata point 6.
;;;273        if( enc28j60Read(EPKTCNT) ==0 )  //收到的以太网数据包长度
000008  2039              MOVS     r0,#0x39
00000a  f7fffffe          BL       enc28j60Read
00000e  2800              CMP      r0,#0
000010  d04c              BEQ      |L2.172|
;;;274        {
;;;275            return(0);
;;;276        }
;;;277        
;;;278        // Set the read pointer to the start of the received packet		 缓冲器读指针
;;;279        enc28j60Write(ERDPTL, (NextPacketPtr));
000012  4d27              LDR      r5,|L2.176|
000014  6868              LDR      r0,[r5,#4]  ; NextPacketPtr
000016  b2c1              UXTB     r1,r0
000018  2000              MOVS     r0,#0
00001a  f7fffffe          BL       enc28j60Write
;;;280        enc28j60Write(ERDPTH, (NextPacketPtr)>>8);
00001e  6868              LDR      r0,[r5,#4]  ; NextPacketPtr
000020  f3c02107          UBFX     r1,r0,#8,#8
000024  2001              MOVS     r0,#1
000026  f7fffffe          BL       enc28j60Write
;;;281        
;;;282        // read the next packet pointer
;;;283        NextPacketPtr  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
00002a  2100              MOVS     r1,#0
00002c  203a              MOVS     r0,#0x3a
00002e  f7fffffe          BL       enc28j60ReadOp
;;;284        NextPacketPtr |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
000032  6068              STR      r0,[r5,#4]  ; NextPacketPtr
000034  2100              MOVS     r1,#0
000036  203a              MOVS     r0,#0x3a
000038  f7fffffe          BL       enc28j60ReadOp
00003c  6869              LDR      r1,[r5,#4]  ; NextPacketPtr
00003e  ea412000          ORR      r0,r1,r0,LSL #8
;;;285        
;;;286        // read the packet length (see datasheet page 43)
;;;287        len  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
000042  6068              STR      r0,[r5,#4]  ; NextPacketPtr
000044  2100              MOVS     r1,#0
000046  203a              MOVS     r0,#0x3a
000048  f7fffffe          BL       enc28j60ReadOp
00004c  4604              MOV      r4,r0
;;;288        len |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
00004e  2100              MOVS     r1,#0
000050  203a              MOVS     r0,#0x3a
000052  f7fffffe          BL       enc28j60ReadOp
000056  ea442400          ORR      r4,r4,r0,LSL #8
;;;289        
;;;290        len-=4; //remove the CRC count
00005a  1f24              SUBS     r4,r4,#4
;;;291        // read the receive status (see datasheet page 43)
;;;292        rxstat  = enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0);
00005c  2100              MOVS     r1,#0
00005e  203a              MOVS     r0,#0x3a
000060  f7fffffe          BL       enc28j60ReadOp
000064  4607              MOV      r7,r0
;;;293        rxstat |= enc28j60ReadOp(ENC28J60_READ_BUF_MEM, 0)<<8;
000066  2100              MOVS     r1,#0
000068  203a              MOVS     r0,#0x3a
00006a  f7fffffe          BL       enc28j60ReadOp
;;;294        // limit retrieve length
;;;295        if (len>maxlen-1)
00006e  1e71              SUBS     r1,r6,#1
000070  ea472000          ORR      r0,r7,r0,LSL #8       ;293
000074  428c              CMP      r4,r1
000076  d900              BLS      |L2.122|
;;;296        {
;;;297            len=maxlen-1;
000078  460c              MOV      r4,r1
                  |L2.122|
;;;298        }
;;;299        
;;;300        // check CRC and symbol errors (see datasheet page 44, table 7-3):
;;;301        // The ERXFCON.CRCEN is set by default. Normally we should not
;;;302        // need to check this.
;;;303        if ((rxstat & 0x80)==0)
00007a  0600              LSLS     r0,r0,#24
00007c  d401              BMI      |L2.130|
;;;304        {
;;;305            // invalid
;;;306            len=0;
00007e  2400              MOVS     r4,#0
000080  e003              B        |L2.138|
                  |L2.130|
;;;307        }
;;;308        else
;;;309        {
;;;310            // copy the packet from the receive buffer
;;;311            enc28j60ReadBuffer(len, packet);
000082  4641              MOV      r1,r8
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       enc28j60ReadBuffer
                  |L2.138|
;;;312        }
;;;313        // Move the RX read pointer to the start of the next received packet
;;;314        // This frees the memory we just read out
;;;315        enc28j60Write(ERXRDPTL, (NextPacketPtr));
00008a  6868              LDR      r0,[r5,#4]  ; NextPacketPtr
00008c  b2c1              UXTB     r1,r0
00008e  200c              MOVS     r0,#0xc
000090  f7fffffe          BL       enc28j60Write
;;;316        enc28j60Write(ERXRDPTH, (NextPacketPtr)>>8);
000094  6868              LDR      r0,[r5,#4]  ; NextPacketPtr
000096  f3c02107          UBFX     r1,r0,#8,#8
00009a  200d              MOVS     r0,#0xd
00009c  f7fffffe          BL       enc28j60Write
;;;317        
;;;318        // decrement the packet counter indicate we are done with this packet
;;;319        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON2, ECON2_PKTDEC);
0000a0  2240              MOVS     r2,#0x40
0000a2  211e              MOVS     r1,#0x1e
0000a4  2080              MOVS     r0,#0x80
0000a6  f7fffffe          BL       enc28j60WriteOp
;;;320        return(len);
0000aa  4620              MOV      r0,r4
                  |L2.172|
;;;321    }
0000ac  e8bd81f0          POP      {r4-r8,pc}
;;;322    
                          ENDP

                  |L2.176|
                          DCD      ||.data||

                          AREA ||i.enc28j60PacketSend||, CODE, READONLY, ALIGN=1

                  enc28j60PacketSend PROC
;;;233    
;;;234    void enc28j60PacketSend(unsigned int len, unsigned char* packet)
000000  b570              PUSH     {r4-r6,lr}
;;;235    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;236        // Set the write pointer to start of transmit buffer area
;;;237        enc28j60Write(EWRPTL, TXSTART_INIT&0xFF);
000006  21ff              MOVS     r1,#0xff
000008  2002              MOVS     r0,#2
00000a  f7fffffe          BL       enc28j60Write
;;;238        enc28j60Write(EWRPTH, TXSTART_INIT>>8);
00000e  2119              MOVS     r1,#0x19
000010  2003              MOVS     r0,#3
000012  f7fffffe          BL       enc28j60Write
;;;239        
;;;240        // Set the TXND pointer to correspond to the packet size given
;;;241        enc28j60Write(ETXNDL, (TXSTART_INIT+len)&0xFF);
000016  f64110ff          MOV      r0,#0x19ff
00001a  182c              ADDS     r4,r5,r0
00001c  b2e1              UXTB     r1,r4
00001e  2006              MOVS     r0,#6
000020  f7fffffe          BL       enc28j60Write
;;;242        enc28j60Write(ETXNDH, (TXSTART_INIT+len)>>8);
000024  f3c42107          UBFX     r1,r4,#8,#8
000028  2007              MOVS     r0,#7
00002a  f7fffffe          BL       enc28j60Write
;;;243        
;;;244        // write per-packet control byte (0x00 means use macon3 settings)
;;;245        enc28j60WriteOp(ENC28J60_WRITE_BUF_MEM, 0, 0x00);
00002e  2200              MOVS     r2,#0
000030  4611              MOV      r1,r2
000032  207a              MOVS     r0,#0x7a
000034  f7fffffe          BL       enc28j60WriteOp
;;;246        
;;;247        // copy the packet into the transmit buffer
;;;248        enc28j60WriteBuffer(len, packet);
000038  4631              MOV      r1,r6
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       enc28j60WriteBuffer
;;;249        
;;;250        // send the contents of the transmit buffer onto the network
;;;251        enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, ECON1_TXRTS);
000040  2208              MOVS     r2,#8
000042  211f              MOVS     r1,#0x1f
000044  2080              MOVS     r0,#0x80
000046  f7fffffe          BL       enc28j60WriteOp
;;;252        
;;;253        // Reset the transmit logic problem. See Rev. B4 Silicon Errata point 12.
;;;254        if( (enc28j60Read(EIR) & EIR_TXERIF) )
00004a  201c              MOVS     r0,#0x1c
00004c  f7fffffe          BL       enc28j60Read
000050  0780              LSLS     r0,r0,#30
000052  d506              BPL      |L3.98|
;;;255        {
;;;256            enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, ECON1_TXRTS);
000054  e8bd4070          POP      {r4-r6,lr}
000058  2208              MOVS     r2,#8
00005a  211f              MOVS     r1,#0x1f
00005c  20a0              MOVS     r0,#0xa0
00005e  f7ffbffe          B.W      enc28j60WriteOp
                  |L3.98|
;;;257        }
;;;258    }
000062  bd70              POP      {r4-r6,pc}
;;;259    
                          ENDP


                          AREA ||i.enc28j60PhyWrite||, CODE, READONLY, ALIGN=1

                  enc28j60PhyWrite PROC
;;;114    
;;;115    void enc28j60PhyWrite(unsigned char address, unsigned int data)
000000  b510              PUSH     {r4,lr}
;;;116    {
000002  460c              MOV      r4,r1
;;;117        // set the PHY register address
;;;118        enc28j60Write(MIREGADR, address);
000004  4601              MOV      r1,r0
000006  20d4              MOVS     r0,#0xd4
000008  f7fffffe          BL       enc28j60Write
;;;119        // write the PHY data
;;;120        enc28j60Write(MIWRL, data);
00000c  b2e1              UXTB     r1,r4
00000e  20d6              MOVS     r0,#0xd6
000010  f7fffffe          BL       enc28j60Write
;;;121        enc28j60Write(MIWRH, data>>8);
000014  f3c42107          UBFX     r1,r4,#8,#8
000018  20d7              MOVS     r0,#0xd7
00001a  f7fffffe          BL       enc28j60Write
                  |L4.30|
;;;122        // wait until the PHY write completes
;;;123        while(enc28j60Read(MISTAT) & MISTAT_BUSY)
00001e  20ea              MOVS     r0,#0xea
000020  f7fffffe          BL       enc28j60Read
000024  07c0              LSLS     r0,r0,#31
000026  d1fa              BNE      |L4.30|
;;;124        {
;;;125            //Del_10us(1);
;;;126            //_nop_();
;;;127        }
;;;128    }
000028  bd10              POP      {r4,pc}
;;;129    
                          ENDP


                          AREA ||i.enc28j60Read||, CODE, READONLY, ALIGN=1

                  enc28j60Read PROC
;;;98     
;;;99     unsigned char enc28j60Read(unsigned char address)
000000  b510              PUSH     {r4,lr}
;;;100    {
000002  4604              MOV      r4,r0
;;;101        // set the bank
;;;102        enc28j60SetBank(address);
000004  f7fffffe          BL       enc28j60SetBank
;;;103        // do the read
;;;104        return enc28j60ReadOp(ENC28J60_READ_CTRL_REG, address);
000008  4621              MOV      r1,r4
00000a  e8bd4010          POP      {r4,lr}
00000e  2000              MOVS     r0,#0
000010  f7ffbffe          B.W      enc28j60ReadOp
;;;105    }
;;;106    
                          ENDP


                          AREA ||i.enc28j60ReadBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60ReadBuffer PROC
;;;55     
;;;56     void enc28j60ReadBuffer(unsigned int len, unsigned char* data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;57     {
;;;58         ENC28J60_CSL();
000004  4f0c              LDR      r7,|L6.56|
000006  f44f5680          MOV      r6,#0x1000
00000a  4605              MOV      r5,r0                 ;57
00000c  460c              MOV      r4,r1                 ;57
00000e  f8c76c14          STR      r6,[r7,#0xc14]
;;;59         // issue read command
;;;60         SPI2_ReadWrite(ENC28J60_READ_BUF_MEM);
000012  203a              MOVS     r0,#0x3a
000014  f7fffffe          BL       SPI2_ReadWrite
;;;61         while(len)
000018  e005              B        |L6.38|
                  |L6.26|
;;;62         {
;;;63             len--;
00001a  1e6d              SUBS     r5,r5,#1
;;;64             // read data
;;;65             *data = (unsigned char)SPI2_ReadWrite(0);
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SPI2_ReadWrite
000022  f8040b01          STRB     r0,[r4],#1
                  |L6.38|
000026  2d00              CMP      r5,#0                 ;61
000028  d1f7              BNE      |L6.26|
;;;66             data++;
;;;67         }
;;;68         *data='\0';
00002a  2000              MOVS     r0,#0
00002c  7020              STRB     r0,[r4,#0]
;;;69         ENC28J60_CSH();
00002e  f8c76c10          STR      r6,[r7,#0xc10]
;;;70     }
000032  e8bd81f0          POP      {r4-r8,pc}
;;;71     
                          ENDP

000036  0000              DCW      0x0000
                  |L6.56|
                          DCD      0x40010000

                          AREA ||i.enc28j60ReadOp||, CODE, READONLY, ALIGN=2

                  enc28j60ReadOp PROC
;;;22     
;;;23     unsigned char enc28j60ReadOp(unsigned char op, unsigned char address)
000000  b570              PUSH     {r4-r6,lr}
;;;24     {
;;;25         unsigned char dat = 0;
;;;26         
;;;27         ENC28J60_CSL();
000002  4e0b              LDR      r6,|L7.48|
000004  f44f5580          MOV      r5,#0x1000
000008  4602              MOV      r2,r0                 ;24
00000a  460c              MOV      r4,r1                 ;24
00000c  f8c65c14          STR      r5,[r6,#0xc14]
;;;28         
;;;29         dat = op | (address & ADDR_MASK);
000010  f001001f          AND      r0,r1,#0x1f
000014  4310              ORRS     r0,r0,r2
;;;30         SPI2_ReadWrite(dat);
000016  f7fffffe          BL       SPI2_ReadWrite
;;;31         dat = SPI2_ReadWrite(0xFF);
00001a  20ff              MOVS     r0,#0xff
00001c  f7fffffe          BL       SPI2_ReadWrite
;;;32         // do dummy read if needed (for mac and mii, see datasheet page 29)
;;;33         if(address & 0x80)
000020  0621              LSLS     r1,r4,#24
000022  d502              BPL      |L7.42|
;;;34         {
;;;35             dat = SPI2_ReadWrite(0xFF);
000024  20ff              MOVS     r0,#0xff
000026  f7fffffe          BL       SPI2_ReadWrite
                  |L7.42|
;;;36         }
;;;37         // release CS
;;;38         ENC28J60_CSH();
00002a  f8c65c10          STR      r5,[r6,#0xc10]
;;;39         return dat;
;;;40     }
00002e  bd70              POP      {r4-r6,pc}
;;;41     
                          ENDP

                  |L7.48|
                          DCD      0x40010000

                          AREA ||i.enc28j60SetBank||, CODE, READONLY, ALIGN=2

                  enc28j60SetBank PROC
;;;86     
;;;87     void enc28j60SetBank(unsigned char address)
000000  b570              PUSH     {r4-r6,lr}
;;;88     {
;;;89         // set the bank (if needed)
;;;90         if((address & BANK_MASK) != Enc28j60Bank)
000002  4e0a              LDR      r6,|L8.44|
000004  4605              MOV      r5,r0                 ;88
000006  f0000460          AND      r4,r0,#0x60
00000a  7830              LDRB     r0,[r6,#0]  ; Enc28j60Bank
00000c  4284              CMP      r4,r0
00000e  d00b              BEQ      |L8.40|
;;;91         {
;;;92             // set the bank
;;;93             enc28j60WriteOp(ENC28J60_BIT_FIELD_CLR, ECON1, (ECON1_BSEL1|ECON1_BSEL0));
000010  2203              MOVS     r2,#3
000012  211f              MOVS     r1,#0x1f
000014  20a0              MOVS     r0,#0xa0
000016  f7fffffe          BL       enc28j60WriteOp
;;;94             enc28j60WriteOp(ENC28J60_BIT_FIELD_SET, ECON1, (address & BANK_MASK)>>5);
00001a  f3c51241          UBFX     r2,r5,#5,#2
00001e  211f              MOVS     r1,#0x1f
000020  2080              MOVS     r0,#0x80
000022  f7fffffe          BL       enc28j60WriteOp
;;;95             Enc28j60Bank = (address & BANK_MASK);
000026  7034              STRB     r4,[r6,#0]
                  |L8.40|
;;;96         }
;;;97     }
000028  bd70              POP      {r4-r6,pc}
;;;98     
                          ENDP

00002a  0000              DCW      0x0000
                  |L8.44|
                          DCD      ||.data||

                          AREA ||i.enc28j60Write||, CODE, READONLY, ALIGN=1

                  enc28j60Write PROC
;;;106    
;;;107    void enc28j60Write(unsigned char address, unsigned char data)
000000  b570              PUSH     {r4-r6,lr}
;;;108    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;109        // set the bank
;;;110        enc28j60SetBank(address);
000006  f7fffffe          BL       enc28j60SetBank
;;;111        // do the write
;;;112        enc28j60WriteOp(ENC28J60_WRITE_CTRL_REG, address, data);
00000a  4622              MOV      r2,r4
00000c  4629              MOV      r1,r5
00000e  e8bd4070          POP      {r4-r6,lr}
000012  2040              MOVS     r0,#0x40
000014  f7ffbffe          B.W      enc28j60WriteOp
;;;113    }
;;;114    
                          ENDP


                          AREA ||i.enc28j60WriteBuffer||, CODE, READONLY, ALIGN=2

                  enc28j60WriteBuffer PROC
;;;71     
;;;72     void enc28j60WriteBuffer(unsigned int len, unsigned char* data)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;73     {
;;;74         ENC28J60_CSL();
000004  4f0a              LDR      r7,|L10.48|
000006  f44f5680          MOV      r6,#0x1000
00000a  4604              MOV      r4,r0                 ;73
00000c  460d              MOV      r5,r1                 ;73
00000e  f8c76c14          STR      r6,[r7,#0xc14]
;;;75         // issue write command
;;;76         SPI2_ReadWrite(ENC28J60_WRITE_BUF_MEM);
000012  207a              MOVS     r0,#0x7a
000014  f7fffffe          BL       SPI2_ReadWrite
;;;77         
;;;78         while(len)
000018  e004              B        |L10.36|
                  |L10.26|
;;;79         {
;;;80             len--;
00001a  1e64              SUBS     r4,r4,#1
;;;81             SPI2_ReadWrite(*data);
00001c  7828              LDRB     r0,[r5,#0]
00001e  f7fffffe          BL       SPI2_ReadWrite
;;;82             data++;
000022  1c6d              ADDS     r5,r5,#1
                  |L10.36|
000024  2c00              CMP      r4,#0                 ;78
000026  d1f8              BNE      |L10.26|
;;;83         }
;;;84         ENC28J60_CSH();
000028  f8c76c10          STR      r6,[r7,#0xc10]
;;;85     }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;86     
                          ENDP

                  |L10.48|
                          DCD      0x40010000

                          AREA ||i.enc28j60WriteOp||, CODE, READONLY, ALIGN=2

                  enc28j60WriteOp PROC
;;;41     
;;;42     void enc28j60WriteOp(unsigned char op, unsigned char address, unsigned char data)
000000  b570              PUSH     {r4-r6,lr}
;;;43     {
;;;44         unsigned char dat = 0;
;;;45         
;;;46         ENC28J60_CSL();
000002  4d08              LDR      r5,|L11.36|
000004  f44f5480          MOV      r4,#0x1000
000008  4616              MOV      r6,r2                 ;43
00000a  606c              STR      r4,[r5,#4]
;;;47         // issue write command
;;;48         dat = op | (address & ADDR_MASK);
00000c  f001011f          AND      r1,r1,#0x1f
000010  ea410000          ORR      r0,r1,r0
;;;49         SPI2_ReadWrite(dat);
000014  f7fffffe          BL       SPI2_ReadWrite
;;;50         // write data
;;;51         dat = data;
000018  4630              MOV      r0,r6
;;;52         SPI2_ReadWrite(dat);
00001a  f7fffffe          BL       SPI2_ReadWrite
;;;53         ENC28J60_CSH();
00001e  602c              STR      r4,[r5,#0]
;;;54     }
000020  bd70              POP      {r4-r6,pc}
;;;55     
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x40010c10

                          AREA ||i.enc28j60clkout||, CODE, READONLY, ALIGN=1

                  enc28j60clkout PROC
;;;129    
;;;130    void enc28j60clkout(unsigned char clk)
000000  f0000107          AND      r1,r0,#7
;;;131    {
;;;132        //setup clkout: 2 is 12.5MHz:
;;;133        enc28j60Write(ECOCON, clk & 0x7);
000004  2075              MOVS     r0,#0x75
000006  f7ffbffe          B.W      enc28j60Write
;;;134    }
;;;135    
                          ENDP


                          AREA ||i.enc28j60getrev||, CODE, READONLY, ALIGN=1

                  enc28j60getrev PROC
;;;225    // read the revision of the chip:
;;;226    unsigned char enc28j60getrev(void)
000000  2072              MOVS     r0,#0x72
;;;227    {
;;;228        //在EREVID 内也存储了版本信息。 EREVID 是一个只读控
;;;229        //制寄存器，包含一个5 位标识符，用来标识器件特定硅片
;;;230        //的版本号
;;;231        return(enc28j60Read(EREVID));
000002  f7ffbffe          B.W      enc28j60Read
;;;232    }
;;;233    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  Enc28j60Bank
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  NextPacketPtr
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Source\\Net\\enc28j60.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_enc28j60_c_a086b4bb____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_enc28j60_c_a086b4bb____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___10_enc28j60_c_a086b4bb____REVSH|
#line 128
|__asm___10_enc28j60_c_a086b4bb____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
