; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\os_sem.o --depend=.\ouput\os_sem.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\os_sem.crf Source\uCOS-II\Source\os_sem.c]
                          THUMB

                          AREA ||i.OSSemAccept||, CODE, READONLY, ALIGN=1

                  OSSemAccept PROC
;;;48     #if OS_SEM_ACCEPT_EN > 0u
;;;49     INT16U  OSSemAccept (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  0004              MOVS     r4,r0
;;;51         INT16U     cnt;
;;;52     #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;53         OS_CPU_SR  cpu_sr = 0u;
;;;54     #endif
;;;55     
;;;56     
;;;57     
;;;58     #if OS_ARG_CHK_EN > 0u
;;;59         if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000004  d002              BEQ      |L1.12|
;;;60             return (0u);
;;;61         }
;;;62     #endif
;;;63         if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L1.16|
                  |L1.12|
;;;64             return (0u);
00000c  2000              MOVS     r0,#0
;;;65         }
;;;66         OS_ENTER_CRITICAL();
;;;67         cnt = pevent->OSEventCnt;
;;;68         if (cnt > 0u) {                                   /* See if resource is available                  */
;;;69             pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
;;;70         }
;;;71         OS_EXIT_CRITICAL();
;;;72         return (cnt);                                     /* Return semaphore count                        */
;;;73     }
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       OS_CPU_SR_Save
000014  8925              LDRH     r5,[r4,#8]            ;67
000016  b10d              CBZ      r5,|L1.28|
000018  1e69              SUBS     r1,r5,#1              ;69
00001a  8121              STRH     r1,[r4,#8]            ;69
                  |L1.28|
00001c  f7fffffe          BL       OS_CPU_SR_Restore
000020  4628              MOV      r0,r5                 ;72
000022  bd70              POP      {r4-r6,pc}
;;;74     #endif
                          ENDP


                          AREA ||i.OSSemCreate||, CODE, READONLY, ALIGN=2

                  OSSemCreate PROC
;;;93     
;;;94     OS_EVENT  *OSSemCreate (INT16U cnt)
000000  b570              PUSH     {r4-r6,lr}
;;;95     {
000002  4605              MOV      r5,r0
;;;96         OS_EVENT  *pevent;
;;;97     #if OS_CRITICAL_METHOD == 3u                               /* Allocate storage for CPU status register */
;;;98         OS_CPU_SR  cpu_sr = 0u;
;;;99     #endif
;;;100    
;;;101    
;;;102    
;;;103    #ifdef OS_SAFETY_CRITICAL_IEC61508
;;;104        if (OSSafetyCriticalStartFlag == OS_TRUE) {
;;;105            OS_SAFETY_CRITICAL_EXCEPTION();
;;;106        }
;;;107    #endif
;;;108    
;;;109        if (OSIntNesting > 0u) {                               /* See if called from ISR ...               */
000004  480d              LDR      r0,|L2.60|
000006  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
000008  b108              CBZ      r0,|L2.14|
;;;110            return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
00000a  2000              MOVS     r0,#0
;;;111        }
;;;112        OS_ENTER_CRITICAL();
;;;113        pevent = OSEventFreeList;                              /* Get next free event control block        */
;;;114        if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
;;;115            OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
;;;116        }
;;;117        OS_EXIT_CRITICAL();
;;;118        if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
;;;119            pevent->OSEventType    = OS_EVENT_TYPE_SEM;
;;;120            pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
;;;121            pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
;;;122    #if OS_EVENT_NAME_EN > 0u
;;;123            pevent->OSEventName    = (INT8U *)(void *)"?";
;;;124    #endif
;;;125            OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
;;;126        }
;;;127        return (pevent);
;;;128    }
00000c  bd70              POP      {r4-r6,pc}
                  |L2.14|
00000e  f7fffffe          BL       OS_CPU_SR_Save
000012  490b              LDR      r1,|L2.64|
000014  680c              LDR      r4,[r1,#0]            ;114  ; OSEventFreeList
000016  b10c              CBZ      r4,|L2.28|
000018  6862              LDR      r2,[r4,#4]            ;115
00001a  600a              STR      r2,[r1,#0]            ;115  ; OSEventFreeList
                  |L2.28|
00001c  f7fffffe          BL       OS_CPU_SR_Restore
000020  b14c              CBZ      r4,|L2.54|
000022  2003              MOVS     r0,#3                 ;119
000024  7020              STRB     r0,[r4,#0]            ;119
000026  8125              STRH     r5,[r4,#8]            ;120
000028  2000              MOVS     r0,#0                 ;121
00002a  6060              STR      r0,[r4,#4]            ;123
00002c  a005              ADR      r0,|L2.68|
00002e  6160              STR      r0,[r4,#0x14]         ;125
000030  4620              MOV      r0,r4                 ;125
000032  f7fffffe          BL       OS_EventWaitListInit
                  |L2.54|
000036  4620              MOV      r0,r4                 ;127
000038  bd70              POP      {r4-r6,pc}
;;;129    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      OSIntNesting
                  |L2.64|
                          DCD      OSEventFreeList
                  |L2.68|
000044  3f00              DCB      "?",0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.OSSemPend||, CODE, READONLY, ALIGN=2

                  OSSemPend PROC
;;;288    /*$PAGE*/
;;;289    void  OSSemPend (OS_EVENT  *pevent,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;290                     INT32U     timeout,
;;;291                     INT8U     *perr)
;;;292    {
000004  0005              MOVS     r5,r0
000006  4689              MOV      r9,r1
000008  4614              MOV      r4,r2
;;;293    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;294        OS_CPU_SR  cpu_sr = 0u;
;;;295    #endif
;;;296    
;;;297    
;;;298    
;;;299    #ifdef OS_SAFETY_CRITICAL
;;;300        if (perr == (INT8U *)0) {
;;;301            OS_SAFETY_CRITICAL_EXCEPTION();
;;;302        }
;;;303    #endif
;;;304    
;;;305    #if OS_ARG_CHK_EN > 0u
;;;306        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00000a  d004              BEQ      |L3.22|
;;;307            *perr = OS_ERR_PEVENT_NULL;
;;;308            return;
;;;309        }
;;;310    #endif
;;;311        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7828              LDRB     r0,[r5,#0]
00000e  2803              CMP      r0,#3
000010  d003              BEQ      |L3.26|
;;;312            *perr = OS_ERR_EVENT_TYPE;
000012  2001              MOVS     r0,#1
;;;313            return;
000014  e00a              B        |L3.44|
                  |L3.22|
000016  2004              MOVS     r0,#4                 ;307
000018  e008              B        |L3.44|
                  |L3.26|
;;;314        }
;;;315        if (OSIntNesting > 0u) {                          /* See if called from ISR ...                    */
00001a  4826              LDR      r0,|L3.180|
00001c  7800              LDRB     r0,[r0,#0]  ; OSIntNesting
00001e  b108              CBZ      r0,|L3.36|
;;;316            *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
000020  2002              MOVS     r0,#2
;;;317            return;
000022  e003              B        |L3.44|
                  |L3.36|
;;;318        }
;;;319        if (OSLockNesting > 0u) {                         /* See if called with scheduler locked ...       */
000024  4824              LDR      r0,|L3.184|
000026  7800              LDRB     r0,[r0,#0]  ; OSLockNesting
000028  b118              CBZ      r0,|L3.50|
;;;320            *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
00002a  200d              MOVS     r0,#0xd
                  |L3.44|
00002c  7010              STRB     r0,[r2,#0]
                  |L3.46|
;;;321            return;
;;;322        }
;;;323        OS_ENTER_CRITICAL();
;;;324        if (pevent->OSEventCnt > 0u) {                    /* If sem. is positive, resource available ...   */
;;;325            pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
;;;326            OS_EXIT_CRITICAL();
;;;327            *perr = OS_ERR_NONE;
;;;328            return;
;;;329        }
;;;330                                                          /* Otherwise, must wait until event occurs       */
;;;331        OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
;;;332        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
;;;333        OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
;;;334        OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
;;;335        OS_EXIT_CRITICAL();
;;;336        OS_Sched();                                       /* Find next highest priority task ready         */
;;;337        OS_ENTER_CRITICAL();
;;;338        switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
;;;339            case OS_STAT_PEND_OK:
;;;340                 *perr = OS_ERR_NONE;
;;;341                 break;
;;;342    
;;;343            case OS_STAT_PEND_ABORT:
;;;344                 *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
;;;345                 break;
;;;346    
;;;347            case OS_STAT_PEND_TO:
;;;348            default:
;;;349                 OS_EventTaskRemove(OSTCBCur, pevent);
;;;350                 *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
;;;351                 break;
;;;352        }
;;;353        OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
;;;354        OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
;;;355        OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
;;;356    #if (OS_EVENT_MULTI_EN > 0u)
;;;357        OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
;;;358    #endif
;;;359        OS_EXIT_CRITICAL();
;;;360    }
00002e  e8bd87f0          POP      {r4-r10,pc}
                  |L3.50|
000032  f7fffffe          BL       OS_CPU_SR_Save
000036  4606              MOV      r6,r0                 ;323
000038  8928              LDRH     r0,[r5,#8]            ;324
00003a  2700              MOVS     r7,#0                 ;294
00003c  b130              CBZ      r0,|L3.76|
00003e  1e40              SUBS     r0,r0,#1              ;325
000040  8128              STRH     r0,[r5,#8]            ;325
000042  4630              MOV      r0,r6                 ;326
000044  f7fffffe          BL       OS_CPU_SR_Restore
000048  7027              STRB     r7,[r4,#0]            ;327
00004a  e7f0              B        |L3.46|
                  |L3.76|
00004c  f8df806c          LDR      r8,|L3.188|
000050  f8d80000          LDR      r0,[r8,#0]            ;331  ; OSTCBCur
000054  f8101f28          LDRB     r1,[r0,#0x28]!        ;331
000058  f0410101          ORR      r1,r1,#1              ;331
00005c  7001              STRB     r1,[r0,#0]            ;331
00005e  7047              STRB     r7,[r0,#1]            ;332
000060  f8409c04          STR      r9,[r0,#-4]           ;333
000064  4628              MOV      r0,r5                 ;334
000066  f7fffffe          BL       OS_EventTaskWait
00006a  4630              MOV      r0,r6                 ;335
00006c  f7fffffe          BL       OS_CPU_SR_Restore
000070  f7fffffe          BL       OS_Sched
000074  f7fffffe          BL       OS_CPU_SR_Save
000078  4606              MOV      r6,r0                 ;337
00007a  f8d80000          LDR      r0,[r8,#0]            ;338  ; OSTCBCur
00007e  f8901029          LDRB     r1,[r0,#0x29]         ;338
000082  b131              CBZ      r1,|L3.146|
000084  2902              CMP      r1,#2                 ;338
000086  d006              BEQ      |L3.150|
000088  4629              MOV      r1,r5                 ;349
00008a  f7fffffe          BL       OS_EventTaskRemove
00008e  200a              MOVS     r0,#0xa               ;350
000090  e002              B        |L3.152|
                  |L3.146|
000092  7027              STRB     r7,[r4,#0]            ;340
000094  e001              B        |L3.154|
                  |L3.150|
000096  200e              MOVS     r0,#0xe               ;344
                  |L3.152|
000098  7020              STRB     r0,[r4,#0]            ;344
                  |L3.154|
00009a  f8d80000          LDR      r0,[r8,#0]            ;353  ; OSTCBCur
00009e  f100001c          ADD      r0,r0,#0x1c           ;353
0000a2  7307              STRB     r7,[r0,#0xc]          ;353
0000a4  7347              STRB     r7,[r0,#0xd]          ;354
0000a6  6007              STR      r7,[r0,#0]            ;359
0000a8  4630              MOV      r0,r6                 ;359
0000aa  e8bd47f0          POP      {r4-r10,lr}           ;359
0000ae  f7ffbffe          B.W      OS_CPU_SR_Restore
;;;361    
                          ENDP

0000b2  0000              DCW      0x0000
                  |L3.180|
                          DCD      OSIntNesting
                  |L3.184|
                          DCD      OSLockNesting
                  |L3.188|
                          DCD      OSTCBCur

                          AREA ||i.OSSemPendAbort||, CODE, READONLY, ALIGN=1

                  OSSemPendAbort PROC
;;;396    #if OS_SEM_PEND_ABORT_EN > 0u
;;;397    INT8U  OSSemPendAbort (OS_EVENT  *pevent,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;398                           INT8U      opt,
;;;399                           INT8U     *perr)
;;;400    {
000004  0005              MOVS     r5,r0
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
;;;401        INT8U      nbr_tasks;
;;;402    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;403        OS_CPU_SR  cpu_sr = 0u;
;;;404    #endif
;;;405    
;;;406    
;;;407    
;;;408    #ifdef OS_SAFETY_CRITICAL
;;;409        if (perr == (INT8U *)0) {
;;;410            OS_SAFETY_CRITICAL_EXCEPTION();
;;;411        }
;;;412    #endif
;;;413    
;;;414    #if OS_ARG_CHK_EN > 0u
;;;415        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
00000a  d005              BEQ      |L4.24|
;;;416            *perr = OS_ERR_PEVENT_NULL;
;;;417            return (0u);
;;;418        }
;;;419    #endif
;;;420        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000c  7829              LDRB     r1,[r5,#0]
;;;421            *perr = OS_ERR_EVENT_TYPE;
00000e  2001              MOVS     r0,#1
000010  2903              CMP      r1,#3                 ;420
000012  d003              BEQ      |L4.28|
                  |L4.20|
000014  7010              STRB     r0,[r2,#0]
;;;422            return (0u);
000016  e02b              B        |L4.112|
                  |L4.24|
000018  2004              MOVS     r0,#4                 ;416
00001a  e7fb              B        |L4.20|
                  |L4.28|
;;;423        }
;;;424        OS_ENTER_CRITICAL();
00001c  f7fffffe          BL       OS_CPU_SR_Save
000020  4680              MOV      r8,r0
;;;425        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting on semaphore?         */
000022  7aa8              LDRB     r0,[r5,#0xa]
000024  b1f8              CBZ      r0,|L4.102|
;;;426            nbr_tasks = 0u;
000026  2400              MOVS     r4,#0
;;;427            switch (opt) {
000028  2f01              CMP      r7,#1
00002a  d010              BEQ      |L4.78|
;;;428                case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
;;;429                     while (pevent->OSEventGrp != 0u) {   /* Yes, ready ALL tasks waiting on semaphore     */
;;;430                         (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
;;;431                         nbr_tasks++;
;;;432                     }
;;;433                     break;
;;;434    
;;;435                case OS_PEND_OPT_NONE:
;;;436                default:                                  /* No,  ready HPT       waiting on semaphore     */
;;;437                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
00002c  2302              MOVS     r3,#2
00002e  2201              MOVS     r2,#1
000030  2100              MOVS     r1,#0
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       OS_EventTaskRdy
;;;438                     nbr_tasks++;
000038  2401              MOVS     r4,#1
                  |L4.58|
;;;439                     break;
;;;440            }
;;;441            OS_EXIT_CRITICAL();
00003a  4640              MOV      r0,r8
00003c  f7fffffe          BL       OS_CPU_SR_Restore
;;;442            OS_Sched();                                   /* Find HPT ready to run                         */
000040  f7fffffe          BL       OS_Sched
;;;443            *perr = OS_ERR_PEND_ABORT;
000044  200e              MOVS     r0,#0xe
000046  7030              STRB     r0,[r6,#0]
;;;444            return (nbr_tasks);
000048  4620              MOV      r0,r4
                  |L4.74|
;;;445        }
;;;446        OS_EXIT_CRITICAL();
;;;447        *perr = OS_ERR_NONE;
;;;448        return (0u);                                      /* No tasks waiting on semaphore                 */
;;;449    }
00004a  e8bd81f0          POP      {r4-r8,pc}
                  |L4.78|
00004e  2302              MOVS     r3,#2                 ;430
000050  2201              MOVS     r2,#1                 ;430
000052  2100              MOVS     r1,#0                 ;430
000054  4628              MOV      r0,r5                 ;430
000056  f7fffffe          BL       OS_EventTaskRdy
00005a  1c64              ADDS     r4,r4,#1              ;431
00005c  7aa8              LDRB     r0,[r5,#0xa]          ;429
00005e  b2e4              UXTB     r4,r4                 ;431
000060  2800              CMP      r0,#0                 ;429
000062  d1f4              BNE      |L4.78|
000064  e7e9              B        |L4.58|
                  |L4.102|
000066  4640              MOV      r0,r8                 ;446
000068  f7fffffe          BL       OS_CPU_SR_Restore
00006c  2000              MOVS     r0,#0                 ;447
00006e  7030              STRB     r0,[r6,#0]            ;447
                  |L4.112|
000070  2000              MOVS     r0,#0                 ;448
000072  e7ea              B        |L4.74|
;;;450    #endif
                          ENDP


                          AREA ||i.OSSemPost||, CODE, READONLY, ALIGN=1

                  OSSemPost PROC
;;;470    
;;;471    INT8U  OSSemPost (OS_EVENT *pevent)
000000  b570              PUSH     {r4-r6,lr}
;;;472    {
000002  0004              MOVS     r4,r0
;;;473    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;474        OS_CPU_SR  cpu_sr = 0u;
;;;475    #endif
;;;476    
;;;477    
;;;478    
;;;479    #if OS_ARG_CHK_EN > 0u
;;;480        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000004  d004              BEQ      |L5.16|
;;;481            return (OS_ERR_PEVENT_NULL);
;;;482        }
;;;483    #endif
;;;484        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
000006  7820              LDRB     r0,[r4,#0]
000008  2803              CMP      r0,#3
00000a  d003              BEQ      |L5.20|
;;;485            return (OS_ERR_EVENT_TYPE);
00000c  2001              MOVS     r0,#1
;;;486        }
;;;487        OS_ENTER_CRITICAL();
;;;488        if (pevent->OSEventGrp != 0u) {                   /* See if any task waiting for semaphore         */
;;;489                                                          /* Ready HPT waiting on event                    */
;;;490            (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
;;;491            OS_EXIT_CRITICAL();
;;;492            OS_Sched();                                   /* Find HPT ready to run                         */
;;;493            return (OS_ERR_NONE);
;;;494        }
;;;495        if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
;;;496            pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
;;;497            OS_EXIT_CRITICAL();
;;;498            return (OS_ERR_NONE);
;;;499        }
;;;500        OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
;;;501        return (OS_ERR_SEM_OVF);
;;;502    }
00000e  bd70              POP      {r4-r6,pc}
                  |L5.16|
000010  2004              MOVS     r0,#4                 ;481
000012  bd70              POP      {r4-r6,pc}
                  |L5.20|
000014  f7fffffe          BL       OS_CPU_SR_Save
000018  4605              MOV      r5,r0                 ;487
00001a  7aa0              LDRB     r0,[r4,#0xa]          ;488
00001c  b158              CBZ      r0,|L5.54|
00001e  2300              MOVS     r3,#0                 ;490
000020  2201              MOVS     r2,#1                 ;490
000022  4619              MOV      r1,r3                 ;490
000024  4620              MOV      r0,r4                 ;490
000026  f7fffffe          BL       OS_EventTaskRdy
00002a  4628              MOV      r0,r5                 ;491
00002c  f7fffffe          BL       OS_CPU_SR_Restore
000030  f7fffffe          BL       OS_Sched
000034  e009              B        |L5.74|
                  |L5.54|
000036  8920              LDRH     r0,[r4,#8]            ;495
000038  f64f71ff          MOV      r1,#0xffff            ;495
00003c  4288              CMP      r0,r1                 ;495
00003e  d206              BCS      |L5.78|
000040  1c40              ADDS     r0,r0,#1              ;496
000042  8120              STRH     r0,[r4,#8]            ;496
000044  4628              MOV      r0,r5                 ;497
000046  f7fffffe          BL       OS_CPU_SR_Restore
                  |L5.74|
00004a  2000              MOVS     r0,#0                 ;498
00004c  bd70              POP      {r4-r6,pc}
                  |L5.78|
00004e  4628              MOV      r0,r5                 ;500
000050  f7fffffe          BL       OS_CPU_SR_Restore
000054  2033              MOVS     r0,#0x33              ;501
000056  bd70              POP      {r4-r6,pc}
;;;503    
                          ENDP


                          AREA ||i.OSSemSet||, CODE, READONLY, ALIGN=1

                  OSSemSet PROC
;;;586    #if OS_SEM_SET_EN > 0u
;;;587    void  OSSemSet (OS_EVENT  *pevent,
000000  b570              PUSH     {r4-r6,lr}
;;;588                    INT16U     cnt,
;;;589                    INT8U     *perr)
;;;590    {
000002  0004              MOVS     r4,r0
000004  460e              MOV      r6,r1
000006  4615              MOV      r5,r2
;;;591    #if OS_CRITICAL_METHOD == 3u                          /* Allocate storage for CPU status register      */
;;;592        OS_CPU_SR  cpu_sr = 0u;
;;;593    #endif
;;;594    
;;;595    
;;;596    
;;;597    #ifdef OS_SAFETY_CRITICAL
;;;598        if (perr == (INT8U *)0) {
;;;599            OS_SAFETY_CRITICAL_EXCEPTION();
;;;600        }
;;;601    #endif
;;;602    
;;;603    #if OS_ARG_CHK_EN > 0u
;;;604        if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
000008  d005              BEQ      |L6.22|
;;;605            *perr = OS_ERR_PEVENT_NULL;
;;;606            return;
;;;607        }
;;;608    #endif
;;;609        if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
00000a  7820              LDRB     r0,[r4,#0]
00000c  2803              CMP      r0,#3
00000e  d004              BEQ      |L6.26|
;;;610            *perr = OS_ERR_EVENT_TYPE;
000010  2001              MOVS     r0,#1
                  |L6.18|
000012  7010              STRB     r0,[r2,#0]
;;;611            return;
;;;612        }
;;;613        OS_ENTER_CRITICAL();
;;;614        *perr = OS_ERR_NONE;
;;;615        if (pevent->OSEventCnt > 0u) {                    /* See if semaphore already has a count          */
;;;616            pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
;;;617        } else {                                          /* No                                            */
;;;618            if (pevent->OSEventGrp == 0u) {               /*      See if task(s) waiting?                  */
;;;619                pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
;;;620            } else {
;;;621                *perr              = OS_ERR_TASK_WAITING;
;;;622            }
;;;623        }
;;;624        OS_EXIT_CRITICAL();
;;;625    }
000014  bd70              POP      {r4-r6,pc}
                  |L6.22|
000016  2004              MOVS     r0,#4                 ;605
000018  e7fb              B        |L6.18|
                  |L6.26|
00001a  f7fffffe          BL       OS_CPU_SR_Save
00001e  2100              MOVS     r1,#0                 ;614
000020  7029              STRB     r1,[r5,#0]            ;614
000022  8921              LDRH     r1,[r4,#8]            ;615
000024  b939              CBNZ     r1,|L6.54|
000026  7aa1              LDRB     r1,[r4,#0xa]          ;618
000028  b129              CBZ      r1,|L6.54|
00002a  2149              MOVS     r1,#0x49              ;621
00002c  7029              STRB     r1,[r5,#0]            ;621
                  |L6.46|
00002e  e8bd4070          POP      {r4-r6,lr}            ;624
000032  f7ffbffe          B.W      OS_CPU_SR_Restore
                  |L6.54|
000036  8126              STRH     r6,[r4,#8]            ;619
000038  e7f9              B        |L6.46|
;;;626    #endif
                          ENDP

