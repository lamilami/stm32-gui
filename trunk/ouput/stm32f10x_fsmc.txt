; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_fsmc.o --depend=.\ouput\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_fsmc.crf Source\FWLib\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||i.FSMC_ClearFlag||, CODE, READONLY, ALIGN=1

                  FSMC_ClearFlag PROC
;;;743      */
;;;744    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  f04f4220          MOV      r2,#0xa0000000
;;;745    {
;;;746     /* Check the parameters */
;;;747      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;748      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;749        
;;;750      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d009              BEQ      |L1.28|
;;;751      {
;;;752        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;753      }  
;;;754      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00a              BEQ      |L1.36|
00000e  f10202a4          ADD      r2,r2,#0xa4
                  |L1.18|
;;;755      {
;;;756        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;757      }
;;;758      /* FSMC_Bank4_PCCARD*/
;;;759      else
;;;760      {
;;;761        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000012  6810              LDR      r0,[r2,#0]
000014  ea200001          BIC      r0,r0,r1
000018  6010              STR      r0,[r2,#0]
;;;762      }
;;;763    }
00001a  4770              BX       lr
                  |L1.28|
00001c  6e50              LDR      r0,[r2,#0x64]         ;752
00001e  4388              BICS     r0,r0,r1              ;752
000020  6650              STR      r0,[r2,#0x64]         ;752
000022  4770              BX       lr
                  |L1.36|
000024  f1020284          ADD      r2,r2,#0x84
000028  e7f3              B        |L1.18|
;;;764    
                          ENDP


                          AREA ||i.FSMC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  FSMC_ClearITPendingBit PROC
;;;829      */
;;;830    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  f04f4220          MOV      r2,#0xa0000000
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;834      assert_param(IS_FSMC_IT(FSMC_IT));
;;;835        
;;;836      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d009              BEQ      |L2.28|
;;;837      {
;;;838        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;839      }  
;;;840      else if(FSMC_Bank == FSMC_Bank3_NAND)
000008  f5b07f80          CMP      r0,#0x100
00000c  d00b              BEQ      |L2.38|
00000e  f10202a4          ADD      r2,r2,#0xa4
                  |L2.18|
;;;841      {
;;;842        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;843      }
;;;844      /* FSMC_Bank4_PCCARD*/
;;;845      else
;;;846      {
;;;847        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
000012  6810              LDR      r0,[r2,#0]
000014  ea2000d1          BIC      r0,r0,r1,LSR #3
000018  6010              STR      r0,[r2,#0]
;;;848      }
;;;849    }
00001a  4770              BX       lr
                  |L2.28|
00001c  6e50              LDR      r0,[r2,#0x64]         ;838
00001e  ea2000d1          BIC      r0,r0,r1,LSR #3       ;838
000022  6650              STR      r0,[r2,#0x64]         ;838
000024  4770              BX       lr
                  |L2.38|
000026  f1020284          ADD      r2,r2,#0x84
00002a  e7f2              B        |L2.18|
;;;850    
                          ENDP


                          AREA ||i.FSMC_GetECC||, CODE, READONLY, ALIGN=1

                  FSMC_GetECC PROC
;;;599      */
;;;600    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000000  f04f4120          MOV      r1,#0xa0000000
;;;601    {
;;;602      uint32_t eccval = 0x00000000;
;;;603      
;;;604      if(FSMC_Bank == FSMC_Bank2_NAND)
000004  2810              CMP      r0,#0x10
000006  d002              BEQ      |L3.14|
;;;605      {
;;;606        /* Get the ECCR2 register value */
;;;607        eccval = FSMC_Bank2->ECCR2;
;;;608      }
;;;609      else
;;;610      {
;;;611        /* Get the ECCR3 register value */
;;;612        eccval = FSMC_Bank3->ECCR3;
000008  f8d10094          LDR      r0,[r1,#0x94]
;;;613      }
;;;614      /* Return the error correction code value */
;;;615      return(eccval);
;;;616    }
00000c  4770              BX       lr
                  |L3.14|
00000e  6f48              LDR      r0,[r1,#0x74]         ;607
000010  4770              BX       lr
;;;617    
                          ENDP


                          AREA ||i.FSMC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetFlagStatus PROC
;;;693      */
;;;694    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
000000  4603              MOV      r3,r0
;;;695    {
;;;696      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;697      uint32_t tmpsr = 0x00000000;
;;;698      
;;;699      /* Check the parameters */
;;;700      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;701      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;702      
;;;703      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;704      {
;;;705        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;703
00000a  d008              BEQ      |L4.30|
;;;706      }  
;;;707      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d007              BEQ      |L4.34|
;;;708      {
;;;709        tmpsr = FSMC_Bank3->SR3;
;;;710      }
;;;711      /* FSMC_Bank4_PCCARD*/
;;;712      else
;;;713      {
;;;714        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L4.22|
;;;715      } 
;;;716      
;;;717      /* Get the flag status */
;;;718      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
000016  420a              TST      r2,r1
000018  d000              BEQ      |L4.28|
;;;719      {
;;;720        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L4.28|
;;;721      }
;;;722      else
;;;723      {
;;;724        bitstatus = RESET;
;;;725      }
;;;726      /* Return the flag status */
;;;727      return bitstatus;
;;;728    }
00001c  4770              BX       lr
                  |L4.30|
00001e  6e52              LDR      r2,[r2,#0x64]         ;705
000020  e7f9              B        |L4.22|
                  |L4.34|
000022  f8d22084          LDR      r2,[r2,#0x84]         ;709
000026  e7f6              B        |L4.22|
;;;729    
                          ENDP


                          AREA ||i.FSMC_GetITStatus||, CODE, READONLY, ALIGN=1

                  FSMC_GetITStatus PROC
;;;778      */
;;;779    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
000000  4603              MOV      r3,r0
;;;780    {
;;;781      ITStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;782      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;783      
;;;784      /* Check the parameters */
;;;785      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;786      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;787      
;;;788      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;789      {
;;;790        tmpsr = FSMC_Bank2->SR2;
000004  f04f4220          MOV      r2,#0xa0000000
000008  2b10              CMP      r3,#0x10              ;788
00000a  d00c              BEQ      |L5.38|
;;;791      }  
;;;792      else if(FSMC_Bank == FSMC_Bank3_NAND)
00000c  f5b37f80          CMP      r3,#0x100
000010  d00b              BEQ      |L5.42|
;;;793      {
;;;794        tmpsr = FSMC_Bank3->SR3;
;;;795      }
;;;796      /* FSMC_Bank4_PCCARD*/
;;;797      else
;;;798      {
;;;799        tmpsr = FSMC_Bank4->SR4;
000012  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L5.22|
;;;800      } 
;;;801      
;;;802      itstatus = tmpsr & FSMC_IT;
000016  420a              TST      r2,r1
;;;803      
;;;804      itenable = tmpsr & (FSMC_IT >> 3);
000018  ea0201d1          AND      r1,r2,r1,LSR #3
;;;805      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
00001c  d002              BEQ      |L5.36|
00001e  2900              CMP      r1,#0
000020  d000              BEQ      |L5.36|
;;;806      {
;;;807        bitstatus = SET;
000022  2001              MOVS     r0,#1
                  |L5.36|
;;;808      }
;;;809      else
;;;810      {
;;;811        bitstatus = RESET;
;;;812      }
;;;813      return bitstatus; 
;;;814    }
000024  4770              BX       lr
                  |L5.38|
000026  6e52              LDR      r2,[r2,#0x64]         ;790
000028  e7f5              B        |L5.22|
                  |L5.42|
00002a  f8d22084          LDR      r2,[r2,#0x84]         ;794
00002e  e7f2              B        |L5.22|
;;;815    
                          ENDP


                          AREA ||i.FSMC_ITConfig||, CODE, READONLY, ALIGN=1

                  FSMC_ITConfig PROC
;;;633      */
;;;634    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000000  b510              PUSH     {r4,lr}
;;;635    {
;;;636      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;637      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;638      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;639      
;;;640      if (NewState != DISABLE)
;;;641      {
;;;642        /* Enable the selected FSMC_Bank2 interrupts */
;;;643        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;644        {
;;;645          FSMC_Bank2->SR2 |= FSMC_IT;
;;;646        }
;;;647        /* Enable the selected FSMC_Bank3 interrupts */
;;;648        else if (FSMC_Bank == FSMC_Bank3_NAND)
000002  f44f7480          MOV      r4,#0x100
000006  f04f4320          MOV      r3,#0xa0000000        ;645
00000a  b182              CBZ      r2,|L6.46|
00000c  2810              CMP      r0,#0x10              ;643
00000e  d004              BEQ      |L6.26|
000010  42a0              CMP      r0,r4
000012  d105              BNE      |L6.32|
000014  f1030384          ADD      r3,r3,#0x84
;;;649        {
;;;650          FSMC_Bank3->SR3 |= FSMC_IT;
000018  e004              B        |L6.36|
                  |L6.26|
00001a  6e58              LDR      r0,[r3,#0x64]         ;645
00001c  4308              ORRS     r0,r0,r1              ;645
00001e  e00f              B        |L6.64|
                  |L6.32|
000020  f10303a4          ADD      r3,r3,#0xa4           ;645
                  |L6.36|
;;;651        }
;;;652        /* Enable the selected FSMC_Bank4 interrupts */
;;;653        else
;;;654        {
;;;655          FSMC_Bank4->SR4 |= FSMC_IT;    
000024  6818              LDR      r0,[r3,#0]
000026  ea400001          ORR      r0,r0,r1
                  |L6.42|
00002a  6018              STR      r0,[r3,#0]
;;;656        }
;;;657      }
;;;658      else
;;;659      {
;;;660        /* Disable the selected FSMC_Bank2 interrupts */
;;;661        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;662        {
;;;663          
;;;664          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;665        }
;;;666        /* Disable the selected FSMC_Bank3 interrupts */
;;;667        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;668        {
;;;669          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;670        }
;;;671        /* Disable the selected FSMC_Bank4 interrupts */
;;;672        else
;;;673        {
;;;674          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;675        }
;;;676      }
;;;677    }
00002c  bd10              POP      {r4,pc}
                  |L6.46|
00002e  2810              CMP      r0,#0x10              ;661
000030  d004              BEQ      |L6.60|
000032  42a0              CMP      r0,r4                 ;667
000034  d106              BNE      |L6.68|
000036  f1030384          ADD      r3,r3,#0x84           ;667
00003a  e005              B        |L6.72|
                  |L6.60|
00003c  6e58              LDR      r0,[r3,#0x64]         ;664
00003e  4388              BICS     r0,r0,r1              ;664
                  |L6.64|
000040  6658              STR      r0,[r3,#0x64]         ;645
000042  bd10              POP      {r4,pc}
                  |L6.68|
000044  f10303a4          ADD      r3,r3,#0xa4
                  |L6.72|
000048  6818              LDR      r0,[r3,#0]            ;669
00004a  ea200001          BIC      r0,r0,r1              ;669
00004e  e7ec              B        |L6.42|
;;;678    
                          ENDP


                          AREA ||i.FSMC_NANDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDCmd PROC
;;;497      */
;;;498    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;499    {
;;;500      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;501      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;502      
;;;503      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L7.28|
;;;504      {
;;;505        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;506        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L7.20|
;;;507        {
;;;508          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
;;;509        }
;;;510        else
;;;511        {
;;;512          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400004          ORR      r0,r0,#4
000012  e009              B        |L7.40|
                  |L7.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;508
000016  f0400004          ORR      r0,r0,#4              ;508
00001a  e009              B        |L7.48|
                  |L7.28|
;;;513        }
;;;514      }
;;;515      else
;;;516      {
;;;517        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;518        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;519        {
;;;520          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
00001c  4905              LDR      r1,|L7.52|
00001e  2810              CMP      r0,#0x10              ;518
000020  d004              BEQ      |L7.44|
;;;521        }
;;;522        else
;;;523        {
;;;524          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L7.40|
000028  6010              STR      r0,[r2,#0]            ;512
;;;525        }
;;;526      }
;;;527    }
00002a  4770              BX       lr
                  |L7.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;520
00002e  4008              ANDS     r0,r0,r1              ;520
                  |L7.48|
000030  6610              STR      r0,[r2,#0x60]         ;508
000032  4770              BX       lr
;;;528    
                          ENDP

                  |L7.52|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_NANDDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDDeInit PROC
;;;127      */
;;;128    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000000  b510              PUSH     {r4,lr}
;;;129    {
;;;130      /* Check the parameter */
;;;131      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;132      
;;;133      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;134      {
;;;135        /* Set the FSMC_Bank2 registers to their reset values */
;;;136        FSMC_Bank2->PCR2 = 0x00000018;
000002  2318              MOVS     r3,#0x18
;;;137        FSMC_Bank2->SR2 = 0x00000040;
000004  2440              MOVS     r4,#0x40
000006  f04f4120          MOV      r1,#0xa0000000        ;136
;;;138        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
00000a  f04f32fc          MOV      r2,#0xfcfcfcfc
00000e  2810              CMP      r0,#0x10              ;133
000010  d005              BEQ      |L8.30|
;;;139        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;140      }
;;;141      /* FSMC_Bank3_NAND */  
;;;142      else
;;;143      {
;;;144        /* Set the FSMC_Bank3 registers to their reset values */
;;;145        FSMC_Bank3->PCR3 = 0x00000018;
000012  f8413f80          STR      r3,[r1,#0x80]!
;;;146        FSMC_Bank3->SR3 = 0x00000040;
000016  604c              STR      r4,[r1,#4]
;;;147        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
000018  608a              STR      r2,[r1,#8]
;;;148        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
00001a  60ca              STR      r2,[r1,#0xc]
;;;149      }  
;;;150    }
00001c  bd10              POP      {r4,pc}
                  |L8.30|
00001e  660b              STR      r3,[r1,#0x60]         ;136
000020  664c              STR      r4,[r1,#0x64]         ;137
000022  668a              STR      r2,[r1,#0x68]         ;138
000024  66ca              STR      r2,[r1,#0x6c]         ;139
000026  bd10              POP      {r4,pc}
;;;151    
                          ENDP


                          AREA ||i.FSMC_NANDECCCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NANDECCCmd PROC
;;;560      */
;;;561    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;562    {
;;;563      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;564      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;565      
;;;566      if (NewState != DISABLE)
000004  b151              CBZ      r1,|L9.28|
;;;567      {
;;;568        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;569        if(FSMC_Bank == FSMC_Bank2_NAND)
000006  2810              CMP      r0,#0x10
000008  d004              BEQ      |L9.20|
;;;570        {
;;;571          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
;;;572        }
;;;573        else
;;;574        {
;;;575          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
00000a  f8520f80          LDR      r0,[r2,#0x80]!
00000e  f0400040          ORR      r0,r0,#0x40
000012  e009              B        |L9.40|
                  |L9.20|
000014  6e10              LDR      r0,[r2,#0x60]         ;571
000016  f0400040          ORR      r0,r0,#0x40           ;571
00001a  e009              B        |L9.48|
                  |L9.28|
;;;576        }
;;;577      }
;;;578      else
;;;579      {
;;;580        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;581        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;582        {
;;;583          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00001c  4905              LDR      r1,|L9.52|
00001e  2810              CMP      r0,#0x10              ;581
000020  d004              BEQ      |L9.44|
;;;584        }
;;;585        else
;;;586        {
;;;587          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000022  f8520f80          LDR      r0,[r2,#0x80]!
000026  4008              ANDS     r0,r0,r1
                  |L9.40|
000028  6010              STR      r0,[r2,#0]            ;575
;;;588        }
;;;589      }
;;;590    }
00002a  4770              BX       lr
                  |L9.44|
00002c  6e10              LDR      r0,[r2,#0x60]         ;583
00002e  4008              ANDS     r0,r0,r1              ;583
                  |L9.48|
000030  6610              STR      r0,[r2,#0x60]         ;571
000032  4770              BX       lr
;;;591    
                          ENDP

                  |L9.52|
                          DCD      0x000fffbf

                          AREA ||i.FSMC_NANDInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDInit PROC
;;;259      */
;;;260    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;261    {
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;262      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;263        
;;;264      /* Check the parameters */
;;;265      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;266      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;267      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;268      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;269      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;270      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;271      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;272      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;273      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;274      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;275      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;276      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;277      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;278      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;279      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;280      
;;;281      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;282      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  ea412142          ORR      r1,r1,r2,LSL #9
000016  6982              LDR      r2,[r0,#0x18]
000018  ea413142          ORR      r1,r1,r2,LSL #13
00001c  f0410408          ORR      r4,r1,#8
;;;283                PCR_MemoryType_NAND |
;;;284                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;285                FSMC_NANDInitStruct->FSMC_ECC |
;;;286                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;287                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;288                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;289                
;;;290      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;291      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000020  69c1              LDR      r1,[r0,#0x1c]
000022  e9d12300          LDRD     r2,r3,[r1,#0]
000026  ea422203          ORR      r2,r2,r3,LSL #8
00002a  688b              LDR      r3,[r1,#8]
00002c  68c9              LDR      r1,[r1,#0xc]
00002e  041b              LSLS     r3,r3,#16
000030  ea436101          ORR      r1,r3,r1,LSL #24
000034  430a              ORRS     r2,r2,r1
;;;292                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;293                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;294                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;295                
;;;296      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;297      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000036  6a01              LDR      r1,[r0,#0x20]
000038  e9d13500          LDRD     r3,r5,[r1,#0]
00003c  ea432305          ORR      r3,r3,r5,LSL #8
000040  688d              LDR      r5,[r1,#8]
000042  68c9              LDR      r1,[r1,#0xc]
000044  042d              LSLS     r5,r5,#16
000046  ea456101          ORR      r1,r5,r1,LSL #24
00004a  430b              ORRS     r3,r3,r1
;;;298                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;299                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;300                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;301      
;;;302      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;303      {
;;;304        /* FSMC_Bank2_NAND registers configuration */
;;;305        FSMC_Bank2->PCR2 = tmppcr;
00004c  6801              LDR      r1,[r0,#0]
00004e  f04f4020          MOV      r0,#0xa0000000
000052  2910              CMP      r1,#0x10              ;302
000054  d004              BEQ      |L10.96|
;;;306        FSMC_Bank2->PMEM2 = tmppmem;
;;;307        FSMC_Bank2->PATT2 = tmppatt;
;;;308      }
;;;309      else
;;;310      {
;;;311        /* FSMC_Bank3_NAND registers configuration */
;;;312        FSMC_Bank3->PCR3 = tmppcr;
000056  f8404f80          STR      r4,[r0,#0x80]!
;;;313        FSMC_Bank3->PMEM3 = tmppmem;
00005a  6082              STR      r2,[r0,#8]
;;;314        FSMC_Bank3->PATT3 = tmppatt;
00005c  60c3              STR      r3,[r0,#0xc]
;;;315      }
;;;316    }
00005e  bd30              POP      {r4,r5,pc}
                  |L10.96|
000060  6604              STR      r4,[r0,#0x60]         ;305
000062  6682              STR      r2,[r0,#0x68]         ;306
000064  66c3              STR      r3,[r0,#0x6c]         ;307
000066  bd30              POP      {r4,r5,pc}
;;;317    
                          ENDP


                          AREA ||i.FSMC_NANDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NANDStructInit PROC
;;;414      */
;;;415    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000000  2110              MOVS     r1,#0x10
;;;416    { 
;;;417      /* Reset NAND Init structure parameters values */
;;;418      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;419      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000002  6001              STR      r1,[r0,#0]
000004  2100              MOVS     r1,#0
;;;420      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000006  6041              STR      r1,[r0,#4]
;;;421      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000008  6081              STR      r1,[r0,#8]
;;;422      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00000a  60c1              STR      r1,[r0,#0xc]
;;;423      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00000c  6101              STR      r1,[r0,#0x10]
;;;424      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00000e  6141              STR      r1,[r0,#0x14]
;;;425      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000010  6181              STR      r1,[r0,#0x18]
000012  69c2              LDR      r2,[r0,#0x1c]
000014  21fc              MOVS     r1,#0xfc
;;;426      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000016  6011              STR      r1,[r2,#0]
000018  69c2              LDR      r2,[r0,#0x1c]
;;;427      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00001a  6051              STR      r1,[r2,#4]
00001c  69c2              LDR      r2,[r0,#0x1c]
;;;428      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00001e  6091              STR      r1,[r2,#8]
000020  69c2              LDR      r2,[r0,#0x1c]
;;;429      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000022  60d1              STR      r1,[r2,#0xc]
000024  6a02              LDR      r2,[r0,#0x20]
;;;430      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000026  6011              STR      r1,[r2,#0]
000028  6a02              LDR      r2,[r0,#0x20]
;;;431      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00002a  6051              STR      r1,[r2,#4]
00002c  6a02              LDR      r2,[r0,#0x20]
;;;432      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00002e  6091              STR      r1,[r2,#8]
000030  6a00              LDR      r0,[r0,#0x20]
000032  60c1              STR      r1,[r0,#0xc]
;;;433    }
000034  4770              BX       lr
;;;434    
                          ENDP


                          AREA ||i.FSMC_NORSRAMCmd||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMCmd PROC
;;;471      */
;;;472    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
000000  f04f4220          MOV      r2,#0xa0000000
;;;473    {
;;;474      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;475      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;476      
;;;477      if (NewState != DISABLE)
;;;478      {
;;;479        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;480        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
000004  eb020080          ADD      r0,r2,r0,LSL #2
000008  2900              CMP      r1,#0                 ;477
;;;481      }
;;;482      else
;;;483      {
;;;484        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;485        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
00000a  6801              LDR      r1,[r0,#0]
00000c  d002              BEQ      |L12.20|
00000e  f0410101          ORR      r1,r1,#1              ;480
000012  e001              B        |L12.24|
                  |L12.20|
000014  4a01              LDR      r2,|L12.28|
000016  4011              ANDS     r1,r1,r2
                  |L12.24|
000018  6001              STR      r1,[r0,#0]            ;480
;;;486      }
;;;487    }
00001a  4770              BX       lr
;;;488    
                          ENDP

                  |L12.28|
                          DCD      0x000ffffe

                          AREA ||i.FSMC_NORSRAMDeInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMDeInit PROC
;;;100      */
;;;101    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  f04f4220          MOV      r2,#0xa0000000
;;;102    {
;;;103      /* Check the parameter */
;;;104      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;105      
;;;106      /* FSMC_Bank1_NORSRAM1 */
;;;107      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;108      {
;;;109        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;110      }
;;;111      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;112      else
;;;113      {   
;;;114        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000004  eb020180          ADD      r1,r2,r0,LSL #2
000008  b140              CBZ      r0,|L13.28|
00000a  f24300d2          MOV      r0,#0x30d2
00000e  6008              STR      r0,[r1,#0]
                  |L13.16|
;;;115      }
;;;116      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
000010  f06f4070          MVN      r0,#0xf0000000
000014  6048              STR      r0,[r1,#4]
;;;117      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000016  f8c10104          STR      r0,[r1,#0x104]
;;;118    }
00001a  4770              BX       lr
                  |L13.28|
00001c  f24300db          MOV      r0,#0x30db            ;109
000020  6010              STR      r0,[r2,#0]            ;109
000022  e7f5              B        |L13.16|
;;;119    
                          ENDP


                          AREA ||i.FSMC_NORSRAMInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMInit PROC
;;;174      */
;;;175    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;176    { 
000002  e9d01201          LDRD     r1,r2,[r0,#4]
;;;177      /* Check the parameters */
;;;178      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;179      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;180      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;181      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;182      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;183      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;184      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;185      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;186      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;187      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;188      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;189      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;190      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;191      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;192      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;193      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;194      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;195      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;196      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;197      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;198      
;;;199      /* Bank1 NOR/SRAM control register configuration */ 
;;;200      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
000006  4311              ORRS     r1,r1,r2
000008  e9d02303          LDRD     r2,r3,[r0,#0xc]
00000c  431a              ORRS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6942              LDR      r2,[r0,#0x14]
000012  6803              LDR      r3,[r0,#0]
000014  4311              ORRS     r1,r1,r2
000016  6982              LDR      r2,[r0,#0x18]
000018  4311              ORRS     r1,r1,r2
00001a  69c2              LDR      r2,[r0,#0x1c]
00001c  4311              ORRS     r1,r1,r2
00001e  6a02              LDR      r2,[r0,#0x20]
000020  4311              ORRS     r1,r1,r2
000022  6a42              LDR      r2,[r0,#0x24]
000024  4311              ORRS     r1,r1,r2
000026  6a82              LDR      r2,[r0,#0x28]
000028  4311              ORRS     r1,r1,r2
00002a  6ac2              LDR      r2,[r0,#0x2c]
00002c  4311              ORRS     r1,r1,r2
00002e  6b02              LDR      r2,[r0,#0x30]
000030  4311              ORRS     r1,r1,r2
000032  f04f4220          MOV      r2,#0xa0000000
000036  f8421023          STR      r1,[r2,r3,LSL #2]
;;;201                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;202                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;203                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;204                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;205                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;206                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;209                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;211                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;212                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;213    
;;;214      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
00003a  6881              LDR      r1,[r0,#8]
00003c  2908              CMP      r1,#8
00003e  d106              BNE      |L14.78|
;;;215      {
;;;216        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
000040  6801              LDR      r1,[r0,#0]
000042  eb020181          ADD      r1,r2,r1,LSL #2
000046  680b              LDR      r3,[r1,#0]
000048  f0430340          ORR      r3,r3,#0x40
00004c  600b              STR      r3,[r1,#0]
                  |L14.78|
;;;217      }
;;;218      
;;;219      /* Bank1 NOR/SRAM timing register configuration */
;;;220      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
00004e  6b41              LDR      r1,[r0,#0x34]
000050  e9d13400          LDRD     r3,r4,[r1,#0]
000054  ea431304          ORR      r3,r3,r4,LSL #4
000058  688c              LDR      r4,[r1,#8]
00005a  68cd              LDR      r5,[r1,#0xc]
00005c  0224              LSLS     r4,r4,#8
00005e  ea444405          ORR      r4,r4,r5,LSL #16
000062  4323              ORRS     r3,r3,r4
000064  690c              LDR      r4,[r1,#0x10]
000066  ea435304          ORR      r3,r3,r4,LSL #20
00006a  694c              LDR      r4,[r1,#0x14]
00006c  6989              LDR      r1,[r1,#0x18]
00006e  ea436304          ORR      r3,r3,r4,LSL #24
000072  430b              ORRS     r3,r3,r1
000074  6801              LDR      r1,[r0,#0]
000076  eb020181          ADD      r1,r2,r1,LSL #2
00007a  604b              STR      r3,[r1,#4]
;;;221                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;222                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;223                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;227                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;228                
;;;229        
;;;230      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;231      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
00007c  6ac1              LDR      r1,[r0,#0x2c]
00007e  f5b14f80          CMP      r1,#0x4000
000082  d007              BEQ      |L14.148|
;;;232      {
;;;233        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;234        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;235        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;236        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;237        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;238        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;239        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;240                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;241                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;242                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;243                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;244                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;245                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;246      }
;;;247      else
;;;248      {
;;;249        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
000084  6800              LDR      r0,[r0,#0]
000086  f06f4170          MVN      r1,#0xf0000000
00008a  eb020080          ADD      r0,r2,r0,LSL #2
00008e  f8c01104          STR      r1,[r0,#0x104]
;;;250      }
;;;251    }
000092  bd30              POP      {r4,r5,pc}
                  |L14.148|
000094  6b81              LDR      r1,[r0,#0x38]         ;239
000096  6800              LDR      r0,[r0,#0]            ;239
000098  e9d13400          LDRD     r3,r4,[r1,#0]         ;239
00009c  ea431304          ORR      r3,r3,r4,LSL #4       ;239
0000a0  688c              LDR      r4,[r1,#8]            ;239
0000a2  690d              LDR      r5,[r1,#0x10]         ;239
0000a4  0224              LSLS     r4,r4,#8              ;239
0000a6  ea445405          ORR      r4,r4,r5,LSL #20      ;239
0000aa  4323              ORRS     r3,r3,r4              ;239
0000ac  694c              LDR      r4,[r1,#0x14]         ;239
0000ae  6989              LDR      r1,[r1,#0x18]         ;239
0000b0  ea436304          ORR      r3,r3,r4,LSL #24      ;239
0000b4  eb020080          ADD      r0,r2,r0,LSL #2       ;239
0000b8  430b              ORRS     r3,r3,r1              ;239
0000ba  f8c03104          STR      r3,[r0,#0x104]        ;239
0000be  bd30              POP      {r4,r5,pc}
;;;252    
                          ENDP


                          AREA ||i.FSMC_NORSRAMStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_NORSRAMStructInit PROC
;;;376      */
;;;377    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000000  b510              PUSH     {r4,lr}
;;;378    {  
;;;379      /* Reset NOR/SRAM Init structure parameters values */
;;;380      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000002  2100              MOVS     r1,#0
;;;381      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000004  2202              MOVS     r2,#2
000006  e9c01200          STRD     r1,r2,[r0,#0]
;;;382      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;383      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
00000a  6081              STR      r1,[r0,#8]
;;;384      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00000c  60c1              STR      r1,[r0,#0xc]
;;;385      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00000e  6101              STR      r1,[r0,#0x10]
;;;386      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000010  6141              STR      r1,[r0,#0x14]
;;;387      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000012  6181              STR      r1,[r0,#0x18]
;;;388      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;389      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000014  02d2              LSLS     r2,r2,#11
000016  61c1              STR      r1,[r0,#0x1c]
000018  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;390      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00001c  0052              LSLS     r2,r2,#1
00001e  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;391      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;392      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;393      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000022  6301              STR      r1,[r0,#0x30]
000024  6b43              LDR      r3,[r0,#0x34]
000026  220f              MOVS     r2,#0xf
;;;394      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000028  601a              STR      r2,[r3,#0]
00002a  6b43              LDR      r3,[r0,#0x34]
;;;395      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00002c  605a              STR      r2,[r3,#4]
00002e  6b44              LDR      r4,[r0,#0x34]
000030  23ff              MOVS     r3,#0xff
;;;396      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000032  60a3              STR      r3,[r4,#8]
000034  6b44              LDR      r4,[r0,#0x34]
;;;397      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000036  60e2              STR      r2,[r4,#0xc]
000038  6b44              LDR      r4,[r0,#0x34]
;;;398      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
00003a  6122              STR      r2,[r4,#0x10]
00003c  6b44              LDR      r4,[r0,#0x34]
;;;399      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00003e  6162              STR      r2,[r4,#0x14]
000040  6b44              LDR      r4,[r0,#0x34]
;;;400      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000042  61a1              STR      r1,[r4,#0x18]
000044  6b84              LDR      r4,[r0,#0x38]
;;;401      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000046  6022              STR      r2,[r4,#0]
000048  6b84              LDR      r4,[r0,#0x38]
;;;402      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00004a  6062              STR      r2,[r4,#4]
00004c  6b84              LDR      r4,[r0,#0x38]
;;;403      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00004e  60a3              STR      r3,[r4,#8]
000050  6b83              LDR      r3,[r0,#0x38]
;;;404      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000052  60da              STR      r2,[r3,#0xc]
000054  6b83              LDR      r3,[r0,#0x38]
;;;405      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000056  611a              STR      r2,[r3,#0x10]
000058  6b83              LDR      r3,[r0,#0x38]
;;;406      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
00005a  615a              STR      r2,[r3,#0x14]
00005c  6b80              LDR      r0,[r0,#0x38]
00005e  6181              STR      r1,[r0,#0x18]
;;;407    }
000060  bd10              POP      {r4,pc}
;;;408    
                          ENDP


                          AREA ||i.FSMC_PCCARDCmd||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDCmd PROC
;;;534      */
;;;535    void FSMC_PCCARDCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L16.24|
;;;536    {
;;;537      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;538      
;;;539      if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;540      {
;;;541        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;542        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
;;;543      }
;;;544      else
;;;545      {
;;;546        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;547        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L16.14|
000008  f0400004          ORR      r0,r0,#4              ;542
00000c  e001              B        |L16.18|
                  |L16.14|
00000e  4a03              LDR      r2,|L16.28|
000010  4010              ANDS     r0,r0,r2
                  |L16.18|
000012  6008              STR      r0,[r1,#0]            ;542
;;;548      }
;;;549    }
000014  4770              BX       lr
;;;550    
                          ENDP

000016  0000              DCW      0x0000
                  |L16.24|
                          DCD      0xa00000a0
                  |L16.28|
                          DCD      0x000ffffb

                          AREA ||i.FSMC_PCCARDDeInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDDeInit PROC
;;;156      */
;;;157    void FSMC_PCCARDDeInit(void)
000000  4805              LDR      r0,|L17.24|
;;;158    {
;;;159      /* Set the FSMC_Bank4 registers to their reset values */
;;;160      FSMC_Bank4->PCR4 = 0x00000018; 
000002  2118              MOVS     r1,#0x18
000004  6001              STR      r1,[r0,#0]
;;;161      FSMC_Bank4->SR4 = 0x00000000;	
000006  f04f0100          MOV      r1,#0
00000a  6041              STR      r1,[r0,#4]
;;;162      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00000c  f04f31fc          MOV      r1,#0xfcfcfcfc
000010  6081              STR      r1,[r0,#8]
;;;163      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000012  60c1              STR      r1,[r0,#0xc]
;;;164      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000014  6101              STR      r1,[r0,#0x10]
;;;165    }
000016  4770              BX       lr
;;;166    
                          ENDP

                  |L17.24|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDInit||, CODE, READONLY, ALIGN=2

                  FSMC_PCCARDInit PROC
;;;324      */
;;;325    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  b510              PUSH     {r4,lr}
;;;326    {
000002  e9d01200          LDRD     r1,r2,[r0,#0]
;;;327      /* Check the parameters */
;;;328      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;329      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;330      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;331     
;;;332      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;333      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;334      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;335      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;336      
;;;337      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;338      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;339      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;340      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;341      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;342      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;343      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;344      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;345      
;;;346      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;347      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
000006  ea412142          ORR      r1,r1,r2,LSL #9
00000a  6882              LDR      r2,[r0,#8]
00000c  2310              MOVS     r3,#0x10
00000e  ea433242          ORR      r2,r3,r2,LSL #13
000012  4311              ORRS     r1,r1,r2
000014  4a16              LDR      r2,|L18.112|
000016  6011              STR      r1,[r2,#0]
;;;348                         FSMC_MemoryDataWidth_16b |  
;;;349                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;350                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;351                
;;;352      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;353      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000018  68c1              LDR      r1,[r0,#0xc]
00001a  e9d13400          LDRD     r3,r4,[r1,#0]
00001e  ea432304          ORR      r3,r3,r4,LSL #8
000022  688c              LDR      r4,[r1,#8]
000024  68c9              LDR      r1,[r1,#0xc]
000026  ea4f4404          LSL      r4,r4,#16
00002a  ea446101          ORR      r1,r4,r1,LSL #24
00002e  ea430301          ORR      r3,r3,r1
000032  6093              STR      r3,[r2,#8]
;;;354                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;355                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;356                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;357                
;;;358      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;359      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000034  6901              LDR      r1,[r0,#0x10]
000036  e9d13400          LDRD     r3,r4,[r1,#0]
00003a  ea432304          ORR      r3,r3,r4,LSL #8
00003e  688c              LDR      r4,[r1,#8]
000040  68c9              LDR      r1,[r1,#0xc]
000042  ea4f4404          LSL      r4,r4,#16
000046  ea446101          ORR      r1,r4,r1,LSL #24
00004a  ea430301          ORR      r3,r3,r1
00004e  60d3              STR      r3,[r2,#0xc]
;;;360                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;361                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;362                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;363                
;;;364      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;365      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
000050  6940              LDR      r0,[r0,#0x14]
000052  e9d01300          LDRD     r1,r3,[r0,#0]
000056  ea412103          ORR      r1,r1,r3,LSL #8
00005a  6883              LDR      r3,[r0,#8]
00005c  68c0              LDR      r0,[r0,#0xc]
00005e  ea4f4303          LSL      r3,r3,#16
000062  ea436000          ORR      r0,r3,r0,LSL #24
000066  ea410100          ORR      r1,r1,r0
00006a  6111              STR      r1,[r2,#0x10]
;;;366                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;367                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;368                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;369    }
00006c  bd10              POP      {r4,pc}
;;;370    
                          ENDP

00006e  0000              DCW      0x0000
                  |L18.112|
                          DCD      0xa00000a0

                          AREA ||i.FSMC_PCCARDStructInit||, CODE, READONLY, ALIGN=1

                  FSMC_PCCARDStructInit PROC
;;;440      */
;;;441    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000000  2100              MOVS     r1,#0
;;;442    {
;;;443      /* Reset PCCARD Init structure parameters values */
;;;444      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;445      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000002  6001              STR      r1,[r0,#0]
;;;446      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
000004  6041              STR      r1,[r0,#4]
;;;447      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000006  6081              STR      r1,[r0,#8]
000008  68c2              LDR      r2,[r0,#0xc]
00000a  21fc              MOVS     r1,#0xfc
;;;448      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00000c  6011              STR      r1,[r2,#0]
00000e  68c2              LDR      r2,[r0,#0xc]
;;;449      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000010  6051              STR      r1,[r2,#4]
000012  68c2              LDR      r2,[r0,#0xc]
;;;450      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000014  6091              STR      r1,[r2,#8]
000016  68c2              LDR      r2,[r0,#0xc]
;;;451      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000018  60d1              STR      r1,[r2,#0xc]
00001a  6902              LDR      r2,[r0,#0x10]
;;;452      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00001c  6011              STR      r1,[r2,#0]
00001e  6902              LDR      r2,[r0,#0x10]
;;;453      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000020  6051              STR      r1,[r2,#4]
000022  6902              LDR      r2,[r0,#0x10]
;;;454      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
000024  6091              STR      r1,[r2,#8]
000026  6902              LDR      r2,[r0,#0x10]
;;;455      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000028  60d1              STR      r1,[r2,#0xc]
00002a  6942              LDR      r2,[r0,#0x14]
;;;456      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
00002c  6011              STR      r1,[r2,#0]
00002e  6942              LDR      r2,[r0,#0x14]
;;;457      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
000030  6051              STR      r1,[r2,#4]
000032  6942              LDR      r2,[r0,#0x14]
;;;458      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
000034  6091              STR      r1,[r2,#8]
000036  6940              LDR      r0,[r0,#0x14]
000038  60c1              STR      r1,[r0,#0xc]
;;;459    }
00003a  4770              BX       lr
;;;460    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_fsmc.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_fsmc_c_2e710976____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_stm32f10x_fsmc_c_2e710976____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___16_stm32f10x_fsmc_c_2e710976____REVSH|
#line 128
|__asm___16_stm32f10x_fsmc_c_2e710976____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
