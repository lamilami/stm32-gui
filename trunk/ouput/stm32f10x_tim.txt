; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\stm32f10x_tim.o --depend=.\ouput\stm32f10x_tim.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\stm32f10x_tim.crf Source\FWLib\src\stm32f10x_tim.c]
                          THUMB

                          AREA ||i.TI1_Config||, CODE, READONLY, ALIGN=2

                  TI1_Config PROC
;;;2698     */
;;;2699   static void TI1_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b530              PUSH     {r4,r5,lr}
;;;2700                          uint16_t TIM_ICFilter)
;;;2701   {
;;;2702     uint16_t tmpccmr1 = 0, tmpccer = 0;
;;;2703     /* Disable the Channel 1: Reset the CC1E Bit */
;;;2704     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC1E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240401          BIC      r4,r4,#1
000008  8404              STRH     r4,[r0,#0x20]
;;;2705     tmpccmr1 = TIMx->CCMR1;
00000a  8b05              LDRH     r5,[r0,#0x18]
;;;2706     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2707     /* Select the Input and set the filter */
;;;2708     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC1F)));
;;;2709     tmpccmr1 |= (uint16_t)(TIM_ICSelection | (uint16_t)(TIM_ICFilter << (uint16_t)4));
00000e  051b              LSLS     r3,r3,#20
000010  ea424313          ORR      r3,r2,r3,LSR #16
000014  f02505f3          BIC      r5,r5,#0xf3           ;2708
;;;2710     
;;;2711     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000018  4a0e              LDR      r2,|L1.84|
00001a  432b              ORRS     r3,r3,r5              ;2709
00001c  4290              CMP      r0,r2
00001e  d00e              BEQ      |L1.62|
000020  4a0d              LDR      r2,|L1.88|
000022  4290              CMP      r0,r2
000024  d00b              BEQ      |L1.62|
000026  f1b04f80          CMP      r0,#0x40000000
00002a  d008              BEQ      |L1.62|
00002c  4a0b              LDR      r2,|L1.92|
00002e  4290              CMP      r0,r2
000030  d005              BEQ      |L1.62|
;;;2712        (TIMx == TIM4) ||(TIMx == TIM5))
000032  4a0b              LDR      r2,|L1.96|
000034  4290              CMP      r0,r2
000036  d002              BEQ      |L1.62|
000038  4a0a              LDR      r2,|L1.100|
00003a  4290              CMP      r0,r2
00003c  d102              BNE      |L1.68|
                  |L1.62|
;;;2713     {
;;;2714       /* Select the Polarity and set the CC1E Bit */
;;;2715       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P));
00003e  f0240202          BIC      r2,r4,#2
;;;2716       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000042  e001              B        |L1.72|
                  |L1.68|
;;;2717     }
;;;2718     else
;;;2719     {
;;;2720       /* Select the Polarity and set the CC1E Bit */
;;;2721       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC1P | TIM_CCER_CC1NP));
000044  f024020a          BIC      r2,r4,#0xa
                  |L1.72|
;;;2722       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC1E);
000048  430a              ORRS     r2,r2,r1
00004a  f0420101          ORR      r1,r2,#1
;;;2723     }
;;;2724   
;;;2725     /* Write to TIMx CCMR1 and CCER registers */
;;;2726     TIMx->CCMR1 = tmpccmr1;
00004e  8303              STRH     r3,[r0,#0x18]
;;;2727     TIMx->CCER = tmpccer;
000050  8401              STRH     r1,[r0,#0x20]
;;;2728   }
000052  bd30              POP      {r4,r5,pc}
;;;2729   
                          ENDP

                  |L1.84|
                          DCD      0x40012c00
                  |L1.88|
                          DCD      0x40013400
                  |L1.92|
                          DCD      0x40000400
                  |L1.96|
                          DCD      0x40000800
                  |L1.100|
                          DCD      0x40000c00

                          AREA ||i.TI2_Config||, CODE, READONLY, ALIGN=2

                  TI2_Config PROC
;;;2745     */
;;;2746   static void TI2_Config(TIM_TypeDef* TIMx, uint16_t TIM_ICPolarity, uint16_t TIM_ICSelection,
000000  b570              PUSH     {r4-r6,lr}
;;;2747                          uint16_t TIM_ICFilter)
;;;2748   {
;;;2749     uint16_t tmpccmr1 = 0, tmpccer = 0, tmp = 0;
;;;2750     /* Disable the Channel 2: Reset the CC2E Bit */
;;;2751     TIMx->CCER &= (uint16_t)~((uint16_t)TIM_CCER_CC2E);
000002  8c04              LDRH     r4,[r0,#0x20]
000004  f0240410          BIC      r4,r4,#0x10
000008  8404              STRH     r4,[r0,#0x20]
;;;2752     tmpccmr1 = TIMx->CCMR1;
00000a  8b06              LDRH     r6,[r0,#0x18]
;;;2753     tmpccer = TIMx->CCER;
00000c  8c04              LDRH     r4,[r0,#0x20]
;;;2754     tmp = (uint16_t)(TIM_ICPolarity << 4);
;;;2755     /* Select the Input and set the filter */
;;;2756     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC2S)) & ((uint16_t)~((uint16_t)TIM_CCMR1_IC2F)));
00000e  f4264673          BIC      r6,r6,#0xf300
;;;2757     tmpccmr1 |= (uint16_t)(TIM_ICFilter << 12);
000012  071b              LSLS     r3,r3,#28
000014  ea464313          ORR      r3,r6,r3,LSR #16
;;;2758     tmpccmr1 |= (uint16_t)(TIM_ICSelection << 8);
000018  0612              LSLS     r2,r2,#24
00001a  ea434212          ORR      r2,r3,r2,LSR #16
00001e  050d              LSLS     r5,r1,#20             ;2754
;;;2759     
;;;2760     if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
000020  4b10              LDR      r3,|L2.100|
000022  0c2d              LSRS     r5,r5,#16             ;2754
000024  4298              CMP      r0,r3
000026  d00e              BEQ      |L2.70|
000028  4b0f              LDR      r3,|L2.104|
00002a  4298              CMP      r0,r3
00002c  d00b              BEQ      |L2.70|
00002e  f1b04f80          CMP      r0,#0x40000000
000032  d008              BEQ      |L2.70|
000034  4b0d              LDR      r3,|L2.108|
000036  4298              CMP      r0,r3
000038  d005              BEQ      |L2.70|
;;;2761        (TIMx == TIM4) ||(TIMx == TIM5))
00003a  4b0d              LDR      r3,|L2.112|
00003c  4298              CMP      r0,r3
00003e  d002              BEQ      |L2.70|
000040  4b0c              LDR      r3,|L2.116|
000042  4298              CMP      r0,r3
000044  d105              BNE      |L2.82|
                  |L2.70|
;;;2762     {
;;;2763       /* Select the Polarity and set the CC2E Bit */
;;;2764       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P));
000046  f0240120          BIC      r1,r4,#0x20
;;;2765       tmpccer |=  (uint16_t)(tmp | (uint16_t)TIM_CCER_CC2E);
00004a  4329              ORRS     r1,r1,r5
00004c  f0410110          ORR      r1,r1,#0x10
000050  e004              B        |L2.92|
                  |L2.82|
;;;2766     }
;;;2767     else
;;;2768     {
;;;2769       /* Select the Polarity and set the CC2E Bit */
;;;2770       tmpccer &= (uint16_t)~((uint16_t)(TIM_CCER_CC2P | TIM_CCER_CC2NP));
000052  f02403a0          BIC      r3,r4,#0xa0
;;;2771       tmpccer |= (uint16_t)(TIM_ICPolarity | (uint16_t)TIM_CCER_CC2E);
000056  430b              ORRS     r3,r3,r1
000058  f0430110          ORR      r1,r3,#0x10
                  |L2.92|
;;;2772     }
;;;2773     
;;;2774     /* Write to TIMx CCMR1 and CCER registers */
;;;2775     TIMx->CCMR1 = tmpccmr1 ;
00005c  8302              STRH     r2,[r0,#0x18]
;;;2776     TIMx->CCER = tmpccer;
00005e  8401              STRH     r1,[r0,#0x20]
;;;2777   }
000060  bd70              POP      {r4-r6,pc}
;;;2778   
                          ENDP

000062  0000              DCW      0x0000
                  |L2.100|
                          DCD      0x40012c00
                  |L2.104|
                          DCD      0x40013400
                  |L2.108|
                          DCD      0x40000400
                  |L2.112|
                          DCD      0x40000800
                  |L2.116|
                          DCD      0x40000c00

                          AREA ||i.TIM_ARRPreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_ARRPreloadConfig PROC
;;;1406     */
;;;1407   void TIM_ARRPreloadConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1408   {
;;;1409     /* Check the parameters */
;;;1410     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1411     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1412     if (NewState != DISABLE)
;;;1413     {
;;;1414       /* Set the ARR Preload Bit */
;;;1415       TIMx->CR1 |= TIM_CR1_ARPE;
;;;1416     }
;;;1417     else
;;;1418     {
;;;1419       /* Reset the ARR Preload Bit */
;;;1420       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_ARPE);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L3.12|
000006  f0410180          ORR      r1,r1,#0x80           ;1415
00000a  e001              B        |L3.16|
                  |L3.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L3.16|
000010  8001              STRH     r1,[r0,#0]            ;1415
;;;1421     }
;;;1422   }
000012  4770              BX       lr
;;;1423   
                          ENDP


                          AREA ||i.TIM_BDTRConfig||, CODE, READONLY, ALIGN=1

                  TIM_BDTRConfig PROC
;;;709      */
;;;710    void TIM_BDTRConfig(TIM_TypeDef* TIMx, TIM_BDTRInitTypeDef *TIM_BDTRInitStruct)
000000  b510              PUSH     {r4,lr}
;;;711    {
;;;712      /* Check the parameters */
;;;713      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;714      assert_param(IS_TIM_OSSR_STATE(TIM_BDTRInitStruct->TIM_OSSRState));
;;;715      assert_param(IS_TIM_OSSI_STATE(TIM_BDTRInitStruct->TIM_OSSIState));
;;;716      assert_param(IS_TIM_LOCK_LEVEL(TIM_BDTRInitStruct->TIM_LOCKLevel));
;;;717      assert_param(IS_TIM_BREAK_STATE(TIM_BDTRInitStruct->TIM_Break));
;;;718      assert_param(IS_TIM_BREAK_POLARITY(TIM_BDTRInitStruct->TIM_BreakPolarity));
;;;719      assert_param(IS_TIM_AUTOMATIC_OUTPUT_STATE(TIM_BDTRInitStruct->TIM_AutomaticOutput));
;;;720      /* Set the Lock level, the Break enable Bit and the Ploarity, the OSSR State,
;;;721         the OSSI State, the dead time value and the Automatic Output Enable Bit */
;;;722      TIMx->BDTR = (uint32_t)TIM_BDTRInitStruct->TIM_OSSRState | TIM_BDTRInitStruct->TIM_OSSIState |
000002  880a              LDRH     r2,[r1,#0]
000004  884b              LDRH     r3,[r1,#2]
000006  88cc              LDRH     r4,[r1,#6]
000008  431a              ORRS     r2,r2,r3
00000a  888b              LDRH     r3,[r1,#4]
00000c  4323              ORRS     r3,r3,r4
00000e  431a              ORRS     r2,r2,r3
000010  890b              LDRH     r3,[r1,#8]
000012  431a              ORRS     r2,r2,r3
000014  894b              LDRH     r3,[r1,#0xa]
000016  8989              LDRH     r1,[r1,#0xc]
000018  431a              ORRS     r2,r2,r3
00001a  430a              ORRS     r2,r2,r1
00001c  f8a02044          STRH     r2,[r0,#0x44]
;;;723                 TIM_BDTRInitStruct->TIM_LOCKLevel | TIM_BDTRInitStruct->TIM_DeadTime |
;;;724                 TIM_BDTRInitStruct->TIM_Break | TIM_BDTRInitStruct->TIM_BreakPolarity |
;;;725                 TIM_BDTRInitStruct->TIM_AutomaticOutput;
;;;726    }
000020  bd10              POP      {r4,pc}
;;;727    
                          ENDP


                          AREA ||i.TIM_BDTRStructInit||, CODE, READONLY, ALIGN=1

                  TIM_BDTRStructInit PROC
;;;784      */
;;;785    void TIM_BDTRStructInit(TIM_BDTRInitTypeDef* TIM_BDTRInitStruct)
000000  2100              MOVS     r1,#0
;;;786    {
;;;787      /* Set the default configuration */
;;;788      TIM_BDTRInitStruct->TIM_OSSRState = TIM_OSSRState_Disable;
000002  8001              STRH     r1,[r0,#0]
;;;789      TIM_BDTRInitStruct->TIM_OSSIState = TIM_OSSIState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;790      TIM_BDTRInitStruct->TIM_LOCKLevel = TIM_LOCKLevel_OFF;
000006  8081              STRH     r1,[r0,#4]
;;;791      TIM_BDTRInitStruct->TIM_DeadTime = 0x00;
000008  80c1              STRH     r1,[r0,#6]
;;;792      TIM_BDTRInitStruct->TIM_Break = TIM_Break_Disable;
00000a  8101              STRH     r1,[r0,#8]
;;;793      TIM_BDTRInitStruct->TIM_BreakPolarity = TIM_BreakPolarity_Low;
00000c  8141              STRH     r1,[r0,#0xa]
;;;794      TIM_BDTRInitStruct->TIM_AutomaticOutput = TIM_AutomaticOutput_Disable;
00000e  8181              STRH     r1,[r0,#0xc]
;;;795    }
000010  4770              BX       lr
;;;796    
                          ENDP


                          AREA ||i.TIM_CCPreloadControl||, CODE, READONLY, ALIGN=1

                  TIM_CCPreloadControl PROC
;;;1480     */
;;;1481   void TIM_CCPreloadControl(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1482   { 
;;;1483     /* Check the parameters */
;;;1484     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1485     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1486     if (NewState != DISABLE)
;;;1487     {
;;;1488       /* Set the CCPC Bit */
;;;1489       TIMx->CR2 |= TIM_CR2_CCPC;
;;;1490     }
;;;1491     else
;;;1492     {
;;;1493       /* Reset the CCPC Bit */
;;;1494       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCPC);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L6.12|
000006  f0410101          ORR      r1,r1,#1              ;1489
00000a  e001              B        |L6.16|
                  |L6.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L6.16|
000010  8081              STRH     r1,[r0,#4]            ;1489
;;;1495     }
;;;1496   }
000012  4770              BX       lr
;;;1497   
                          ENDP


                          AREA ||i.TIM_CCxCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxCmd PROC
;;;1971     */
;;;1972   void TIM_CCxCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCx)
000000  b510              PUSH     {r4,lr}
;;;1973   {
;;;1974     uint16_t tmp = 0;
;;;1975   
;;;1976     /* Check the parameters */
;;;1977     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1978     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;1979     assert_param(IS_TIM_CCX(TIM_CCx));
;;;1980   
;;;1981     tmp = CCER_CCE_Set << TIM_Channel;
000002  2301              MOVS     r3,#1
;;;1982   
;;;1983     /* Reset the CCxE Bit */
;;;1984     TIMx->CCER &= (uint16_t)~ tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;1981
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;1985   
;;;1986     /* Set or reset the CCxE Bit */ 
;;;1987     TIMx->CCER |=  (uint16_t)(TIM_CCx << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;1988   }
000014  bd10              POP      {r4,pc}
;;;1989   
                          ENDP


                          AREA ||i.TIM_CCxNCmd||, CODE, READONLY, ALIGN=1

                  TIM_CCxNCmd PROC
;;;2001     */
;;;2002   void TIM_CCxNCmd(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_CCxN)
000000  b510              PUSH     {r4,lr}
;;;2003   {
;;;2004     uint16_t tmp = 0;
;;;2005   
;;;2006     /* Check the parameters */
;;;2007     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;2008     assert_param(IS_TIM_COMPLEMENTARY_CHANNEL(TIM_Channel));
;;;2009     assert_param(IS_TIM_CCXN(TIM_CCxN));
;;;2010   
;;;2011     tmp = CCER_CCNE_Set << TIM_Channel;
000002  2304              MOVS     r3,#4
;;;2012   
;;;2013     /* Reset the CCxNE Bit */
;;;2014     TIMx->CCER &= (uint16_t) ~tmp;
000004  8c04              LDRH     r4,[r0,#0x20]
000006  408b              LSLS     r3,r3,r1              ;2011
000008  439c              BICS     r4,r4,r3
00000a  8404              STRH     r4,[r0,#0x20]
;;;2015   
;;;2016     /* Set or reset the CCxNE Bit */ 
;;;2017     TIMx->CCER |=  (uint16_t)(TIM_CCxN << TIM_Channel);
00000c  8c03              LDRH     r3,[r0,#0x20]
00000e  408a              LSLS     r2,r2,r1
000010  4313              ORRS     r3,r3,r2
000012  8403              STRH     r3,[r0,#0x20]
;;;2018   }
000014  bd10              POP      {r4,pc}
;;;2019   
                          ENDP


                          AREA ||i.TIM_ClearFlag||, CODE, READONLY, ALIGN=1

                  TIM_ClearFlag PROC
;;;2597     */
;;;2598   void TIM_ClearFlag(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  43c9              MVNS     r1,r1
;;;2599   {  
;;;2600     /* Check the parameters */
;;;2601     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2602     assert_param(IS_TIM_CLEAR_FLAG(TIM_FLAG));
;;;2603      
;;;2604     /* Clear the flags */
;;;2605     TIMx->SR = (uint16_t)~TIM_FLAG;
000002  8201              STRH     r1,[r0,#0x10]
;;;2606   }
000004  4770              BX       lr
;;;2607   
                          ENDP


                          AREA ||i.TIM_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  TIM_ClearITPendingBit PROC
;;;2673     */
;;;2674   void TIM_ClearITPendingBit(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  43c9              MVNS     r1,r1
;;;2675   {
;;;2676     /* Check the parameters */
;;;2677     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2678     assert_param(IS_TIM_IT(TIM_IT));
;;;2679     /* Clear the IT pending Bit */
;;;2680     TIMx->SR = (uint16_t)~TIM_IT;
000002  8201              STRH     r1,[r0,#0x10]
;;;2681   }
000004  4770              BX       lr
;;;2682   
                          ENDP


                          AREA ||i.TIM_ClearOC1Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC1Ref PROC
;;;1704     */
;;;1705   void TIM_ClearOC1Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1706   {
;;;1707     uint16_t tmpccmr1 = 0;
;;;1708     /* Check the parameters */
;;;1709     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1710     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1711   
;;;1712     tmpccmr1 = TIMx->CCMR1;
;;;1713   
;;;1714     /* Reset the OC1CE Bit */
;;;1715     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1716     /* Enable or Disable the Output Compare Clear Bit */
;;;1717     tmpccmr1 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1718     /* Write to TIMx CCMR1 register */
;;;1719     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1720   }
00000a  4770              BX       lr
;;;1721   
                          ENDP


                          AREA ||i.TIM_ClearOC2Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC2Ref PROC
;;;1730     */
;;;1731   void TIM_ClearOC2Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1732   {
;;;1733     uint16_t tmpccmr1 = 0;
;;;1734     /* Check the parameters */
;;;1735     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1736     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1737     tmpccmr1 = TIMx->CCMR1;
;;;1738     /* Reset the OC2CE Bit */
;;;1739     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2CE);
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1740     /* Enable or Disable the Output Compare Clear Bit */
;;;1741     tmpccmr1 |= (uint16_t)(TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1742     /* Write to TIMx CCMR1 register */
;;;1743     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1744   }
00000c  4770              BX       lr
;;;1745   
                          ENDP


                          AREA ||i.TIM_ClearOC3Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC3Ref PROC
;;;1754     */
;;;1755   void TIM_ClearOC3Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1756   {
;;;1757     uint16_t tmpccmr2 = 0;
;;;1758     /* Check the parameters */
;;;1759     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1760     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1761     tmpccmr2 = TIMx->CCMR2;
;;;1762     /* Reset the OC3CE Bit */
;;;1763     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3CE);
000002  f0220280          BIC      r2,r2,#0x80
;;;1764     /* Enable or Disable the Output Compare Clear Bit */
;;;1765     tmpccmr2 |= TIM_OCClear;
000006  430a              ORRS     r2,r2,r1
;;;1766     /* Write to TIMx CCMR2 register */
;;;1767     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1768   }
00000a  4770              BX       lr
;;;1769   
                          ENDP


                          AREA ||i.TIM_ClearOC4Ref||, CODE, READONLY, ALIGN=1

                  TIM_ClearOC4Ref PROC
;;;1778     */
;;;1779   void TIM_ClearOC4Ref(TIM_TypeDef* TIMx, uint16_t TIM_OCClear)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1780   {
;;;1781     uint16_t tmpccmr2 = 0;
;;;1782     /* Check the parameters */
;;;1783     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1784     assert_param(IS_TIM_OCCLEAR_STATE(TIM_OCClear));
;;;1785     tmpccmr2 = TIMx->CCMR2;
;;;1786     /* Reset the OC4CE Bit */
;;;1787     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4CE);
000002  f3c2020e          UBFX     r2,r2,#0,#15
;;;1788     /* Enable or Disable the Output Compare Clear Bit */
;;;1789     tmpccmr2 |= (uint16_t)(TIM_OCClear << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1790     /* Write to TIMx CCMR2 register */
;;;1791     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1792   }
00000c  4770              BX       lr
;;;1793   
                          ENDP


                          AREA ||i.TIM_Cmd||, CODE, READONLY, ALIGN=1

                  TIM_Cmd PROC
;;;803      */
;;;804    void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;805    {
;;;806      /* Check the parameters */
;;;807      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;808      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;809      
;;;810      if (NewState != DISABLE)
;;;811      {
;;;812        /* Enable the TIM Counter */
;;;813        TIMx->CR1 |= TIM_CR1_CEN;
;;;814      }
;;;815      else
;;;816      {
;;;817        /* Disable the TIM Counter */
;;;818        TIMx->CR1 &= (uint16_t)(~((uint16_t)TIM_CR1_CEN));
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L15.12|
000006  f0410101          ORR      r1,r1,#1              ;813
00000a  e001              B        |L15.16|
                  |L15.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L15.16|
000010  8001              STRH     r1,[r0,#0]            ;813
;;;819      }
;;;820    }
000012  4770              BX       lr
;;;821    
                          ENDP


                          AREA ||i.TIM_CounterModeConfig||, CODE, READONLY, ALIGN=1

                  TIM_CounterModeConfig PROC
;;;1196     */
;;;1197   void TIM_CounterModeConfig(TIM_TypeDef* TIMx, uint16_t TIM_CounterMode)
000000  8802              LDRH     r2,[r0,#0]
;;;1198   {
;;;1199     uint16_t tmpcr1 = 0;
;;;1200     /* Check the parameters */
;;;1201     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1202     assert_param(IS_TIM_COUNTER_MODE(TIM_CounterMode));
;;;1203     tmpcr1 = TIMx->CR1;
;;;1204     /* Reset the CMS and DIR Bits */
;;;1205     tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000002  f0220270          BIC      r2,r2,#0x70
;;;1206     /* Set the Counter Mode */
;;;1207     tmpcr1 |= TIM_CounterMode;
000006  430a              ORRS     r2,r2,r1
;;;1208     /* Write to TIMx CR1 register */
;;;1209     TIMx->CR1 = tmpcr1;
000008  8002              STRH     r2,[r0,#0]
;;;1210   }
00000a  4770              BX       lr
;;;1211   
                          ENDP


                          AREA ||i.TIM_CtrlPWMOutputs||, CODE, READONLY, ALIGN=1

                  TIM_CtrlPWMOutputs PROC
;;;828      */
;;;829    void TIM_CtrlPWMOutputs(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;830    {
;;;831      /* Check the parameters */
;;;832      assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;833      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;834      if (NewState != DISABLE)
;;;835      {
;;;836        /* Enable the TIM Main Output */
;;;837        TIMx->BDTR |= TIM_BDTR_MOE;
;;;838      }
;;;839      else
;;;840      {
;;;841        /* Disable the TIM Main Output */
;;;842        TIMx->BDTR &= (uint16_t)(~((uint16_t)TIM_BDTR_MOE));
000002  f8301f44          LDRH     r1,[r0,#0x44]!
000006  d002              BEQ      |L17.14|
000008  f4414100          ORR      r1,r1,#0x8000         ;837
00000c  e001              B        |L17.18|
                  |L17.14|
00000e  f3c1010e          UBFX     r1,r1,#0,#15
                  |L17.18|
000012  8001              STRH     r1,[r0,#0]            ;837
;;;843      }  
;;;844    }
000014  4770              BX       lr
;;;845    
                          ENDP


                          AREA ||i.TIM_DMACmd||, CODE, READONLY, ALIGN=1

                  TIM_DMACmd PROC
;;;961      */
;;;962    void TIM_DMACmd(TIM_TypeDef* TIMx, uint16_t TIM_DMASource, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;963    { 
;;;964      /* Check the parameters */
;;;965      assert_param(IS_TIM_LIST9_PERIPH(TIMx));
;;;966      assert_param(IS_TIM_DMA_SOURCE(TIM_DMASource));
;;;967      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;968      
;;;969      if (NewState != DISABLE)
;;;970      {
;;;971        /* Enable the DMA sources */
;;;972        TIMx->DIER |= TIM_DMASource; 
;;;973      }
;;;974      else
;;;975      {
;;;976        /* Disable the DMA sources */
;;;977        TIMx->DIER &= (uint16_t)~TIM_DMASource;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L18.10|
000006  430a              ORRS     r2,r2,r1              ;972
000008  e000              B        |L18.12|
                  |L18.10|
00000a  438a              BICS     r2,r2,r1
                  |L18.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;972
;;;978      }
;;;979    }
00000e  4770              BX       lr
;;;980    
                          ENDP


                          AREA ||i.TIM_DMAConfig||, CODE, READONLY, ALIGN=1

                  TIM_DMAConfig PROC
;;;934      */
;;;935    void TIM_DMAConfig(TIM_TypeDef* TIMx, uint16_t TIM_DMABase, uint16_t TIM_DMABurstLength)
000000  4311              ORRS     r1,r1,r2
;;;936    {
;;;937      /* Check the parameters */
;;;938      assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;939      assert_param(IS_TIM_DMA_BASE(TIM_DMABase));
;;;940      assert_param(IS_TIM_DMA_LENGTH(TIM_DMABurstLength));
;;;941      /* Set the DMA Base and the DMA Burst Length */
;;;942      TIMx->DCR = TIM_DMABase | TIM_DMABurstLength;
000002  f8a01048          STRH     r1,[r0,#0x48]
;;;943    }
000006  4770              BX       lr
;;;944    
                          ENDP


                          AREA ||i.TIM_DeInit||, CODE, READONLY, ALIGN=2

                  TIM_DeInit PROC
;;;120      */
;;;121    void TIM_DeInit(TIM_TypeDef* TIMx)
000000  494b              LDR      r1,|L20.304|
;;;122    {
000002  b510              PUSH     {r4,lr}
;;;123      /* Check the parameters */
;;;124      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;125     
;;;126      if (TIMx == TIM1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L20.14|
;;;127      {
;;;128        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  14c4              ASRS     r4,r0,#19
;;;129        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM1, DISABLE);  
00000c  e086              B        |L20.284|
                  |L20.14|
;;;130      }     
;;;131      else if (TIMx == TIM2)
00000e  f1b04f80          CMP      r0,#0x40000000
000012  d009              BEQ      |L20.40|
;;;132      {
;;;133        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, ENABLE);
;;;134        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM2, DISABLE);
;;;135      }
;;;136      else if (TIMx == TIM3)
000014  4947              LDR      r1,|L20.308|
000016  4288              CMP      r0,r1
000018  d10d              BNE      |L20.54|
;;;137      {
;;;138        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, ENABLE);
00001a  2101              MOVS     r1,#1
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;139        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM3, DISABLE);
000022  2100              MOVS     r1,#0
000024  2002              MOVS     r0,#2
000026  e064              B        |L20.242|
                  |L20.40|
000028  2101              MOVS     r1,#1                 ;133
00002a  4608              MOV      r0,r1                 ;133
00002c  f7fffffe          BL       RCC_APB1PeriphResetCmd
000030  2100              MOVS     r1,#0                 ;134
000032  2001              MOVS     r0,#1                 ;134
000034  e05d              B        |L20.242|
                  |L20.54|
;;;140      }
;;;141      else if (TIMx == TIM4)
000036  4940              LDR      r1,|L20.312|
000038  4288              CMP      r0,r1
00003a  d106              BNE      |L20.74|
;;;142      {
;;;143        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, ENABLE);
00003c  2101              MOVS     r1,#1
00003e  2004              MOVS     r0,#4
000040  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;144        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM4, DISABLE);
000044  2100              MOVS     r1,#0
000046  2004              MOVS     r0,#4
000048  e053              B        |L20.242|
                  |L20.74|
;;;145      } 
;;;146      else if (TIMx == TIM5)
00004a  493c              LDR      r1,|L20.316|
00004c  4288              CMP      r0,r1
00004e  d106              BNE      |L20.94|
;;;147      {
;;;148        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, ENABLE);
000050  2101              MOVS     r1,#1
000052  2008              MOVS     r0,#8
000054  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;149        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM5, DISABLE);
000058  2100              MOVS     r1,#0
00005a  2008              MOVS     r0,#8
00005c  e049              B        |L20.242|
                  |L20.94|
;;;150      } 
;;;151      else if (TIMx == TIM6)
00005e  4938              LDR      r1,|L20.320|
000060  4288              CMP      r0,r1
000062  d106              BNE      |L20.114|
;;;152      {
;;;153        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, ENABLE);
000064  2101              MOVS     r1,#1
000066  2010              MOVS     r0,#0x10
000068  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;154        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM6, DISABLE);
00006c  2100              MOVS     r1,#0
00006e  2010              MOVS     r0,#0x10
000070  e03f              B        |L20.242|
                  |L20.114|
;;;155      } 
;;;156      else if (TIMx == TIM7)
000072  4934              LDR      r1,|L20.324|
000074  4288              CMP      r0,r1
000076  d106              BNE      |L20.134|
;;;157      {
;;;158        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, ENABLE);
000078  2101              MOVS     r1,#1
00007a  2020              MOVS     r0,#0x20
00007c  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;159        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM7, DISABLE);
000080  2100              MOVS     r1,#0
000082  2020              MOVS     r0,#0x20
000084  e035              B        |L20.242|
                  |L20.134|
;;;160      } 
;;;161      else if (TIMx == TIM8)
000086  4930              LDR      r1,|L20.328|
000088  4288              CMP      r0,r1
00008a  d102              BNE      |L20.146|
;;;162      {
;;;163        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, ENABLE);
00008c  2101              MOVS     r1,#1
00008e  1444              ASRS     r4,r0,#17
;;;164        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM8, DISABLE);
000090  e044              B        |L20.284|
                  |L20.146|
;;;165      }
;;;166      else if (TIMx == TIM9)
000092  492e              LDR      r1,|L20.332|
000094  4288              CMP      r0,r1
000096  d102              BNE      |L20.158|
;;;167      {      
;;;168        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, ENABLE);
000098  2101              MOVS     r1,#1
00009a  04cc              LSLS     r4,r1,#19
;;;169        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM9, DISABLE);  
00009c  e03e              B        |L20.284|
                  |L20.158|
;;;170       }  
;;;171      else if (TIMx == TIM10)
00009e  492c              LDR      r1,|L20.336|
0000a0  4288              CMP      r0,r1
0000a2  d102              BNE      |L20.170|
;;;172      {      
;;;173        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, ENABLE);
0000a4  2101              MOVS     r1,#1
0000a6  050c              LSLS     r4,r1,#20
;;;174        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM10, DISABLE);  
0000a8  e038              B        |L20.284|
                  |L20.170|
;;;175      }  
;;;176      else if (TIMx == TIM11) 
0000aa  492a              LDR      r1,|L20.340|
0000ac  4288              CMP      r0,r1
0000ae  d102              BNE      |L20.182|
;;;177      {     
;;;178        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  054c              LSLS     r4,r1,#21
;;;179        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM11, DISABLE);  
0000b4  e032              B        |L20.284|
                  |L20.182|
;;;180      }  
;;;181      else if (TIMx == TIM12)
0000b6  4928              LDR      r1,|L20.344|
0000b8  4288              CMP      r0,r1
0000ba  d106              BNE      |L20.202|
;;;182      {      
;;;183        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, ENABLE);
0000bc  2101              MOVS     r1,#1
0000be  2040              MOVS     r0,#0x40
0000c0  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;184        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM12, DISABLE);  
0000c4  2100              MOVS     r1,#0
0000c6  2040              MOVS     r0,#0x40
0000c8  e013              B        |L20.242|
                  |L20.202|
;;;185      }  
;;;186      else if (TIMx == TIM13) 
0000ca  4924              LDR      r1,|L20.348|
0000cc  4288              CMP      r0,r1
0000ce  d106              BNE      |L20.222|
;;;187      {       
;;;188        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, ENABLE);
0000d0  2101              MOVS     r1,#1
0000d2  2080              MOVS     r0,#0x80
0000d4  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;189        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM13, DISABLE);  
0000d8  2100              MOVS     r1,#0
0000da  2080              MOVS     r0,#0x80
0000dc  e009              B        |L20.242|
                  |L20.222|
;;;190      }
;;;191      else if (TIMx == TIM14) 
0000de  4920              LDR      r1,|L20.352|
0000e0  4288              CMP      r0,r1
0000e2  d10a              BNE      |L20.250|
;;;192      {       
;;;193        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, ENABLE);
0000e4  1584              ASRS     r4,r0,#22
0000e6  2101              MOVS     r1,#1
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;194        RCC_APB1PeriphResetCmd(RCC_APB1Periph_TIM14, DISABLE);  
0000ee  2100              MOVS     r1,#0
0000f0  4620              MOV      r0,r4
                  |L20.242|
0000f2  e8bd4010          POP      {r4,lr}
0000f6  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
                  |L20.250|
;;;195      }        
;;;196      else if (TIMx == TIM15)
0000fa  491a              LDR      r1,|L20.356|
0000fc  4288              CMP      r0,r1
0000fe  d102              BNE      |L20.262|
;;;197      {
;;;198        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, ENABLE);
000100  2101              MOVS     r1,#1
000102  040c              LSLS     r4,r1,#16
;;;199        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM15, DISABLE);
000104  e00a              B        |L20.284|
                  |L20.262|
;;;200      } 
;;;201      else if (TIMx == TIM16)
000106  4918              LDR      r1,|L20.360|
000108  4288              CMP      r0,r1
00010a  d102              BNE      |L20.274|
;;;202      {
;;;203        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, ENABLE);
00010c  2101              MOVS     r1,#1
00010e  044c              LSLS     r4,r1,#17
;;;204        RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM16, DISABLE);
000110  e004              B        |L20.284|
                  |L20.274|
;;;205      } 
;;;206      else
;;;207      {
;;;208        if (TIMx == TIM17)
000112  4916              LDR      r1,|L20.364|
000114  4288              CMP      r0,r1
000116  d10a              BNE      |L20.302|
;;;209        {
;;;210          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, ENABLE);
000118  2101              MOVS     r1,#1
00011a  048c              LSLS     r4,r1,#18
                  |L20.284|
00011c  4620              MOV      r0,r4
00011e  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;211          RCC_APB2PeriphResetCmd(RCC_APB2Periph_TIM17, DISABLE);
000122  4620              MOV      r0,r4
000124  e8bd4010          POP      {r4,lr}
000128  2100              MOVS     r1,#0
00012a  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L20.302|
;;;212        }  
;;;213      }
;;;214    }
00012e  bd10              POP      {r4,pc}
;;;215    
                          ENDP

                  |L20.304|
                          DCD      0x40012c00
                  |L20.308|
                          DCD      0x40000400
                  |L20.312|
                          DCD      0x40000800
                  |L20.316|
                          DCD      0x40000c00
                  |L20.320|
                          DCD      0x40001000
                  |L20.324|
                          DCD      0x40001400
                  |L20.328|
                          DCD      0x40013400
                  |L20.332|
                          DCD      0x40014c00
                  |L20.336|
                          DCD      0x40015000
                  |L20.340|
                          DCD      0x40015400
                  |L20.344|
                          DCD      0x40001800
                  |L20.348|
                          DCD      0x40001c00
                  |L20.352|
                          DCD      0x40002000
                  |L20.356|
                          DCD      0x40014000
                  |L20.360|
                          DCD      0x40014400
                  |L20.364|
                          DCD      0x40014800

                          AREA ||i.TIM_ETRClockMode1Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode1Config PROC
;;;1072     */
;;;1073   void TIM_ETRClockMode1Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b510              PUSH     {r4,lr}
;;;1074                                uint16_t ExtTRGFilter)
;;;1075   {
000002  4604              MOV      r4,r0
;;;1076     uint16_t tmpsmcr = 0;
;;;1077     /* Check the parameters */
;;;1078     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1079     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1080     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1081     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1082     /* Configure the ETR Clock source */
;;;1083     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;1084     
;;;1085     /* Get the TIMx SMCR register value */
;;;1086     tmpsmcr = TIMx->SMCR;
000008  8920              LDRH     r0,[r4,#8]
;;;1087     /* Reset the SMS Bits */
;;;1088     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
;;;1089     /* Select the External clock mode1 */
;;;1090     tmpsmcr |= TIM_SlaveMode_External1;
;;;1091     /* Select the Trigger selection : ETRF */
;;;1092     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
;;;1093     tmpsmcr |= TIM_TS_ETRF;
00000a  f0400077          ORR      r0,r0,#0x77
;;;1094     /* Write to TIMx SMCR */
;;;1095     TIMx->SMCR = tmpsmcr;
00000e  8120              STRH     r0,[r4,#8]
;;;1096   }
000010  bd10              POP      {r4,pc}
;;;1097   
                          ENDP


                          AREA ||i.TIM_ETRClockMode2Config||, CODE, READONLY, ALIGN=1

                  TIM_ETRClockMode2Config PROC
;;;1114     */
;;;1115   void TIM_ETRClockMode2Config(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, 
000000  b510              PUSH     {r4,lr}
;;;1116                                uint16_t TIM_ExtTRGPolarity, uint16_t ExtTRGFilter)
;;;1117   {
000002  4604              MOV      r4,r0
;;;1118     /* Check the parameters */
;;;1119     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1120     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1121     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1122     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1123     /* Configure the ETR Clock source */
;;;1124     TIM_ETRConfig(TIMx, TIM_ExtTRGPrescaler, TIM_ExtTRGPolarity, ExtTRGFilter);
000004  f7fffffe          BL       TIM_ETRConfig
;;;1125     /* Enable the External clock mode2 */
;;;1126     TIMx->SMCR |= TIM_SMCR_ECE;
000008  8920              LDRH     r0,[r4,#8]
00000a  f4404080          ORR      r0,r0,#0x4000
00000e  8120              STRH     r0,[r4,#8]
;;;1127   }
000010  bd10              POP      {r4,pc}
;;;1128   
                          ENDP


                          AREA ||i.TIM_ETRConfig||, CODE, READONLY, ALIGN=1

                  TIM_ETRConfig PROC
;;;1145     */
;;;1146   void TIM_ETRConfig(TIM_TypeDef* TIMx, uint16_t TIM_ExtTRGPrescaler, uint16_t TIM_ExtTRGPolarity,
000000  b510              PUSH     {r4,lr}
;;;1147                      uint16_t ExtTRGFilter)
;;;1148   {
;;;1149     uint16_t tmpsmcr = 0;
;;;1150     /* Check the parameters */
;;;1151     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1152     assert_param(IS_TIM_EXT_PRESCALER(TIM_ExtTRGPrescaler));
;;;1153     assert_param(IS_TIM_EXT_POLARITY(TIM_ExtTRGPolarity));
;;;1154     assert_param(IS_TIM_EXT_FILTER(ExtTRGFilter));
;;;1155     tmpsmcr = TIMx->SMCR;
000002  8904              LDRH     r4,[r0,#8]
;;;1156     /* Reset the ETR Bits */
;;;1157     tmpsmcr &= SMCR_ETR_Mask;
;;;1158     /* Set the Prescaler, the Filter value and the Polarity */
;;;1159     tmpsmcr |= (uint16_t)(TIM_ExtTRGPrescaler | (uint16_t)(TIM_ExtTRGPolarity | (uint16_t)(ExtTRGFilter << (uint16_t)8)));
000004  ea422303          ORR      r3,r2,r3,LSL #8
000008  b2e4              UXTB     r4,r4                 ;1157
00000a  430b              ORRS     r3,r3,r1
00000c  4323              ORRS     r3,r3,r4
;;;1160     /* Write to TIMx SMCR */
;;;1161     TIMx->SMCR = tmpsmcr;
00000e  8103              STRH     r3,[r0,#8]
;;;1162   }
000010  bd10              POP      {r4,pc}
;;;1163   
                          ENDP


                          AREA ||i.TIM_EncoderInterfaceConfig||, CODE, READONLY, ALIGN=1

                  TIM_EncoderInterfaceConfig PROC
;;;1261     */
;;;1262   void TIM_EncoderInterfaceConfig(TIM_TypeDef* TIMx, uint16_t TIM_EncoderMode,
000000  b570              PUSH     {r4-r6,lr}
;;;1263                                   uint16_t TIM_IC1Polarity, uint16_t TIM_IC2Polarity)
;;;1264   {
;;;1265     uint16_t tmpsmcr = 0;
;;;1266     uint16_t tmpccmr1 = 0;
;;;1267     uint16_t tmpccer = 0;
;;;1268       
;;;1269     /* Check the parameters */
;;;1270     assert_param(IS_TIM_LIST5_PERIPH(TIMx));
;;;1271     assert_param(IS_TIM_ENCODER_MODE(TIM_EncoderMode));
;;;1272     assert_param(IS_TIM_IC_POLARITY(TIM_IC1Polarity));
;;;1273     assert_param(IS_TIM_IC_POLARITY(TIM_IC2Polarity));
;;;1274   
;;;1275     /* Get the TIMx SMCR register value */
;;;1276     tmpsmcr = TIMx->SMCR;
000002  8905              LDRH     r5,[r0,#8]
;;;1277     
;;;1278     /* Get the TIMx CCMR1 register value */
;;;1279     tmpccmr1 = TIMx->CCMR1;
000004  8b04              LDRH     r4,[r0,#0x18]
;;;1280     
;;;1281     /* Get the TIMx CCER register value */
;;;1282     tmpccer = TIMx->CCER;
000006  8c06              LDRH     r6,[r0,#0x20]
;;;1283     
;;;1284     /* Set the encoder Mode */
;;;1285     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000008  f0250507          BIC      r5,r5,#7
;;;1286     tmpsmcr |= TIM_EncoderMode;
00000c  430d              ORRS     r5,r5,r1
;;;1287     
;;;1288     /* Select the Capture Compare 1 and the Capture Compare 2 as input */
;;;1289     tmpccmr1 &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCMR1_CC1S)) & (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S)));
00000e  f64f41fc          MOV      r1,#0xfcfc
000012  400c              ANDS     r4,r4,r1
;;;1290     tmpccmr1 |= TIM_CCMR1_CC1S_0 | TIM_CCMR1_CC2S_0;
000014  f2401101          MOV      r1,#0x101
000018  430c              ORRS     r4,r4,r1
;;;1291     
;;;1292     /* Set the TI1 and the TI2 Polarities */
;;;1293     tmpccer &= (uint16_t)(((uint16_t)~((uint16_t)TIM_CCER_CC1P)) & ((uint16_t)~((uint16_t)TIM_CCER_CC2P)));
00001a  f0260622          BIC      r6,r6,#0x22
;;;1294     tmpccer |= (uint16_t)(TIM_IC1Polarity | (uint16_t)(TIM_IC2Polarity << (uint16_t)4));
00001e  ea421103          ORR      r1,r2,r3,LSL #4
000022  4331              ORRS     r1,r1,r6
;;;1295     
;;;1296     /* Write to TIMx SMCR */
;;;1297     TIMx->SMCR = tmpsmcr;
000024  8105              STRH     r5,[r0,#8]
;;;1298     /* Write to TIMx CCMR1 */
;;;1299     TIMx->CCMR1 = tmpccmr1;
000026  8304              STRH     r4,[r0,#0x18]
;;;1300     /* Write to TIMx CCER */
;;;1301     TIMx->CCER = tmpccer;
000028  8401              STRH     r1,[r0,#0x20]
;;;1302   }
00002a  bd70              POP      {r4-r6,pc}
;;;1303   
                          ENDP


                          AREA ||i.TIM_ForcedOC1Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC1Config PROC
;;;1312     */
;;;1313   void TIM_ForcedOC1Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1314   {
;;;1315     uint16_t tmpccmr1 = 0;
;;;1316     /* Check the parameters */
;;;1317     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1318     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1319     tmpccmr1 = TIMx->CCMR1;
;;;1320     /* Reset the OC1M Bits */
;;;1321     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1322     /* Configure The Forced output Mode */
;;;1323     tmpccmr1 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1324     /* Write to TIMx CCMR1 register */
;;;1325     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1326   }
00000a  4770              BX       lr
;;;1327   
                          ENDP


                          AREA ||i.TIM_ForcedOC2Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC2Config PROC
;;;1336     */
;;;1337   void TIM_ForcedOC2Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1338   {
;;;1339     uint16_t tmpccmr1 = 0;
;;;1340     /* Check the parameters */
;;;1341     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1342     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1343     tmpccmr1 = TIMx->CCMR1;
;;;1344     /* Reset the OC2M Bits */
;;;1345     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2M);
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1346     /* Configure The Forced output Mode */
;;;1347     tmpccmr1 |= (uint16_t)(TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1348     /* Write to TIMx CCMR1 register */
;;;1349     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1350   }
00000c  4770              BX       lr
;;;1351   
                          ENDP


                          AREA ||i.TIM_ForcedOC3Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC3Config PROC
;;;1360     */
;;;1361   void TIM_ForcedOC3Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1362   {
;;;1363     uint16_t tmpccmr2 = 0;
;;;1364     /* Check the parameters */
;;;1365     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1366     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1367     tmpccmr2 = TIMx->CCMR2;
;;;1368     /* Reset the OC1M Bits */
;;;1369     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3M);
000002  f0220270          BIC      r2,r2,#0x70
;;;1370     /* Configure The Forced output Mode */
;;;1371     tmpccmr2 |= TIM_ForcedAction;
000006  430a              ORRS     r2,r2,r1
;;;1372     /* Write to TIMx CCMR2 register */
;;;1373     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1374   }
00000a  4770              BX       lr
;;;1375   
                          ENDP


                          AREA ||i.TIM_ForcedOC4Config||, CODE, READONLY, ALIGN=1

                  TIM_ForcedOC4Config PROC
;;;1384     */
;;;1385   void TIM_ForcedOC4Config(TIM_TypeDef* TIMx, uint16_t TIM_ForcedAction)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1386   {
;;;1387     uint16_t tmpccmr2 = 0;
;;;1388     /* Check the parameters */
;;;1389     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1390     assert_param(IS_TIM_FORCED_ACTION(TIM_ForcedAction));
;;;1391     tmpccmr2 = TIMx->CCMR2;
;;;1392     /* Reset the OC2M Bits */
;;;1393     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4M);
000002  f42242e0          BIC      r2,r2,#0x7000
;;;1394     /* Configure The Forced output Mode */
;;;1395     tmpccmr2 |= (uint16_t)(TIM_ForcedAction << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1396     /* Write to TIMx CCMR2 register */
;;;1397     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1398   }
00000c  4770              BX       lr
;;;1399   
                          ENDP


                          AREA ||i.TIM_GenerateEvent||, CODE, READONLY, ALIGN=1

                  TIM_GenerateEvent PROC
;;;906      */
;;;907    void TIM_GenerateEvent(TIM_TypeDef* TIMx, uint16_t TIM_EventSource)
000000  8281              STRH     r1,[r0,#0x14]
;;;908    { 
;;;909      /* Check the parameters */
;;;910      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;911      assert_param(IS_TIM_EVENT_SOURCE(TIM_EventSource));
;;;912      
;;;913      /* Set the event sources */
;;;914      TIMx->EGR = TIM_EventSource;
;;;915    }
000002  4770              BX       lr
;;;916    
                          ENDP


                          AREA ||i.TIM_GetCapture1||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture1 PROC
;;;2454     */
;;;2455   uint16_t TIM_GetCapture1(TIM_TypeDef* TIMx)
000000  8e80              LDRH     r0,[r0,#0x34]
;;;2456   {
;;;2457     /* Check the parameters */
;;;2458     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2459     /* Get the Capture 1 Register value */
;;;2460     return TIMx->CCR1;
;;;2461   }
000002  4770              BX       lr
;;;2462   
                          ENDP


                          AREA ||i.TIM_GetCapture2||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture2 PROC
;;;2467     */
;;;2468   uint16_t TIM_GetCapture2(TIM_TypeDef* TIMx)
000000  8f00              LDRH     r0,[r0,#0x38]
;;;2469   {
;;;2470     /* Check the parameters */
;;;2471     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2472     /* Get the Capture 2 Register value */
;;;2473     return TIMx->CCR2;
;;;2474   }
000002  4770              BX       lr
;;;2475   
                          ENDP


                          AREA ||i.TIM_GetCapture3||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture3 PROC
;;;2480     */
;;;2481   uint16_t TIM_GetCapture3(TIM_TypeDef* TIMx)
000000  8f80              LDRH     r0,[r0,#0x3c]
;;;2482   {
;;;2483     /* Check the parameters */
;;;2484     assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;2485     /* Get the Capture 3 Register value */
;;;2486     return TIMx->CCR3;
;;;2487   }
000002  4770              BX       lr
;;;2488   
                          ENDP


                          AREA ||i.TIM_GetCapture4||, CODE, READONLY, ALIGN=1

                  TIM_GetCapture4 PROC
;;;2493     */
;;;2494   uint16_t TIM_GetCapture4(TIM_TypeDef* TIMx)
000000  f8b00040          LDRH     r0,[r0,#0x40]
;;;2495   {
;;;2496     /* Check the parameters */
;;;2497     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2498     /* Get the Capture 4 Register value */
;;;2499     return TIMx->CCR4;
;;;2500   }
000004  4770              BX       lr
;;;2501   
                          ENDP


                          AREA ||i.TIM_GetCounter||, CODE, READONLY, ALIGN=1

                  TIM_GetCounter PROC
;;;2506     */
;;;2507   uint16_t TIM_GetCounter(TIM_TypeDef* TIMx)
000000  8c80              LDRH     r0,[r0,#0x24]
;;;2508   {
;;;2509     /* Check the parameters */
;;;2510     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2511     /* Get the Counter Register value */
;;;2512     return TIMx->CNT;
;;;2513   }
000002  4770              BX       lr
;;;2514   
                          ENDP


                          AREA ||i.TIM_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetFlagStatus PROC
;;;2553     */
;;;2554   FlagStatus TIM_GetFlagStatus(TIM_TypeDef* TIMx, uint16_t TIM_FLAG)
000000  4602              MOV      r2,r0
;;;2555   { 
;;;2556     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2557     /* Check the parameters */
;;;2558     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2559     assert_param(IS_TIM_GET_FLAG(TIM_FLAG));
;;;2560     
;;;2561     if ((TIMx->SR & TIM_FLAG) != (uint16_t)RESET)
000004  8a12              LDRH     r2,[r2,#0x10]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L35.12|
;;;2562     {
;;;2563       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L35.12|
;;;2564     }
;;;2565     else
;;;2566     {
;;;2567       bitstatus = RESET;
;;;2568     }
;;;2569     return bitstatus;
;;;2570   }
00000c  4770              BX       lr
;;;2571   
                          ENDP


                          AREA ||i.TIM_GetITStatus||, CODE, READONLY, ALIGN=1

                  TIM_GetITStatus PROC
;;;2629     */
;;;2630   ITStatus TIM_GetITStatus(TIM_TypeDef* TIMx, uint16_t TIM_IT)
000000  4602              MOV      r2,r0
;;;2631   {
;;;2632     ITStatus bitstatus = RESET;  
000002  2000              MOVS     r0,#0
;;;2633     uint16_t itstatus = 0x0, itenable = 0x0;
;;;2634     /* Check the parameters */
;;;2635     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2636     assert_param(IS_TIM_GET_IT(TIM_IT));
;;;2637      
;;;2638     itstatus = TIMx->SR & TIM_IT;
000004  8a13              LDRH     r3,[r2,#0x10]
;;;2639     
;;;2640     itenable = TIMx->DIER & TIM_IT;
000006  8992              LDRH     r2,[r2,#0xc]
000008  420b              TST      r3,r1                 ;2638
00000a  ea020201          AND      r2,r2,r1
;;;2641     if ((itstatus != (uint16_t)RESET) && (itenable != (uint16_t)RESET))
00000e  d002              BEQ      |L36.22|
000010  2a00              CMP      r2,#0
000012  d000              BEQ      |L36.22|
;;;2642     {
;;;2643       bitstatus = SET;
000014  2001              MOVS     r0,#1
                  |L36.22|
;;;2644     }
;;;2645     else
;;;2646     {
;;;2647       bitstatus = RESET;
;;;2648     }
;;;2649     return bitstatus;
;;;2650   }
000016  4770              BX       lr
;;;2651   
                          ENDP


                          AREA ||i.TIM_GetPrescaler||, CODE, READONLY, ALIGN=1

                  TIM_GetPrescaler PROC
;;;2519     */
;;;2520   uint16_t TIM_GetPrescaler(TIM_TypeDef* TIMx)
000000  8d00              LDRH     r0,[r0,#0x28]
;;;2521   {
;;;2522     /* Check the parameters */
;;;2523     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2524     /* Get the Prescaler Register value */
;;;2525     return TIMx->PSC;
;;;2526   }
000002  4770              BX       lr
;;;2527   
                          ENDP


                          AREA ||i.TIM_ICInit||, CODE, READONLY, ALIGN=2

                  TIM_ICInit PROC
;;;584      */
;;;585    void TIM_ICInit(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;586    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;587      /* Check the parameters */
;;;588      assert_param(IS_TIM_CHANNEL(TIM_ICInitStruct->TIM_Channel));  
;;;589      assert_param(IS_TIM_IC_SELECTION(TIM_ICInitStruct->TIM_ICSelection));
;;;590      assert_param(IS_TIM_IC_PRESCALER(TIM_ICInitStruct->TIM_ICPrescaler));
;;;591      assert_param(IS_TIM_IC_FILTER(TIM_ICInitStruct->TIM_ICFilter));
;;;592      
;;;593      if((TIMx == TIM1) || (TIMx == TIM8) || (TIMx == TIM2) || (TIMx == TIM3) ||
;;;594         (TIMx == TIM4) ||(TIMx == TIM5))
;;;595      {
;;;596        assert_param(IS_TIM_IC_POLARITY(TIM_ICInitStruct->TIM_ICPolarity));
;;;597      }
;;;598      else
;;;599      {
;;;600        assert_param(IS_TIM_IC_POLARITY_LITE(TIM_ICInitStruct->TIM_ICPolarity));
;;;601      }
;;;602      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
000008  8808              LDRH     r0,[r1,#0]
00000a  4e42              LDR      r6,|L38.276|
00000c  4f42              LDR      r7,|L38.280|
00000e  f8df810c          LDR      r8,|L38.284|
000012  f8df910c          LDR      r9,|L38.288|
;;;603      {
;;;604        assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;605        /* TI1 Configuration */
;;;606        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000016  8849              LDRH     r1,[r1,#2]
000018  88aa              LDRH     r2,[r5,#4]
00001a  892b              LDRH     r3,[r5,#8]
00001c  f04f4a80          MOV      r10,#0x40000000       ;593
000020  b128              CBZ      r0,|L38.46|
;;;607                   TIM_ICInitStruct->TIM_ICSelection,
;;;608                   TIM_ICInitStruct->TIM_ICFilter);
;;;609        /* Set the Input Capture Prescaler value */
;;;610        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;611      }
;;;612      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_2)
000022  2804              CMP      r0,#4
000024  d00c              BEQ      |L38.64|
;;;613      {
;;;614        assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;615        /* TI2 Configuration */
;;;616        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
;;;617                   TIM_ICInitStruct->TIM_ICSelection,
;;;618                   TIM_ICInitStruct->TIM_ICFilter);
;;;619        /* Set the Input Capture Prescaler value */
;;;620        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;621      }
;;;622      else if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_3)
000026  2808              CMP      r0,#8
;;;623      {
;;;624        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;625        /* TI3 Configuration */
;;;626        TI3_Config(TIMx,  TIM_ICInitStruct->TIM_ICPolarity,
;;;627                   TIM_ICInitStruct->TIM_ICSelection,
;;;628                   TIM_ICInitStruct->TIM_ICFilter);
;;;629        /* Set the Input Capture Prescaler value */
;;;630        TIM_SetIC3Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;631      }
;;;632      else
;;;633      {
;;;634        assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;635        /* TI4 Configuration */
;;;636        TI4_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity,
000028  4693              MOV      r11,r2
00002a  d012              BEQ      |L38.82|
00002c  e040              B        |L38.176|
                  |L38.46|
00002e  4620              MOV      r0,r4                 ;606
000030  f7fffffe          BL       TI1_Config
000034  88e9              LDRH     r1,[r5,#6]            ;610
000036  4620              MOV      r0,r4                 ;610
000038  e8bd5ff0          POP      {r4-r12,lr}           ;610
00003c  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L38.64|
000040  4620              MOV      r0,r4                 ;616
000042  f7fffffe          BL       TI2_Config
000046  88e9              LDRH     r1,[r5,#6]            ;620
000048  4620              MOV      r0,r4                 ;620
00004a  e8bd5ff0          POP      {r4-r12,lr}           ;620
00004e  f7ffbffe          B.W      TIM_SetIC2Prescaler
                  |L38.82|
000052  8c20              LDRH     r0,[r4,#0x20]         ;620
000054  f4207080          BIC      r0,r0,#0x100          ;620
000058  8420              STRH     r0,[r4,#0x20]         ;620
00005a  8ba2              LDRH     r2,[r4,#0x1c]         ;620
00005c  8c20              LDRH     r0,[r4,#0x20]         ;620
00005e  051b              LSLS     r3,r3,#20             ;620
000060  f02202f3          BIC      r2,r2,#0xf3           ;620
000064  ea4b4313          ORR      r3,r11,r3,LSR #16     ;620
000068  ea4f6c01          LSL      r12,r1,#24            ;620
00006c  4313              ORRS     r3,r3,r2              ;620
00006e  ea4f4e1c          LSR      lr,r12,#16            ;620
000072  42b4              CMP      r4,r6                 ;620
000074  d00a              BEQ      |L38.140|
000076  42bc              CMP      r4,r7                 ;620
000078  d008              BEQ      |L38.140|
00007a  4554              CMP      r4,r10                ;620
00007c  d006              BEQ      |L38.140|
00007e  4544              CMP      r4,r8                 ;620
000080  d004              BEQ      |L38.140|
000082  454c              CMP      r4,r9                 ;620
000084  d002              BEQ      |L38.140|
000086  4a27              LDR      r2,|L38.292|
000088  4294              CMP      r4,r2                 ;620
00008a  d104              BNE      |L38.150|
                  |L38.140|
00008c  f4207000          BIC      r0,r0,#0x200          ;620
000090  ea40000e          ORR      r0,r0,lr              ;620
000094  e002              B        |L38.156|
                  |L38.150|
000096  f4206020          BIC      r0,r0,#0xa00          ;620
00009a  4308              ORRS     r0,r0,r1              ;620
                  |L38.156|
00009c  f4407080          ORR      r0,r0,#0x100          ;620
0000a0  83a3              STRH     r3,[r4,#0x1c]         ;620
0000a2  8420              STRH     r0,[r4,#0x20]         ;620
0000a4  88e9              LDRH     r1,[r5,#6]            ;630
0000a6  4620              MOV      r0,r4                 ;630
0000a8  e8bd5ff0          POP      {r4-r12,lr}           ;630
0000ac  f7ffbffe          B.W      TIM_SetIC3Prescaler
                  |L38.176|
0000b0  8c20              LDRH     r0,[r4,#0x20]         ;630
0000b2  f4205080          BIC      r0,r0,#0x1000         ;630
0000b6  8420              STRH     r0,[r4,#0x20]         ;630
0000b8  f8b4c01c          LDRH     r12,[r4,#0x1c]        ;630
0000bc  8c20              LDRH     r0,[r4,#0x20]         ;630
0000be  070a              LSLS     r2,r1,#28             ;630
0000c0  ea4f4e12          LSR      lr,r2,#16             ;630
0000c4  f42c4c73          BIC      r12,r12,#0xf300       ;630
0000c8  ea4f620b          LSL      r2,r11,#24            ;630
0000cc  071b              LSLS     r3,r3,#28             ;630
0000ce  ea4c4212          ORR      r2,r12,r2,LSR #16     ;630
0000d2  ea424313          ORR      r3,r2,r3,LSR #16      ;630
0000d6  42b4              CMP      r4,r6                 ;630
0000d8  d00a              BEQ      |L38.240|
0000da  42bc              CMP      r4,r7                 ;630
0000dc  d008              BEQ      |L38.240|
0000de  4554              CMP      r4,r10                ;630
0000e0  d006              BEQ      |L38.240|
0000e2  4544              CMP      r4,r8                 ;630
0000e4  d004              BEQ      |L38.240|
0000e6  454c              CMP      r4,r9                 ;630
0000e8  d002              BEQ      |L38.240|
0000ea  4a0e              LDR      r2,|L38.292|
0000ec  4294              CMP      r4,r2                 ;630
0000ee  d104              BNE      |L38.250|
                  |L38.240|
0000f0  f4205000          BIC      r0,r0,#0x2000         ;630
0000f4  ea40000e          ORR      r0,r0,lr              ;630
0000f8  e002              B        |L38.256|
                  |L38.250|
0000fa  f4204002          BIC      r0,r0,#0x8200         ;630
0000fe  4308              ORRS     r0,r0,r1              ;630
                  |L38.256|
000100  f4405080          ORR      r0,r0,#0x1000         ;630
000104  83a3              STRH     r3,[r4,#0x1c]         ;630
000106  8420              STRH     r0,[r4,#0x20]         ;630
;;;637                   TIM_ICInitStruct->TIM_ICSelection,
;;;638                   TIM_ICInitStruct->TIM_ICFilter);
;;;639        /* Set the Input Capture Prescaler value */
;;;640        TIM_SetIC4Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000108  88e9              LDRH     r1,[r5,#6]
00010a  4620              MOV      r0,r4
00010c  e8bd5ff0          POP      {r4-r12,lr}
000110  f7ffbffe          B.W      TIM_SetIC4Prescaler
;;;641      }
;;;642    }
;;;643    
                          ENDP

                  |L38.276|
                          DCD      0x40012c00
                  |L38.280|
                          DCD      0x40013400
                  |L38.284|
                          DCD      0x40000400
                  |L38.288|
                          DCD      0x40000800
                  |L38.292|
                          DCD      0x40000c00

                          AREA ||i.TIM_ICStructInit||, CODE, READONLY, ALIGN=1

                  TIM_ICStructInit PROC
;;;768      */
;;;769    void TIM_ICStructInit(TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  2100              MOVS     r1,#0
;;;770    {
;;;771      /* Set the default configuration */
;;;772      TIM_ICInitStruct->TIM_Channel = TIM_Channel_1;
000002  8001              STRH     r1,[r0,#0]
;;;773      TIM_ICInitStruct->TIM_ICPolarity = TIM_ICPolarity_Rising;
000004  8041              STRH     r1,[r0,#2]
;;;774      TIM_ICInitStruct->TIM_ICSelection = TIM_ICSelection_DirectTI;
000006  2201              MOVS     r2,#1
000008  8082              STRH     r2,[r0,#4]
;;;775      TIM_ICInitStruct->TIM_ICPrescaler = TIM_ICPSC_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;776      TIM_ICInitStruct->TIM_ICFilter = 0x00;
00000c  8101              STRH     r1,[r0,#8]
;;;777    }
00000e  4770              BX       lr
;;;778    
                          ENDP


                          AREA ||i.TIM_ITConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITConfig PROC
;;;869      */
;;;870    void TIM_ITConfig(TIM_TypeDef* TIMx, uint16_t TIM_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;871    {  
;;;872      /* Check the parameters */
;;;873      assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;874      assert_param(IS_TIM_IT(TIM_IT));
;;;875      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;876      
;;;877      if (NewState != DISABLE)
;;;878      {
;;;879        /* Enable the Interrupt sources */
;;;880        TIMx->DIER |= TIM_IT;
;;;881      }
;;;882      else
;;;883      {
;;;884        /* Disable the Interrupt sources */
;;;885        TIMx->DIER &= (uint16_t)~TIM_IT;
000002  8982              LDRH     r2,[r0,#0xc]
000004  d001              BEQ      |L40.10|
000006  430a              ORRS     r2,r2,r1              ;880
000008  e000              B        |L40.12|
                  |L40.10|
00000a  438a              BICS     r2,r2,r1
                  |L40.12|
00000c  8182              STRH     r2,[r0,#0xc]          ;880
;;;886      }
;;;887    }
00000e  4770              BX       lr
;;;888    
                          ENDP


                          AREA ||i.TIM_ITRxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_ITRxExternalClockConfig PROC
;;;1005     */
;;;1006   void TIM_ITRxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
000002  f0220270          BIC      r2,r2,#0x70
000006  430a              ORRS     r2,r2,r1
000008  8102              STRH     r2,[r0,#8]
;;;1007   {
;;;1008     /* Check the parameters */
;;;1009     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1010     assert_param(IS_TIM_INTERNAL_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1011     /* Select the Internal Trigger */
;;;1012     TIM_SelectInputTrigger(TIMx, TIM_InputTriggerSource);
;;;1013     /* Select the External clock mode1 */
;;;1014     TIMx->SMCR |= TIM_SlaveMode_External1;
00000a  8901              LDRH     r1,[r0,#8]
00000c  f0410107          ORR      r1,r1,#7
000010  8101              STRH     r1,[r0,#8]
;;;1015   }
000012  4770              BX       lr
;;;1016   
                          ENDP


                          AREA ||i.TIM_InternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_InternalClockConfig PROC
;;;986      */
;;;987    void TIM_InternalClockConfig(TIM_TypeDef* TIMx)
000000  8901              LDRH     r1,[r0,#8]
;;;988    {
;;;989      /* Check the parameters */
;;;990      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;991      /* Disable slave mode to clock the prescaler directly with the internal clock */
;;;992      TIMx->SMCR &=  (uint16_t)(~((uint16_t)TIM_SMCR_SMS));
000002  f0210107          BIC      r1,r1,#7
000006  8101              STRH     r1,[r0,#8]
;;;993    }
000008  4770              BX       lr
;;;994    
                          ENDP


                          AREA ||i.TIM_OC1FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1FastConfig PROC
;;;1603     */
;;;1604   void TIM_OC1FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1605   {
;;;1606     uint16_t tmpccmr1 = 0;
;;;1607     /* Check the parameters */
;;;1608     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1609     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1610     /* Get the TIMx CCMR1 register value */
;;;1611     tmpccmr1 = TIMx->CCMR1;
;;;1612     /* Reset the OC1FE Bit */
;;;1613     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1FE);
000002  f0220204          BIC      r2,r2,#4
;;;1614     /* Enable or Disable the Output Compare Fast Bit */
;;;1615     tmpccmr1 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1616     /* Write to TIMx CCMR1 */
;;;1617     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1618   }
00000a  4770              BX       lr
;;;1619   
                          ENDP


                          AREA ||i.TIM_OC1Init||, CODE, READONLY, ALIGN=2

                  TIM_OC1Init PROC
;;;276      */
;;;277    void TIM_OC1Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;278    {
;;;279      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;280       
;;;281      /* Check the parameters */
;;;282      assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;283      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;284      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;285      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;286     /* Disable the Channel 1: Reset the CC1E Bit */
;;;287      TIMx->CCER &= (uint16_t)(~(uint16_t)TIM_CCER_CC1E);
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220201          BIC      r2,r2,#1
000008  8402              STRH     r2,[r0,#0x20]
;;;288      /* Get the TIMx CCER register value */
;;;289      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;290      /* Get the TIMx CR2 register value */
;;;291      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;292      
;;;293      /* Get the TIMx CCMR1 register value */
;;;294      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;295        
;;;296      /* Reset the Output Compare Mode Bits */
;;;297      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC1M));
;;;298      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC1S));
;;;299    
;;;300      /* Select the Output Compare Mode */
;;;301      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;302      
;;;303      /* Reset the Output Polarity level */
;;;304      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1P));
000010  f0220202          BIC      r2,r2,#2
000014  f0240573          BIC      r5,r4,#0x73           ;298
000018  880c              LDRH     r4,[r1,#0]            ;301
00001a  432c              ORRS     r4,r4,r5              ;301
;;;305      /* Set the Output Compare Polarity */
;;;306      tmpccer |= TIM_OCInitStruct->TIM_OCPolarity;
00001c  890d              LDRH     r5,[r1,#8]
00001e  4315              ORRS     r5,r5,r2
;;;307      
;;;308      /* Set the Output State */
;;;309      tmpccer |= TIM_OCInitStruct->TIM_OutputState;
000020  884a              LDRH     r2,[r1,#2]
000022  432a              ORRS     r2,r2,r5
;;;310        
;;;311      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)||
000024  4d11              LDR      r5,|L44.108|
000026  42a8              CMP      r0,r5
000028  d00b              BEQ      |L44.66|
00002a  4d11              LDR      r5,|L44.112|
00002c  42a8              CMP      r0,r5
00002e  d008              BEQ      |L44.66|
000030  4d10              LDR      r5,|L44.116|
000032  42a8              CMP      r0,r5
000034  d005              BEQ      |L44.66|
;;;312         (TIMx == TIM16)|| (TIMx == TIM17))
000036  4d10              LDR      r5,|L44.120|
000038  42a8              CMP      r0,r5
00003a  d002              BEQ      |L44.66|
00003c  4d0f              LDR      r5,|L44.124|
00003e  42a8              CMP      r0,r5
000040  d10d              BNE      |L44.94|
                  |L44.66|
;;;313      {
;;;314        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;315        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;316        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;317        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;318        
;;;319        /* Reset the Output N Polarity level */
;;;320        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NP));
000042  f0220508          BIC      r5,r2,#8
;;;321        /* Set the Output N Polarity */
;;;322        tmpccer |= TIM_OCInitStruct->TIM_OCNPolarity;
000046  894a              LDRH     r2,[r1,#0xa]
;;;323        
;;;324        /* Reset the Output N State */
;;;325        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC1NE));    
;;;326        /* Set the Output N State */
;;;327        tmpccer |= TIM_OCInitStruct->TIM_OutputNState;
;;;328        
;;;329        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;330        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1));
;;;331        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS1N));
000048  f4237340          BIC      r3,r3,#0x300
00004c  432a              ORRS     r2,r2,r5              ;322
00004e  f0220504          BIC      r5,r2,#4              ;325
000052  888a              LDRH     r2,[r1,#4]            ;327
000054  432a              ORRS     r2,r2,r5              ;327
;;;332        
;;;333        /* Set the Output Idle state */
;;;334        tmpcr2 |= TIM_OCInitStruct->TIM_OCIdleState;
000056  898d              LDRH     r5,[r1,#0xc]
000058  431d              ORRS     r5,r5,r3
;;;335        /* Set the Output N Idle state */
;;;336        tmpcr2 |= TIM_OCInitStruct->TIM_OCNIdleState;
00005a  89cb              LDRH     r3,[r1,#0xe]
00005c  432b              ORRS     r3,r3,r5
                  |L44.94|
;;;337      }
;;;338      /* Write to TIMx CR2 */
;;;339      TIMx->CR2 = tmpcr2;
00005e  8083              STRH     r3,[r0,#4]
;;;340      
;;;341      /* Write to TIMx CCMR1 */
;;;342      TIMx->CCMR1 = tmpccmrx;
000060  8304              STRH     r4,[r0,#0x18]
;;;343    
;;;344      /* Set the Capture Compare Register value */
;;;345      TIMx->CCR1 = TIM_OCInitStruct->TIM_Pulse; 
000062  88c9              LDRH     r1,[r1,#6]
000064  8681              STRH     r1,[r0,#0x34]
;;;346     
;;;347      /* Write to TIMx CCER */
;;;348      TIMx->CCER = tmpccer;
000066  8402              STRH     r2,[r0,#0x20]
;;;349    }
000068  bd30              POP      {r4,r5,pc}
;;;350    
                          ENDP

00006a  0000              DCW      0x0000
                  |L44.108|
                          DCD      0x40012c00
                  |L44.112|
                          DCD      0x40013400
                  |L44.116|
                          DCD      0x40014000
                  |L44.120|
                          DCD      0x40014400
                  |L44.124|
                          DCD      0x40014800

                          AREA ||i.TIM_OC1NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1NPolarityConfig PROC
;;;1825     */
;;;1826   void TIM_OC1NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1827   {
;;;1828     uint16_t tmpccer = 0;
;;;1829     /* Check the parameters */
;;;1830     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1831     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1832      
;;;1833     tmpccer = TIMx->CCER;
;;;1834     /* Set or Reset the CC1NP Bit */
;;;1835     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1NP);
000002  f0220208          BIC      r2,r2,#8
;;;1836     tmpccer |= TIM_OCNPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1837     /* Write to TIMx CCER register */
;;;1838     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1839   }
00000a  4770              BX       lr
;;;1840   
                          ENDP


                          AREA ||i.TIM_OC1PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PolarityConfig PROC
;;;1802     */
;;;1803   void TIM_OC1PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1804   {
;;;1805     uint16_t tmpccer = 0;
;;;1806     /* Check the parameters */
;;;1807     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1808     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1809     tmpccer = TIMx->CCER;
;;;1810     /* Set or Reset the CC1P Bit */
;;;1811     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC1P);
000002  f0220202          BIC      r2,r2,#2
;;;1812     tmpccer |= TIM_OCPolarity;
000006  430a              ORRS     r2,r2,r1
;;;1813     /* Write to TIMx CCER register */
;;;1814     TIMx->CCER = tmpccer;
000008  8402              STRH     r2,[r0,#0x20]
;;;1815   }
00000a  4770              BX       lr
;;;1816   
                          ENDP


                          AREA ||i.TIM_OC1PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC1PreloadConfig PROC
;;;1506     */
;;;1507   void TIM_OC1PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1508   {
;;;1509     uint16_t tmpccmr1 = 0;
;;;1510     /* Check the parameters */
;;;1511     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;1512     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1513     tmpccmr1 = TIMx->CCMR1;
;;;1514     /* Reset the OC1PE Bit */
;;;1515     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC1PE);
000002  f0220208          BIC      r2,r2,#8
;;;1516     /* Enable or Disable the Output Compare Preload feature */
;;;1517     tmpccmr1 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1518     /* Write to TIMx CCMR1 register */
;;;1519     TIMx->CCMR1 = tmpccmr1;
000008  8302              STRH     r2,[r0,#0x18]
;;;1520   }
00000a  4770              BX       lr
;;;1521   
                          ENDP


                          AREA ||i.TIM_OC2FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2FastConfig PROC
;;;1629     */
;;;1630   void TIM_OC2FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1631   {
;;;1632     uint16_t tmpccmr1 = 0;
;;;1633     /* Check the parameters */
;;;1634     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1635     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1636     /* Get the TIMx CCMR1 register value */
;;;1637     tmpccmr1 = TIMx->CCMR1;
;;;1638     /* Reset the OC2FE Bit */
;;;1639     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1640     /* Enable or Disable the Output Compare Fast Bit */
;;;1641     tmpccmr1 |= (uint16_t)(TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1642     /* Write to TIMx CCMR1 */
;;;1643     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1644   }
00000c  4770              BX       lr
;;;1645   
                          ENDP


                          AREA ||i.TIM_OC2Init||, CODE, READONLY, ALIGN=2

                  TIM_OC2Init PROC
;;;359      */
;;;360    void TIM_OC2Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;361    {
;;;362      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;363       
;;;364      /* Check the parameters */
;;;365      assert_param(IS_TIM_LIST6_PERIPH(TIMx)); 
;;;366      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;367      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;368      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;369       /* Disable the Channel 2: Reset the CC2E Bit */
;;;370      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC2E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f0220210          BIC      r2,r2,#0x10
000008  8402              STRH     r2,[r0,#0x20]
;;;371      
;;;372      /* Get the TIMx CCER register value */  
;;;373      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;374      /* Get the TIMx CR2 register value */
;;;375      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;376      
;;;377      /* Get the TIMx CCMR1 register value */
;;;378      tmpccmrx = TIMx->CCMR1;
00000e  8b04              LDRH     r4,[r0,#0x18]
;;;379        
;;;380      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;381      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_OC2M));
;;;382      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR1_CC2S));
;;;383      
;;;384      /* Select the Output Compare Mode */
;;;385      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
;;;386      
;;;387      /* Reset the Output Polarity level */
;;;388      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2P));
000010  f0220220          BIC      r2,r2,#0x20
000014  f42445e6          BIC      r5,r4,#0x7300         ;382
000018  880c              LDRH     r4,[r1,#0]            ;385
00001a  0624              LSLS     r4,r4,#24             ;385
00001c  ea454414          ORR      r4,r5,r4,LSR #16      ;385
;;;389      /* Set the Output Compare Polarity */
;;;390      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 4);
000020  890d              LDRH     r5,[r1,#8]
000022  052d              LSLS     r5,r5,#20
000024  ea424515          ORR      r5,r2,r5,LSR #16
;;;391      
;;;392      /* Set the Output State */
;;;393      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 4);
000028  884a              LDRH     r2,[r1,#2]
00002a  0512              LSLS     r2,r2,#20
00002c  ea454212          ORR      r2,r5,r2,LSR #16
;;;394        
;;;395      if((TIMx == TIM1) || (TIMx == TIM8))
000030  4d10              LDR      r5,|L49.116|
000032  42a8              CMP      r0,r5
000034  d002              BEQ      |L49.60|
000036  4d10              LDR      r5,|L49.120|
000038  42a8              CMP      r0,r5
00003a  d115              BNE      |L49.104|
                  |L49.60|
;;;396      {
;;;397        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;398        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;399        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;400        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;401        
;;;402        /* Reset the Output N Polarity level */
;;;403        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NP));
00003c  f0220580          BIC      r5,r2,#0x80
;;;404        /* Set the Output N Polarity */
;;;405        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 4);
000040  894a              LDRH     r2,[r1,#0xa]
;;;406        
;;;407        /* Reset the Output N State */
;;;408        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC2NE));    
;;;409        /* Set the Output N State */
;;;410        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 4);
;;;411        
;;;412        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;413        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2));
;;;414        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS2N));
000042  f4236340          BIC      r3,r3,#0xc00
000046  0512              LSLS     r2,r2,#20             ;405
000048  ea454212          ORR      r2,r5,r2,LSR #16      ;405
00004c  f0220540          BIC      r5,r2,#0x40           ;408
000050  888a              LDRH     r2,[r1,#4]            ;410
000052  0512              LSLS     r2,r2,#20             ;410
000054  ea454212          ORR      r2,r5,r2,LSR #16      ;410
;;;415        
;;;416        /* Set the Output Idle state */
;;;417        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 2);
000058  898d              LDRH     r5,[r1,#0xc]
00005a  04ad              LSLS     r5,r5,#18
00005c  ea434515          ORR      r5,r3,r5,LSR #16
;;;418        /* Set the Output N Idle state */
;;;419        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 2);
000060  89cb              LDRH     r3,[r1,#0xe]
000062  049b              LSLS     r3,r3,#18
000064  ea454313          ORR      r3,r5,r3,LSR #16
                  |L49.104|
;;;420      }
;;;421      /* Write to TIMx CR2 */
;;;422      TIMx->CR2 = tmpcr2;
000068  8083              STRH     r3,[r0,#4]
;;;423      
;;;424      /* Write to TIMx CCMR1 */
;;;425      TIMx->CCMR1 = tmpccmrx;
00006a  8304              STRH     r4,[r0,#0x18]
;;;426    
;;;427      /* Set the Capture Compare Register value */
;;;428      TIMx->CCR2 = TIM_OCInitStruct->TIM_Pulse;
00006c  88c9              LDRH     r1,[r1,#6]
00006e  8701              STRH     r1,[r0,#0x38]
;;;429      
;;;430      /* Write to TIMx CCER */
;;;431      TIMx->CCER = tmpccer;
000070  8402              STRH     r2,[r0,#0x20]
;;;432    }
000072  bd30              POP      {r4,r5,pc}
;;;433    
                          ENDP

                  |L49.116|
                          DCD      0x40012c00
                  |L49.120|
                          DCD      0x40013400

                          AREA ||i.TIM_OC2NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2NPolarityConfig PROC
;;;1872     */
;;;1873   void TIM_OC2NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1874   {
;;;1875     uint16_t tmpccer = 0;
;;;1876     /* Check the parameters */
;;;1877     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1878     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1879     
;;;1880     tmpccer = TIMx->CCER;
;;;1881     /* Set or Reset the CC2NP Bit */
;;;1882     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2NP);
000002  f0220280          BIC      r2,r2,#0x80
;;;1883     tmpccer |= (uint16_t)(TIM_OCNPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;1884     /* Write to TIMx CCER register */
;;;1885     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1886   }
00000c  4770              BX       lr
;;;1887   
                          ENDP


                          AREA ||i.TIM_OC2PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PolarityConfig PROC
;;;1849     */
;;;1850   void TIM_OC2PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1851   {
;;;1852     uint16_t tmpccer = 0;
;;;1853     /* Check the parameters */
;;;1854     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1855     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1856     tmpccer = TIMx->CCER;
;;;1857     /* Set or Reset the CC2P Bit */
;;;1858     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC2P);
000002  f0220220          BIC      r2,r2,#0x20
;;;1859     tmpccer |= (uint16_t)(TIM_OCPolarity << 4);
000006  ea421101          ORR      r1,r2,r1,LSL #4
;;;1860     /* Write to TIMx CCER register */
;;;1861     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1862   }
00000c  4770              BX       lr
;;;1863   
                          ENDP


                          AREA ||i.TIM_OC2PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC2PreloadConfig PROC
;;;1531     */
;;;1532   void TIM_OC2PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;1533   {
;;;1534     uint16_t tmpccmr1 = 0;
;;;1535     /* Check the parameters */
;;;1536     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1537     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1538     tmpccmr1 = TIMx->CCMR1;
;;;1539     /* Reset the OC2PE Bit */
;;;1540     tmpccmr1 &= (uint16_t)~((uint16_t)TIM_CCMR1_OC2PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1541     /* Enable or Disable the Output Compare Preload feature */
;;;1542     tmpccmr1 |= (uint16_t)(TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1543     /* Write to TIMx CCMR1 register */
;;;1544     TIMx->CCMR1 = tmpccmr1;
00000a  8301              STRH     r1,[r0,#0x18]
;;;1545   }
00000c  4770              BX       lr
;;;1546   
                          ENDP


                          AREA ||i.TIM_OC3FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3FastConfig PROC
;;;1654     */
;;;1655   void TIM_OC3FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1656   {
;;;1657     uint16_t tmpccmr2 = 0;
;;;1658     /* Check the parameters */
;;;1659     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1660     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1661     /* Get the TIMx CCMR2 register value */
;;;1662     tmpccmr2 = TIMx->CCMR2;
;;;1663     /* Reset the OC3FE Bit */
;;;1664     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3FE);
000002  f0220204          BIC      r2,r2,#4
;;;1665     /* Enable or Disable the Output Compare Fast Bit */
;;;1666     tmpccmr2 |= TIM_OCFast;
000006  430a              ORRS     r2,r2,r1
;;;1667     /* Write to TIMx CCMR2 */
;;;1668     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1669   }
00000a  4770              BX       lr
;;;1670   
                          ENDP


                          AREA ||i.TIM_OC3Init||, CODE, READONLY, ALIGN=2

                  TIM_OC3Init PROC
;;;441      */
;;;442    void TIM_OC3Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;443    {
;;;444      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;445       
;;;446      /* Check the parameters */
;;;447      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;448      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;449      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;450      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;451      /* Disable the Channel 2: Reset the CC2E Bit */
;;;452      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC3E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4227280          BIC      r2,r2,#0x100
000008  8402              STRH     r2,[r0,#0x20]
;;;453      
;;;454      /* Get the TIMx CCER register value */
;;;455      tmpccer = TIMx->CCER;
00000a  8c02              LDRH     r2,[r0,#0x20]
;;;456      /* Get the TIMx CR2 register value */
;;;457      tmpcr2 =  TIMx->CR2;
00000c  8883              LDRH     r3,[r0,#4]
;;;458      
;;;459      /* Get the TIMx CCMR2 register value */
;;;460      tmpccmrx = TIMx->CCMR2;
00000e  8b84              LDRH     r4,[r0,#0x1c]
;;;461        
;;;462      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;463      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC3M));
;;;464      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC3S));  
;;;465      /* Select the Output Compare Mode */
;;;466      tmpccmrx |= TIM_OCInitStruct->TIM_OCMode;
;;;467      
;;;468      /* Reset the Output Polarity level */
;;;469      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3P));
000010  f4227200          BIC      r2,r2,#0x200
000014  f0240573          BIC      r5,r4,#0x73           ;464
000018  880c              LDRH     r4,[r1,#0]            ;466
00001a  432c              ORRS     r4,r4,r5              ;466
;;;470      /* Set the Output Compare Polarity */
;;;471      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 8);
00001c  890d              LDRH     r5,[r1,#8]
00001e  062d              LSLS     r5,r5,#24
000020  ea424515          ORR      r5,r2,r5,LSR #16
;;;472      
;;;473      /* Set the Output State */
;;;474      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 8);
000024  884a              LDRH     r2,[r1,#2]
000026  0612              LSLS     r2,r2,#24
000028  ea454212          ORR      r2,r5,r2,LSR #16
;;;475        
;;;476      if((TIMx == TIM1) || (TIMx == TIM8))
00002c  4d10              LDR      r5,|L54.112|
00002e  42a8              CMP      r0,r5
000030  d002              BEQ      |L54.56|
000032  4d10              LDR      r5,|L54.116|
000034  42a8              CMP      r0,r5
000036  d115              BNE      |L54.100|
                  |L54.56|
;;;477      {
;;;478        assert_param(IS_TIM_OUTPUTN_STATE(TIM_OCInitStruct->TIM_OutputNState));
;;;479        assert_param(IS_TIM_OCN_POLARITY(TIM_OCInitStruct->TIM_OCNPolarity));
;;;480        assert_param(IS_TIM_OCNIDLE_STATE(TIM_OCInitStruct->TIM_OCNIdleState));
;;;481        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;482        
;;;483        /* Reset the Output N Polarity level */
;;;484        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NP));
000038  f4226500          BIC      r5,r2,#0x800
;;;485        /* Set the Output N Polarity */
;;;486        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCNPolarity << 8);
00003c  894a              LDRH     r2,[r1,#0xa]
;;;487        /* Reset the Output N State */
;;;488        tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC3NE));
;;;489        
;;;490        /* Set the Output N State */
;;;491        tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputNState << 8);
;;;492        /* Reset the Ouput Compare and Output Compare N IDLE State */
;;;493        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3));
;;;494        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS3N));
00003e  f4235340          BIC      r3,r3,#0x3000
000042  0612              LSLS     r2,r2,#24             ;486
000044  ea454212          ORR      r2,r5,r2,LSR #16      ;486
000048  f4226580          BIC      r5,r2,#0x400          ;488
00004c  888a              LDRH     r2,[r1,#4]            ;491
00004e  0612              LSLS     r2,r2,#24             ;491
000050  ea454212          ORR      r2,r5,r2,LSR #16      ;491
;;;495        /* Set the Output Idle state */
;;;496        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 4);
000054  898d              LDRH     r5,[r1,#0xc]
000056  052d              LSLS     r5,r5,#20
000058  ea434515          ORR      r5,r3,r5,LSR #16
;;;497        /* Set the Output N Idle state */
;;;498        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCNIdleState << 4);
00005c  89cb              LDRH     r3,[r1,#0xe]
00005e  051b              LSLS     r3,r3,#20
000060  ea454313          ORR      r3,r5,r3,LSR #16
                  |L54.100|
;;;499      }
;;;500      /* Write to TIMx CR2 */
;;;501      TIMx->CR2 = tmpcr2;
000064  8083              STRH     r3,[r0,#4]
;;;502      
;;;503      /* Write to TIMx CCMR2 */
;;;504      TIMx->CCMR2 = tmpccmrx;
000066  8384              STRH     r4,[r0,#0x1c]
;;;505    
;;;506      /* Set the Capture Compare Register value */
;;;507      TIMx->CCR3 = TIM_OCInitStruct->TIM_Pulse;
000068  88c9              LDRH     r1,[r1,#6]
00006a  8781              STRH     r1,[r0,#0x3c]
;;;508      
;;;509      /* Write to TIMx CCER */
;;;510      TIMx->CCER = tmpccer;
00006c  8402              STRH     r2,[r0,#0x20]
;;;511    }
00006e  bd30              POP      {r4,r5,pc}
;;;512    
                          ENDP

                  |L54.112|
                          DCD      0x40012c00
                  |L54.116|
                          DCD      0x40013400

                          AREA ||i.TIM_OC3NPolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3NPolarityConfig PROC
;;;1919     */
;;;1920   void TIM_OC3NPolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCNPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1921   {
;;;1922     uint16_t tmpccer = 0;
;;;1923    
;;;1924     /* Check the parameters */
;;;1925     assert_param(IS_TIM_LIST1_PERIPH(TIMx));
;;;1926     assert_param(IS_TIM_OCN_POLARITY(TIM_OCNPolarity));
;;;1927       
;;;1928     tmpccer = TIMx->CCER;
;;;1929     /* Set or Reset the CC3NP Bit */
;;;1930     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3NP);
000002  f4226200          BIC      r2,r2,#0x800
;;;1931     tmpccer |= (uint16_t)(TIM_OCNPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1932     /* Write to TIMx CCER register */
;;;1933     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1934   }
00000c  4770              BX       lr
;;;1935   
                          ENDP


                          AREA ||i.TIM_OC3PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PolarityConfig PROC
;;;1896     */
;;;1897   void TIM_OC3PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1898   {
;;;1899     uint16_t tmpccer = 0;
;;;1900     /* Check the parameters */
;;;1901     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1902     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1903     tmpccer = TIMx->CCER;
;;;1904     /* Set or Reset the CC3P Bit */
;;;1905     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC3P);
000002  f4227200          BIC      r2,r2,#0x200
;;;1906     tmpccer |= (uint16_t)(TIM_OCPolarity << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1907     /* Write to TIMx CCER register */
;;;1908     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1909   }
00000c  4770              BX       lr
;;;1910   
                          ENDP


                          AREA ||i.TIM_OC3PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC3PreloadConfig PROC
;;;1555     */
;;;1556   void TIM_OC3PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1557   {
;;;1558     uint16_t tmpccmr2 = 0;
;;;1559     /* Check the parameters */
;;;1560     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1561     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1562     tmpccmr2 = TIMx->CCMR2;
;;;1563     /* Reset the OC3PE Bit */
;;;1564     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC3PE);
000002  f0220208          BIC      r2,r2,#8
;;;1565     /* Enable or Disable the Output Compare Preload feature */
;;;1566     tmpccmr2 |= TIM_OCPreload;
000006  430a              ORRS     r2,r2,r1
;;;1567     /* Write to TIMx CCMR2 register */
;;;1568     TIMx->CCMR2 = tmpccmr2;
000008  8382              STRH     r2,[r0,#0x1c]
;;;1569   }
00000a  4770              BX       lr
;;;1570   
                          ENDP


                          AREA ||i.TIM_OC4FastConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4FastConfig PROC
;;;1679     */
;;;1680   void TIM_OC4FastConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCFast)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1681   {
;;;1682     uint16_t tmpccmr2 = 0;
;;;1683     /* Check the parameters */
;;;1684     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1685     assert_param(IS_TIM_OCFAST_STATE(TIM_OCFast));
;;;1686     /* Get the TIMx CCMR2 register value */
;;;1687     tmpccmr2 = TIMx->CCMR2;
;;;1688     /* Reset the OC4FE Bit */
;;;1689     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4FE);
000002  f4226280          BIC      r2,r2,#0x400
;;;1690     /* Enable or Disable the Output Compare Fast Bit */
;;;1691     tmpccmr2 |= (uint16_t)(TIM_OCFast << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1692     /* Write to TIMx CCMR2 */
;;;1693     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1694   }
00000c  4770              BX       lr
;;;1695   
                          ENDP


                          AREA ||i.TIM_OC4Init||, CODE, READONLY, ALIGN=2

                  TIM_OC4Init PROC
;;;520      */
;;;521    void TIM_OC4Init(TIM_TypeDef* TIMx, TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;522    {
;;;523      uint16_t tmpccmrx = 0, tmpccer = 0, tmpcr2 = 0;
;;;524       
;;;525      /* Check the parameters */
;;;526      assert_param(IS_TIM_LIST3_PERIPH(TIMx)); 
;;;527      assert_param(IS_TIM_OC_MODE(TIM_OCInitStruct->TIM_OCMode));
;;;528      assert_param(IS_TIM_OUTPUT_STATE(TIM_OCInitStruct->TIM_OutputState));
;;;529      assert_param(IS_TIM_OC_POLARITY(TIM_OCInitStruct->TIM_OCPolarity));   
;;;530      /* Disable the Channel 2: Reset the CC4E Bit */
;;;531      TIMx->CCER &= (uint16_t)(~((uint16_t)TIM_CCER_CC4E));
000002  8c02              LDRH     r2,[r0,#0x20]
000004  f4225280          BIC      r2,r2,#0x1000
000008  8402              STRH     r2,[r0,#0x20]
;;;532      
;;;533      /* Get the TIMx CCER register value */
;;;534      tmpccer = TIMx->CCER;
00000a  8c04              LDRH     r4,[r0,#0x20]
;;;535      /* Get the TIMx CR2 register value */
;;;536      tmpcr2 =  TIMx->CR2;
00000c  8882              LDRH     r2,[r0,#4]
;;;537      
;;;538      /* Get the TIMx CCMR2 register value */
;;;539      tmpccmrx = TIMx->CCMR2;
00000e  8b83              LDRH     r3,[r0,#0x1c]
;;;540        
;;;541      /* Reset the Output Compare mode and Capture/Compare selection Bits */
;;;542      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_OC4M));
;;;543      tmpccmrx &= (uint16_t)(~((uint16_t)TIM_CCMR2_CC4S));
000010  f42345e6          BIC      r5,r3,#0x7300
;;;544      
;;;545      /* Select the Output Compare Mode */
;;;546      tmpccmrx |= (uint16_t)(TIM_OCInitStruct->TIM_OCMode << 8);
000014  880b              LDRH     r3,[r1,#0]
000016  061b              LSLS     r3,r3,#24
000018  ea454313          ORR      r3,r5,r3,LSR #16
;;;547      
;;;548      /* Reset the Output Polarity level */
;;;549      tmpccer &= (uint16_t)(~((uint16_t)TIM_CCER_CC4P));
00001c  f4245500          BIC      r5,r4,#0x2000
;;;550      /* Set the Output Compare Polarity */
;;;551      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OCPolarity << 12);
000020  890c              LDRH     r4,[r1,#8]
000022  0724              LSLS     r4,r4,#28
000024  ea454414          ORR      r4,r5,r4,LSR #16
;;;552      
;;;553      /* Set the Output State */
;;;554      tmpccer |= (uint16_t)(TIM_OCInitStruct->TIM_OutputState << 12);
000028  884d              LDRH     r5,[r1,#2]
00002a  072d              LSLS     r5,r5,#28
00002c  ea444515          ORR      r5,r4,r5,LSR #16
;;;555        
;;;556      if((TIMx == TIM1) || (TIMx == TIM8))
000030  4c09              LDR      r4,|L59.88|
000032  42a0              CMP      r0,r4
000034  d002              BEQ      |L59.60|
000036  4c09              LDR      r4,|L59.92|
000038  42a0              CMP      r0,r4
00003a  d105              BNE      |L59.72|
                  |L59.60|
;;;557      {
;;;558        assert_param(IS_TIM_OCIDLE_STATE(TIM_OCInitStruct->TIM_OCIdleState));
;;;559        /* Reset the Ouput Compare IDLE State */
;;;560        tmpcr2 &= (uint16_t)(~((uint16_t)TIM_CR2_OIS4));
00003c  f4224480          BIC      r4,r2,#0x4000
;;;561        /* Set the Output Idle state */
;;;562        tmpcr2 |= (uint16_t)(TIM_OCInitStruct->TIM_OCIdleState << 6);
000040  898a              LDRH     r2,[r1,#0xc]
000042  0592              LSLS     r2,r2,#22
000044  ea444212          ORR      r2,r4,r2,LSR #16
                  |L59.72|
;;;563      }
;;;564      /* Write to TIMx CR2 */
;;;565      TIMx->CR2 = tmpcr2;
000048  8082              STRH     r2,[r0,#4]
;;;566      
;;;567      /* Write to TIMx CCMR2 */  
;;;568      TIMx->CCMR2 = tmpccmrx;
00004a  8383              STRH     r3,[r0,#0x1c]
;;;569    
;;;570      /* Set the Capture Compare Register value */
;;;571      TIMx->CCR4 = TIM_OCInitStruct->TIM_Pulse;
00004c  88c9              LDRH     r1,[r1,#6]
00004e  f8a01040          STRH     r1,[r0,#0x40]
;;;572      
;;;573      /* Write to TIMx CCER */
;;;574      TIMx->CCER = tmpccer;
000052  8405              STRH     r5,[r0,#0x20]
;;;575    }
000054  bd30              POP      {r4,r5,pc}
;;;576    
                          ENDP

000056  0000              DCW      0x0000
                  |L59.88|
                          DCD      0x40012c00
                  |L59.92|
                          DCD      0x40013400

                          AREA ||i.TIM_OC4PolarityConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PolarityConfig PROC
;;;1944     */
;;;1945   void TIM_OC4PolarityConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPolarity)
000000  8c02              LDRH     r2,[r0,#0x20]
;;;1946   {
;;;1947     uint16_t tmpccer = 0;
;;;1948     /* Check the parameters */
;;;1949     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1950     assert_param(IS_TIM_OC_POLARITY(TIM_OCPolarity));
;;;1951     tmpccer = TIMx->CCER;
;;;1952     /* Set or Reset the CC4P Bit */
;;;1953     tmpccer &= (uint16_t)~((uint16_t)TIM_CCER_CC4P);
000002  f4225200          BIC      r2,r2,#0x2000
;;;1954     tmpccer |= (uint16_t)(TIM_OCPolarity << 12);
000006  ea423101          ORR      r1,r2,r1,LSL #12
;;;1955     /* Write to TIMx CCER register */
;;;1956     TIMx->CCER = tmpccer;
00000a  8401              STRH     r1,[r0,#0x20]
;;;1957   }
00000c  4770              BX       lr
;;;1958   
                          ENDP


                          AREA ||i.TIM_OC4PreloadConfig||, CODE, READONLY, ALIGN=1

                  TIM_OC4PreloadConfig PROC
;;;1579     */
;;;1580   void TIM_OC4PreloadConfig(TIM_TypeDef* TIMx, uint16_t TIM_OCPreload)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;1581   {
;;;1582     uint16_t tmpccmr2 = 0;
;;;1583     /* Check the parameters */
;;;1584     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;1585     assert_param(IS_TIM_OCPRELOAD_STATE(TIM_OCPreload));
;;;1586     tmpccmr2 = TIMx->CCMR2;
;;;1587     /* Reset the OC4PE Bit */
;;;1588     tmpccmr2 &= (uint16_t)~((uint16_t)TIM_CCMR2_OC4PE);
000002  f4226200          BIC      r2,r2,#0x800
;;;1589     /* Enable or Disable the Output Compare Preload feature */
;;;1590     tmpccmr2 |= (uint16_t)(TIM_OCPreload << 8);
000006  ea422101          ORR      r1,r2,r1,LSL #8
;;;1591     /* Write to TIMx CCMR2 register */
;;;1592     TIMx->CCMR2 = tmpccmr2;
00000a  8381              STRH     r1,[r0,#0x1c]
;;;1593   }
00000c  4770              BX       lr
;;;1594   
                          ENDP


                          AREA ||i.TIM_OCStructInit||, CODE, READONLY, ALIGN=1

                  TIM_OCStructInit PROC
;;;749      */
;;;750    void TIM_OCStructInit(TIM_OCInitTypeDef* TIM_OCInitStruct)
000000  2100              MOVS     r1,#0
;;;751    {
;;;752      /* Set the default configuration */
;;;753      TIM_OCInitStruct->TIM_OCMode = TIM_OCMode_Timing;
000002  8001              STRH     r1,[r0,#0]
;;;754      TIM_OCInitStruct->TIM_OutputState = TIM_OutputState_Disable;
000004  8041              STRH     r1,[r0,#2]
;;;755      TIM_OCInitStruct->TIM_OutputNState = TIM_OutputNState_Disable;
000006  8081              STRH     r1,[r0,#4]
;;;756      TIM_OCInitStruct->TIM_Pulse = 0x0000;
000008  80c1              STRH     r1,[r0,#6]
;;;757      TIM_OCInitStruct->TIM_OCPolarity = TIM_OCPolarity_High;
00000a  8101              STRH     r1,[r0,#8]
;;;758      TIM_OCInitStruct->TIM_OCNPolarity = TIM_OCPolarity_High;
00000c  8141              STRH     r1,[r0,#0xa]
;;;759      TIM_OCInitStruct->TIM_OCIdleState = TIM_OCIdleState_Reset;
00000e  8181              STRH     r1,[r0,#0xc]
;;;760      TIM_OCInitStruct->TIM_OCNIdleState = TIM_OCNIdleState_Reset;
000010  81c1              STRH     r1,[r0,#0xe]
;;;761    }
000012  4770              BX       lr
;;;762    
                          ENDP


                          AREA ||i.TIM_PWMIConfig||, CODE, READONLY, ALIGN=1

                  TIM_PWMIConfig PROC
;;;651      */
;;;652    void TIM_PWMIConfig(TIM_TypeDef* TIMx, TIM_ICInitTypeDef* TIM_ICInitStruct)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;653    {
000004  460c              MOV      r4,r1
;;;654      uint16_t icoppositepolarity = TIM_ICPolarity_Rising;
000006  2500              MOVS     r5,#0
;;;655      uint16_t icoppositeselection = TIM_ICSelection_DirectTI;
;;;656      /* Check the parameters */
;;;657      assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;658      /* Select the Opposite Input Polarity */
;;;659      if (TIM_ICInitStruct->TIM_ICPolarity == TIM_ICPolarity_Rising)
000008  8849              LDRH     r1,[r1,#2]
00000a  4607              MOV      r7,r0                 ;653
00000c  2601              MOVS     r6,#1                 ;655
00000e  b901              CBNZ     r1,|L63.18|
;;;660      {
;;;661        icoppositepolarity = TIM_ICPolarity_Falling;
000010  2502              MOVS     r5,#2
                  |L63.18|
;;;662      }
;;;663      else
;;;664      {
;;;665        icoppositepolarity = TIM_ICPolarity_Rising;
;;;666      }
;;;667      /* Select the Opposite Input */
;;;668      if (TIM_ICInitStruct->TIM_ICSelection == TIM_ICSelection_DirectTI)
000012  88a2              LDRH     r2,[r4,#4]
000014  2a01              CMP      r2,#1
000016  d100              BNE      |L63.26|
;;;669      {
;;;670        icoppositeselection = TIM_ICSelection_IndirectTI;
000018  2602              MOVS     r6,#2
                  |L63.26|
;;;671      }
;;;672      else
;;;673      {
;;;674        icoppositeselection = TIM_ICSelection_DirectTI;
;;;675      }
;;;676      if (TIM_ICInitStruct->TIM_Channel == TIM_Channel_1)
00001a  8820              LDRH     r0,[r4,#0]
;;;677      {
;;;678        /* TI1 Configuration */
;;;679        TI1_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
00001c  8923              LDRH     r3,[r4,#8]
00001e  2800              CMP      r0,#0                 ;676
;;;680                   TIM_ICInitStruct->TIM_ICFilter);
;;;681        /* Set the Input Capture Prescaler value */
;;;682        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;683        /* TI2 Configuration */
;;;684        TI2_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
;;;685        /* Set the Input Capture Prescaler value */
;;;686        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
;;;687      }
;;;688      else
;;;689      { 
;;;690        /* TI2 Configuration */
;;;691        TI2_Config(TIMx, TIM_ICInitStruct->TIM_ICPolarity, TIM_ICInitStruct->TIM_ICSelection,
000020  4638              MOV      r0,r7
000022  d011              BEQ      |L63.72|
000024  f7fffffe          BL       TI2_Config
;;;692                   TIM_ICInitStruct->TIM_ICFilter);
;;;693        /* Set the Input Capture Prescaler value */
;;;694        TIM_SetIC2Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
000028  88e1              LDRH     r1,[r4,#6]
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       TIM_SetIC2Prescaler
;;;695        /* TI1 Configuration */
;;;696        TI1_Config(TIMx, icoppositepolarity, icoppositeselection, TIM_ICInitStruct->TIM_ICFilter);
000030  8923              LDRH     r3,[r4,#8]
000032  4632              MOV      r2,r6
000034  4629              MOV      r1,r5
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       TI1_Config
;;;697        /* Set the Input Capture Prescaler value */
;;;698        TIM_SetIC1Prescaler(TIMx, TIM_ICInitStruct->TIM_ICPrescaler);
00003c  88e1              LDRH     r1,[r4,#6]
00003e  4638              MOV      r0,r7
000040  e8bd41f0          POP      {r4-r8,lr}
000044  f7ffbffe          B.W      TIM_SetIC1Prescaler
                  |L63.72|
000048  f7fffffe          BL       TI1_Config
00004c  88e1              LDRH     r1,[r4,#6]            ;682
00004e  4638              MOV      r0,r7                 ;682
000050  f7fffffe          BL       TIM_SetIC1Prescaler
000054  8923              LDRH     r3,[r4,#8]            ;684
000056  4632              MOV      r2,r6                 ;684
000058  4629              MOV      r1,r5                 ;684
00005a  4638              MOV      r0,r7                 ;684
00005c  f7fffffe          BL       TI2_Config
000060  88e1              LDRH     r1,[r4,#6]            ;686
000062  4638              MOV      r0,r7                 ;686
000064  e8bd41f0          POP      {r4-r8,lr}            ;686
000068  f7ffbffe          B.W      TIM_SetIC2Prescaler
;;;699      }
;;;700    }
;;;701    
                          ENDP


                          AREA ||i.TIM_PrescalerConfig||, CODE, READONLY, ALIGN=1

                  TIM_PrescalerConfig PROC
;;;1173     */
;;;1174   void TIM_PrescalerConfig(TIM_TypeDef* TIMx, uint16_t Prescaler, uint16_t TIM_PSCReloadMode)
000000  8501              STRH     r1,[r0,#0x28]
;;;1175   {
;;;1176     /* Check the parameters */
;;;1177     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;1178     assert_param(IS_TIM_PRESCALER_RELOAD(TIM_PSCReloadMode));
;;;1179     /* Set the Prescaler value */
;;;1180     TIMx->PSC = Prescaler;
;;;1181     /* Set or reset the UG Bit */
;;;1182     TIMx->EGR = TIM_PSCReloadMode;
000002  8282              STRH     r2,[r0,#0x14]
;;;1183   }
000004  4770              BX       lr
;;;1184   
                          ENDP


                          AREA ||i.TIM_SelectCCDMA||, CODE, READONLY, ALIGN=1

                  TIM_SelectCCDMA PROC
;;;1455     */
;;;1456   void TIM_SelectCCDMA(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1457   {
;;;1458     /* Check the parameters */
;;;1459     assert_param(IS_TIM_LIST4_PERIPH(TIMx));
;;;1460     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1461     if (NewState != DISABLE)
;;;1462     {
;;;1463       /* Set the CCDS Bit */
;;;1464       TIMx->CR2 |= TIM_CR2_CCDS;
;;;1465     }
;;;1466     else
;;;1467     {
;;;1468       /* Reset the CCDS Bit */
;;;1469       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCDS);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L65.12|
000006  f0410108          ORR      r1,r1,#8              ;1464
00000a  e001              B        |L65.16|
                  |L65.12|
00000c  f0210108          BIC      r1,r1,#8
                  |L65.16|
000010  8081              STRH     r1,[r0,#4]            ;1464
;;;1470     }
;;;1471   }
000012  4770              BX       lr
;;;1472   
                          ENDP


                          AREA ||i.TIM_SelectCOM||, CODE, READONLY, ALIGN=1

                  TIM_SelectCOM PROC
;;;1430     */
;;;1431   void TIM_SelectCOM(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;1432   {
;;;1433     /* Check the parameters */
;;;1434     assert_param(IS_TIM_LIST2_PERIPH(TIMx));
;;;1435     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1436     if (NewState != DISABLE)
;;;1437     {
;;;1438       /* Set the COM Bit */
;;;1439       TIMx->CR2 |= TIM_CR2_CCUS;
;;;1440     }
;;;1441     else
;;;1442     {
;;;1443       /* Reset the COM Bit */
;;;1444       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_CCUS);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L66.12|
000006  f0410104          ORR      r1,r1,#4              ;1439
00000a  e001              B        |L66.16|
                  |L66.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L66.16|
000010  8081              STRH     r1,[r0,#4]            ;1439
;;;1445     }
;;;1446   }
000012  4770              BX       lr
;;;1447   
                          ENDP


                          AREA ||i.TIM_SelectHallSensor||, CODE, READONLY, ALIGN=1

                  TIM_SelectHallSensor PROC
;;;2141     */
;;;2142   void TIM_SelectHallSensor(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2143   {
;;;2144     /* Check the parameters */
;;;2145     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2146     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2147     if (NewState != DISABLE)
;;;2148     {
;;;2149       /* Set the TI1S Bit */
;;;2150       TIMx->CR2 |= TIM_CR2_TI1S;
;;;2151     }
;;;2152     else
;;;2153     {
;;;2154       /* Reset the TI1S Bit */
;;;2155       TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_TI1S);
000002  8881              LDRH     r1,[r0,#4]
000004  d002              BEQ      |L67.12|
000006  f0410180          ORR      r1,r1,#0x80           ;2150
00000a  e001              B        |L67.16|
                  |L67.12|
00000c  f0210180          BIC      r1,r1,#0x80
                  |L67.16|
000010  8081              STRH     r1,[r0,#4]            ;2150
;;;2156     }
;;;2157   }
000012  4770              BX       lr
;;;2158   
                          ENDP


                          AREA ||i.TIM_SelectInputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectInputTrigger PROC
;;;1226     */
;;;1227   void TIM_SelectInputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_InputTriggerSource)
000000  8902              LDRH     r2,[r0,#8]
;;;1228   {
;;;1229     uint16_t tmpsmcr = 0;
;;;1230     /* Check the parameters */
;;;1231     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1232     assert_param(IS_TIM_TRIGGER_SELECTION(TIM_InputTriggerSource));
;;;1233     /* Get the TIMx SMCR register value */
;;;1234     tmpsmcr = TIMx->SMCR;
;;;1235     /* Reset the TS Bits */
;;;1236     tmpsmcr &= (uint16_t)(~((uint16_t)TIM_SMCR_TS));
000002  f0220270          BIC      r2,r2,#0x70
;;;1237     /* Set the Input Trigger source */
;;;1238     tmpsmcr |= TIM_InputTriggerSource;
000006  430a              ORRS     r2,r2,r1
;;;1239     /* Write to TIMx SMCR */
;;;1240     TIMx->SMCR = tmpsmcr;
000008  8102              STRH     r2,[r0,#8]
;;;1241   }
00000a  4770              BX       lr
;;;1242   
                          ENDP


                          AREA ||i.TIM_SelectMasterSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectMasterSlaveMode PROC
;;;2243     */
;;;2244   void TIM_SelectMasterSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_MasterSlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2245   {
;;;2246     /* Check the parameters */
;;;2247     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2248     assert_param(IS_TIM_MSM_STATE(TIM_MasterSlaveMode));
;;;2249     /* Reset the MSM Bit */
;;;2250     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_MSM);
000002  f0220280          BIC      r2,r2,#0x80
000006  8102              STRH     r2,[r0,#8]
;;;2251     
;;;2252     /* Set or Reset the MSM Bit */
;;;2253     TIMx->SMCR |= TIM_MasterSlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2254   }
00000e  4770              BX       lr
;;;2255   
                          ENDP


                          AREA ||i.TIM_SelectOCxM||, CODE, READONLY, ALIGN=1

                  TIM_SelectOCxM PROC
;;;2042     */
;;;2043   void TIM_SelectOCxM(TIM_TypeDef* TIMx, uint16_t TIM_Channel, uint16_t TIM_OCMode)
000000  b530              PUSH     {r4,r5,lr}
;;;2044   {
;;;2045     uint32_t tmp = 0;
;;;2046     uint16_t tmp1 = 0;
;;;2047   
;;;2048     /* Check the parameters */
;;;2049     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2050     assert_param(IS_TIM_CHANNEL(TIM_Channel));
;;;2051     assert_param(IS_TIM_OCM(TIM_OCMode));
;;;2052   
;;;2053     tmp = (uint32_t) TIMx;
;;;2054     tmp += CCMR_Offset;
;;;2055   
;;;2056     tmp1 = CCER_CCE_Set << (uint16_t)TIM_Channel;
000002  2401              MOVS     r4,#1
;;;2057   
;;;2058     /* Disable the Channel: Reset the CCxE Bit */
;;;2059     TIMx->CCER &= (uint16_t) ~tmp1;
000004  8c05              LDRH     r5,[r0,#0x20]
000006  f1000318          ADD      r3,r0,#0x18           ;2054
00000a  408c              LSLS     r4,r4,r1              ;2056
00000c  43a5              BICS     r5,r5,r4
00000e  8405              STRH     r5,[r0,#0x20]
;;;2060   
;;;2061     if((TIM_Channel == TIM_Channel_1) ||(TIM_Channel == TIM_Channel_3))
000010  b179              CBZ      r1,|L70.50|
000012  2908              CMP      r1,#8
000014  d00d              BEQ      |L70.50|
;;;2062     {
;;;2063       tmp += (TIM_Channel>>1);
;;;2064   
;;;2065       /* Reset the OCxM bits in the CCMRx register */
;;;2066       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC1M);
;;;2067      
;;;2068       /* Configure the OCxM bits in the CCMRx register */
;;;2069       *(__IO uint32_t *) tmp |= TIM_OCMode;
;;;2070     }
;;;2071     else
;;;2072     {
;;;2073       tmp += (uint16_t)(TIM_Channel - (uint16_t)4)>> (uint16_t)1;
000016  1f09              SUBS     r1,r1,#4
000018  b288              UXTH     r0,r1
00001a  eb030050          ADD      r0,r3,r0,LSR #1
;;;2074   
;;;2075       /* Reset the OCxM bits in the CCMRx register */
;;;2076       *(__IO uint32_t *) tmp &= (uint32_t)~((uint32_t)TIM_CCMR1_OC2M);
00001e  6801              LDR      r1,[r0,#0]
000020  f42141e0          BIC      r1,r1,#0x7000
000024  6001              STR      r1,[r0,#0]
;;;2077       
;;;2078       /* Configure the OCxM bits in the CCMRx register */
;;;2079       *(__IO uint32_t *) tmp |= (uint16_t)(TIM_OCMode << 8);
000026  6801              LDR      r1,[r0,#0]
000028  0612              LSLS     r2,r2,#24
00002a  0c12              LSRS     r2,r2,#16
                  |L70.44|
00002c  4311              ORRS     r1,r1,r2              ;2069
00002e  6001              STR      r1,[r0,#0]            ;2069
;;;2080     }
;;;2081   }
000030  bd30              POP      {r4,r5,pc}
                  |L70.50|
000032  eb030051          ADD      r0,r3,r1,LSR #1       ;2063
000036  6801              LDR      r1,[r0,#0]            ;2066
000038  f0210170          BIC      r1,r1,#0x70           ;2066
00003c  6001              STR      r1,[r0,#0]            ;2066
00003e  6801              LDR      r1,[r0,#0]            ;2069
000040  e7f4              B        |L70.44|
;;;2082   
                          ENDP


                          AREA ||i.TIM_SelectOnePulseMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectOnePulseMode PROC
;;;2167     */
;;;2168   void TIM_SelectOnePulseMode(TIM_TypeDef* TIMx, uint16_t TIM_OPMode)
000000  8802              LDRH     r2,[r0,#0]
;;;2169   {
;;;2170     /* Check the parameters */
;;;2171     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2172     assert_param(IS_TIM_OPM_MODE(TIM_OPMode));
;;;2173     /* Reset the OPM Bit */
;;;2174     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_OPM);
000002  f0220208          BIC      r2,r2,#8
000006  8002              STRH     r2,[r0,#0]
;;;2175     /* Configure the OPM Mode */
;;;2176     TIMx->CR1 |= TIM_OPMode;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;2177   }
00000e  4770              BX       lr
;;;2178   
                          ENDP


                          AREA ||i.TIM_SelectOutputTrigger||, CODE, READONLY, ALIGN=1

                  TIM_SelectOutputTrigger PROC
;;;2199     */
;;;2200   void TIM_SelectOutputTrigger(TIM_TypeDef* TIMx, uint16_t TIM_TRGOSource)
000000  8882              LDRH     r2,[r0,#4]
;;;2201   {
;;;2202     /* Check the parameters */
;;;2203     assert_param(IS_TIM_LIST7_PERIPH(TIMx));
;;;2204     assert_param(IS_TIM_TRGO_SOURCE(TIM_TRGOSource));
;;;2205     /* Reset the MMS Bits */
;;;2206     TIMx->CR2 &= (uint16_t)~((uint16_t)TIM_CR2_MMS);
000002  f0220270          BIC      r2,r2,#0x70
000006  8082              STRH     r2,[r0,#4]
;;;2207     /* Select the TRGO source */
;;;2208     TIMx->CR2 |=  TIM_TRGOSource;
000008  8882              LDRH     r2,[r0,#4]
00000a  430a              ORRS     r2,r2,r1
00000c  8082              STRH     r2,[r0,#4]
;;;2209   }
00000e  4770              BX       lr
;;;2210   
                          ENDP


                          AREA ||i.TIM_SelectSlaveMode||, CODE, READONLY, ALIGN=1

                  TIM_SelectSlaveMode PROC
;;;2222     */
;;;2223   void TIM_SelectSlaveMode(TIM_TypeDef* TIMx, uint16_t TIM_SlaveMode)
000000  8902              LDRH     r2,[r0,#8]
;;;2224   {
;;;2225     /* Check the parameters */
;;;2226     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2227     assert_param(IS_TIM_SLAVE_MODE(TIM_SlaveMode));
;;;2228    /* Reset the SMS Bits */
;;;2229     TIMx->SMCR &= (uint16_t)~((uint16_t)TIM_SMCR_SMS);
000002  f0220207          BIC      r2,r2,#7
000006  8102              STRH     r2,[r0,#8]
;;;2230     /* Select the Slave Mode */
;;;2231     TIMx->SMCR |= TIM_SlaveMode;
000008  8902              LDRH     r2,[r0,#8]
00000a  430a              ORRS     r2,r2,r1
00000c  8102              STRH     r2,[r0,#8]
;;;2232   }
00000e  4770              BX       lr
;;;2233   
                          ENDP


                          AREA ||i.TIM_SetAutoreload||, CODE, READONLY, ALIGN=1

                  TIM_SetAutoreload PROC
;;;2275     */
;;;2276   void TIM_SetAutoreload(TIM_TypeDef* TIMx, uint16_t Autoreload)
000000  8581              STRH     r1,[r0,#0x2c]
;;;2277   {
;;;2278     /* Check the parameters */
;;;2279     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2280     /* Set the Autoreload Register value */
;;;2281     TIMx->ARR = Autoreload;
;;;2282   }
000002  4770              BX       lr
;;;2283   
                          ENDP


                          AREA ||i.TIM_SetClockDivision||, CODE, READONLY, ALIGN=1

                  TIM_SetClockDivision PROC
;;;2438     */
;;;2439   void TIM_SetClockDivision(TIM_TypeDef* TIMx, uint16_t TIM_CKD)
000000  8802              LDRH     r2,[r0,#0]
;;;2440   {
;;;2441     /* Check the parameters */
;;;2442     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2443     assert_param(IS_TIM_CKD_DIV(TIM_CKD));
;;;2444     /* Reset the CKD Bits */
;;;2445     TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_CKD);
000002  f4227240          BIC      r2,r2,#0x300
000006  8002              STRH     r2,[r0,#0]
;;;2446     /* Set the CKD value */
;;;2447     TIMx->CR1 |= TIM_CKD;
000008  8802              LDRH     r2,[r0,#0]
00000a  430a              ORRS     r2,r2,r1
00000c  8002              STRH     r2,[r0,#0]
;;;2448   }
00000e  4770              BX       lr
;;;2449   
                          ENDP


                          AREA ||i.TIM_SetCompare1||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare1 PROC
;;;2289     */
;;;2290   void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)
000000  8681              STRH     r1,[r0,#0x34]
;;;2291   {
;;;2292     /* Check the parameters */
;;;2293     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2294     /* Set the Capture Compare1 Register value */
;;;2295     TIMx->CCR1 = Compare1;
;;;2296   }
000002  4770              BX       lr
;;;2297   
                          ENDP


                          AREA ||i.TIM_SetCompare2||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare2 PROC
;;;2303     */
;;;2304   void TIM_SetCompare2(TIM_TypeDef* TIMx, uint16_t Compare2)
000000  8701              STRH     r1,[r0,#0x38]
;;;2305   {
;;;2306     /* Check the parameters */
;;;2307     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2308     /* Set the Capture Compare2 Register value */
;;;2309     TIMx->CCR2 = Compare2;
;;;2310   }
000002  4770              BX       lr
;;;2311   
                          ENDP


                          AREA ||i.TIM_SetCompare3||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare3 PROC
;;;2317     */
;;;2318   void TIM_SetCompare3(TIM_TypeDef* TIMx, uint16_t Compare3)
000000  8781              STRH     r1,[r0,#0x3c]
;;;2319   {
;;;2320     /* Check the parameters */
;;;2321     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2322     /* Set the Capture Compare3 Register value */
;;;2323     TIMx->CCR3 = Compare3;
;;;2324   }
000002  4770              BX       lr
;;;2325   
                          ENDP


                          AREA ||i.TIM_SetCompare4||, CODE, READONLY, ALIGN=1

                  TIM_SetCompare4 PROC
;;;2331     */
;;;2332   void TIM_SetCompare4(TIM_TypeDef* TIMx, uint16_t Compare4)
000000  f8a01040          STRH     r1,[r0,#0x40]
;;;2333   {
;;;2334     /* Check the parameters */
;;;2335     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2336     /* Set the Capture Compare4 Register value */
;;;2337     TIMx->CCR4 = Compare4;
;;;2338   }
000004  4770              BX       lr
;;;2339   
                          ENDP


                          AREA ||i.TIM_SetCounter||, CODE, READONLY, ALIGN=1

                  TIM_SetCounter PROC
;;;2261     */
;;;2262   void TIM_SetCounter(TIM_TypeDef* TIMx, uint16_t Counter)
000000  8481              STRH     r1,[r0,#0x24]
;;;2263   {
;;;2264     /* Check the parameters */
;;;2265     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2266     /* Set the Counter Register value */
;;;2267     TIMx->CNT = Counter;
;;;2268   }
000002  4770              BX       lr
;;;2269   
                          ENDP


                          AREA ||i.TIM_SetIC1Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC1Prescaler PROC
;;;2350     */
;;;2351   void TIM_SetIC1Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2352   {
;;;2353     /* Check the parameters */
;;;2354     assert_param(IS_TIM_LIST8_PERIPH(TIMx));
;;;2355     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2356     /* Reset the IC1PSC Bits */
;;;2357     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC1PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8302              STRH     r2,[r0,#0x18]
;;;2358     /* Set the IC1PSC value */
;;;2359     TIMx->CCMR1 |= TIM_ICPSC;
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  430a              ORRS     r2,r2,r1
00000c  8302              STRH     r2,[r0,#0x18]
;;;2360   }
00000e  4770              BX       lr
;;;2361   
                          ENDP


                          AREA ||i.TIM_SetIC2Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC2Prescaler PROC
;;;2372     */
;;;2373   void TIM_SetIC2Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b02              LDRH     r2,[r0,#0x18]
;;;2374   {
;;;2375     /* Check the parameters */
;;;2376     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;2377     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2378     /* Reset the IC2PSC Bits */
;;;2379     TIMx->CCMR1 &= (uint16_t)~((uint16_t)TIM_CCMR1_IC2PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8302              STRH     r2,[r0,#0x18]
;;;2380     /* Set the IC2PSC value */
;;;2381     TIMx->CCMR1 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b02              LDRH     r2,[r0,#0x18]
00000a  ea422201          ORR      r2,r2,r1,LSL #8
00000e  8302              STRH     r2,[r0,#0x18]
;;;2382   }
000010  4770              BX       lr
;;;2383   
                          ENDP


                          AREA ||i.TIM_SetIC3Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC3Prescaler PROC
;;;2394     */
;;;2395   void TIM_SetIC3Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2396   {
;;;2397     /* Check the parameters */
;;;2398     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2399     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2400     /* Reset the IC3PSC Bits */
;;;2401     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC3PSC);
000002  f022020c          BIC      r2,r2,#0xc
000006  8382              STRH     r2,[r0,#0x1c]
;;;2402     /* Set the IC3PSC value */
;;;2403     TIMx->CCMR2 |= TIM_ICPSC;
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  430a              ORRS     r2,r2,r1
00000c  8382              STRH     r2,[r0,#0x1c]
;;;2404   }
00000e  4770              BX       lr
;;;2405   
                          ENDP


                          AREA ||i.TIM_SetIC4Prescaler||, CODE, READONLY, ALIGN=1

                  TIM_SetIC4Prescaler PROC
;;;2416     */
;;;2417   void TIM_SetIC4Prescaler(TIM_TypeDef* TIMx, uint16_t TIM_ICPSC)
000000  8b82              LDRH     r2,[r0,#0x1c]
;;;2418   {  
;;;2419     /* Check the parameters */
;;;2420     assert_param(IS_TIM_LIST3_PERIPH(TIMx));
;;;2421     assert_param(IS_TIM_IC_PRESCALER(TIM_ICPSC));
;;;2422     /* Reset the IC4PSC Bits */
;;;2423     TIMx->CCMR2 &= (uint16_t)~((uint16_t)TIM_CCMR2_IC4PSC);
000002  f4226240          BIC      r2,r2,#0xc00
000006  8382              STRH     r2,[r0,#0x1c]
;;;2424     /* Set the IC4PSC value */
;;;2425     TIMx->CCMR2 |= (uint16_t)(TIM_ICPSC << 8);
000008  8b82              LDRH     r2,[r0,#0x1c]
00000a  ea422201          ORR      r2,r2,r1,LSL #8
00000e  8382              STRH     r2,[r0,#0x1c]
;;;2426   }
000010  4770              BX       lr
;;;2427   
                          ENDP


                          AREA ||i.TIM_TIxExternalClockConfig||, CODE, READONLY, ALIGN=1

                  TIM_TIxExternalClockConfig PROC
;;;1032     */
;;;1033   void TIM_TIxExternalClockConfig(TIM_TypeDef* TIMx, uint16_t TIM_TIxExternalCLKSource,
000000  b570              PUSH     {r4-r6,lr}
;;;1034                                   uint16_t TIM_ICPolarity, uint16_t ICFilter)
;;;1035   {
000002  460d              MOV      r5,r1
000004  4611              MOV      r1,r2
000006  4604              MOV      r4,r0
;;;1036     /* Check the parameters */
;;;1037     assert_param(IS_TIM_LIST6_PERIPH(TIMx));
;;;1038     assert_param(IS_TIM_TIXCLK_SOURCE(TIM_TIxExternalCLKSource));
;;;1039     assert_param(IS_TIM_IC_POLARITY(TIM_ICPolarity));
;;;1040     assert_param(IS_TIM_IC_FILTER(ICFilter));
;;;1041     /* Configure the Timer Input Clock Source */
;;;1042     if (TIM_TIxExternalCLKSource == TIM_TIxExternalCLK1Source_TI2)
000008  2d60              CMP      r5,#0x60
;;;1043     {
;;;1044       TI2_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
;;;1045     }
;;;1046     else
;;;1047     {
;;;1048       TI1_Config(TIMx, TIM_ICPolarity, TIM_ICSelection_DirectTI, ICFilter);
00000a  f04f0201          MOV      r2,#1
00000e  d00b              BEQ      |L85.40|
000010  f7fffffe          BL       TI1_Config
                  |L85.20|
000014  8920              LDRH     r0,[r4,#8]
000016  f0200070          BIC      r0,r0,#0x70
00001a  4328              ORRS     r0,r0,r5
00001c  8120              STRH     r0,[r4,#8]
;;;1049     }
;;;1050     /* Select the Trigger source */
;;;1051     TIM_SelectInputTrigger(TIMx, TIM_TIxExternalCLKSource);
;;;1052     /* Select the External clock mode1 */
;;;1053     TIMx->SMCR |= TIM_SlaveMode_External1;
00001e  8920              LDRH     r0,[r4,#8]
000020  f0400007          ORR      r0,r0,#7
000024  8120              STRH     r0,[r4,#8]
;;;1054   }
000026  bd70              POP      {r4-r6,pc}
                  |L85.40|
000028  f7fffffe          BL       TI2_Config
00002c  e7f2              B        |L85.20|
;;;1055   
                          ENDP


                          AREA ||i.TIM_TimeBaseInit||, CODE, READONLY, ALIGN=2

                  TIM_TimeBaseInit PROC
;;;223      */
;;;224    void TIM_TimeBaseInit(TIM_TypeDef* TIMx, TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  b530              PUSH     {r4,r5,lr}
;;;225    {
;;;226      uint16_t tmpcr1 = 0;
;;;227    
;;;228      /* Check the parameters */
;;;229      assert_param(IS_TIM_ALL_PERIPH(TIMx)); 
;;;230      assert_param(IS_TIM_COUNTER_MODE(TIM_TimeBaseInitStruct->TIM_CounterMode));
;;;231      assert_param(IS_TIM_CKD_DIV(TIM_TimeBaseInitStruct->TIM_ClockDivision));
;;;232    
;;;233      tmpcr1 = TIMx->CR1;  
000002  8802              LDRH     r2,[r0,#0]
;;;234    
;;;235      if((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM2) || (TIMx == TIM3)||
000004  4c1b              LDR      r4,|L86.116|
000006  4d1c              LDR      r5,|L86.120|
000008  42a0              CMP      r0,r4
00000a  d00d              BEQ      |L86.40|
00000c  42a8              CMP      r0,r5
00000e  d00b              BEQ      |L86.40|
000010  f1b04f80          CMP      r0,#0x40000000
000014  d008              BEQ      |L86.40|
000016  4b19              LDR      r3,|L86.124|
000018  4298              CMP      r0,r3
00001a  d005              BEQ      |L86.40|
;;;236         (TIMx == TIM4) || (TIMx == TIM5)) 
00001c  4b18              LDR      r3,|L86.128|
00001e  4298              CMP      r0,r3
000020  d002              BEQ      |L86.40|
000022  4b18              LDR      r3,|L86.132|
000024  4298              CMP      r0,r3
000026  d103              BNE      |L86.48|
                  |L86.40|
;;;237      {
;;;238        /* Select the Counter Mode */
;;;239        tmpcr1 &= (uint16_t)(~((uint16_t)(TIM_CR1_DIR | TIM_CR1_CMS)));
000028  f0220370          BIC      r3,r2,#0x70
;;;240        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_CounterMode;
00002c  884a              LDRH     r2,[r1,#2]
00002e  431a              ORRS     r2,r2,r3
                  |L86.48|
;;;241      }
;;;242     
;;;243      if((TIMx != TIM6) && (TIMx != TIM7))
000030  4b15              LDR      r3,|L86.136|
000032  4298              CMP      r0,r3
000034  d006              BEQ      |L86.68|
000036  4b15              LDR      r3,|L86.140|
000038  4298              CMP      r0,r3
00003a  d003              BEQ      |L86.68|
;;;244      {
;;;245        /* Set the clock division */
;;;246        tmpcr1 &= (uint16_t)(~((uint16_t)TIM_CR1_CKD));
00003c  f4227340          BIC      r3,r2,#0x300
;;;247        tmpcr1 |= (uint32_t)TIM_TimeBaseInitStruct->TIM_ClockDivision;
000040  88ca              LDRH     r2,[r1,#6]
000042  431a              ORRS     r2,r2,r3
                  |L86.68|
;;;248      }
;;;249    
;;;250      TIMx->CR1 = tmpcr1;
000044  8002              STRH     r2,[r0,#0]
;;;251    
;;;252      /* Set the Autoreload value */
;;;253      TIMx->ARR = TIM_TimeBaseInitStruct->TIM_Period ;
000046  888a              LDRH     r2,[r1,#4]
000048  8582              STRH     r2,[r0,#0x2c]
;;;254     
;;;255      /* Set the Prescaler value */
;;;256      TIMx->PSC = TIM_TimeBaseInitStruct->TIM_Prescaler;
00004a  880a              LDRH     r2,[r1,#0]
00004c  8502              STRH     r2,[r0,#0x28]
;;;257        
;;;258      if ((TIMx == TIM1) || (TIMx == TIM8)|| (TIMx == TIM15)|| (TIMx == TIM16) || (TIMx == TIM17))  
00004e  42a0              CMP      r0,r4
000050  d00a              BEQ      |L86.104|
000052  42a8              CMP      r0,r5
000054  d008              BEQ      |L86.104|
000056  4a0e              LDR      r2,|L86.144|
000058  4290              CMP      r0,r2
00005a  d005              BEQ      |L86.104|
00005c  4a0d              LDR      r2,|L86.148|
00005e  4290              CMP      r0,r2
000060  d002              BEQ      |L86.104|
000062  4a0d              LDR      r2,|L86.152|
000064  4290              CMP      r0,r2
000066  d101              BNE      |L86.108|
                  |L86.104|
;;;259      {
;;;260        /* Set the Repetition Counter value */
;;;261        TIMx->RCR = TIM_TimeBaseInitStruct->TIM_RepetitionCounter;
000068  7a09              LDRB     r1,[r1,#8]
00006a  8601              STRH     r1,[r0,#0x30]
                  |L86.108|
;;;262      }
;;;263    
;;;264      /* Generate an update event to reload the Prescaler and the Repetition counter
;;;265         values immediately */
;;;266      TIMx->EGR = TIM_PSCReloadMode_Immediate;           
00006c  2101              MOVS     r1,#1
00006e  8281              STRH     r1,[r0,#0x14]
;;;267    }
000070  bd30              POP      {r4,r5,pc}
;;;268    
                          ENDP

000072  0000              DCW      0x0000
                  |L86.116|
                          DCD      0x40012c00
                  |L86.120|
                          DCD      0x40013400
                  |L86.124|
                          DCD      0x40000400
                  |L86.128|
                          DCD      0x40000800
                  |L86.132|
                          DCD      0x40000c00
                  |L86.136|
                          DCD      0x40001000
                  |L86.140|
                          DCD      0x40001400
                  |L86.144|
                          DCD      0x40014000
                  |L86.148|
                          DCD      0x40014400
                  |L86.152|
                          DCD      0x40014800

                          AREA ||i.TIM_TimeBaseStructInit||, CODE, READONLY, ALIGN=1

                  TIM_TimeBaseStructInit PROC
;;;733      */
;;;734    void TIM_TimeBaseStructInit(TIM_TimeBaseInitTypeDef* TIM_TimeBaseInitStruct)
000000  f64f71ff          MOV      r1,#0xffff
;;;735    {
;;;736      /* Set the default configuration */
;;;737      TIM_TimeBaseInitStruct->TIM_Period = 0xFFFF;
000004  8081              STRH     r1,[r0,#4]
;;;738      TIM_TimeBaseInitStruct->TIM_Prescaler = 0x0000;
000006  2100              MOVS     r1,#0
000008  8001              STRH     r1,[r0,#0]
;;;739      TIM_TimeBaseInitStruct->TIM_ClockDivision = TIM_CKD_DIV1;
00000a  80c1              STRH     r1,[r0,#6]
;;;740      TIM_TimeBaseInitStruct->TIM_CounterMode = TIM_CounterMode_Up;
00000c  8041              STRH     r1,[r0,#2]
;;;741      TIM_TimeBaseInitStruct->TIM_RepetitionCounter = 0x0000;
00000e  7201              STRB     r1,[r0,#8]
;;;742    }
000010  4770              BX       lr
;;;743    
                          ENDP


                          AREA ||i.TIM_UpdateDisableConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateDisableConfig PROC
;;;2089     */
;;;2090   void TIM_UpdateDisableConfig(TIM_TypeDef* TIMx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;2091   {
;;;2092     /* Check the parameters */
;;;2093     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2094     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;2095     if (NewState != DISABLE)
;;;2096     {
;;;2097       /* Set the Update Disable Bit */
;;;2098       TIMx->CR1 |= TIM_CR1_UDIS;
;;;2099     }
;;;2100     else
;;;2101     {
;;;2102       /* Reset the Update Disable Bit */
;;;2103       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_UDIS);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L88.12|
000006  f0410102          ORR      r1,r1,#2              ;2098
00000a  e001              B        |L88.16|
                  |L88.12|
00000c  f0210102          BIC      r1,r1,#2
                  |L88.16|
000010  8001              STRH     r1,[r0,#0]            ;2098
;;;2104     }
;;;2105   }
000012  4770              BX       lr
;;;2106   
                          ENDP


                          AREA ||i.TIM_UpdateRequestConfig||, CODE, READONLY, ALIGN=1

                  TIM_UpdateRequestConfig PROC
;;;2117     */
;;;2118   void TIM_UpdateRequestConfig(TIM_TypeDef* TIMx, uint16_t TIM_UpdateSource)
000000  2900              CMP      r1,#0
;;;2119   {
;;;2120     /* Check the parameters */
;;;2121     assert_param(IS_TIM_ALL_PERIPH(TIMx));
;;;2122     assert_param(IS_TIM_UPDATE_SOURCE(TIM_UpdateSource));
;;;2123     if (TIM_UpdateSource != TIM_UpdateSource_Global)
;;;2124     {
;;;2125       /* Set the URS Bit */
;;;2126       TIMx->CR1 |= TIM_CR1_URS;
;;;2127     }
;;;2128     else
;;;2129     {
;;;2130       /* Reset the URS Bit */
;;;2131       TIMx->CR1 &= (uint16_t)~((uint16_t)TIM_CR1_URS);
000002  8801              LDRH     r1,[r0,#0]
000004  d002              BEQ      |L89.12|
000006  f0410104          ORR      r1,r1,#4              ;2126
00000a  e001              B        |L89.16|
                  |L89.12|
00000c  f0210104          BIC      r1,r1,#4
                  |L89.16|
000010  8001              STRH     r1,[r0,#0]            ;2126
;;;2132     }
;;;2133   }
000012  4770              BX       lr
;;;2134   
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\FWLib\\src\\stm32f10x_tim.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_tim_c_c458916b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___15_stm32f10x_tim_c_c458916b____REVSH|
#line 128
|__asm___15_stm32f10x_tim_c_c458916b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
