; generated by ARM C/C++ Compiler, 4.1 [Build 481]
; commandline ArmCC [--split_sections --debug -c --asm --interleave -o.\ouput\diskio.o --depend=.\ouput\diskio.d --cpu=Cortex-M3 --apcs=interwork -I.\Source\APP -I.\Source\FWLib\cm3 -I.\Source\FWLib\inc -I.\Source\BSP -I.\Source\FWLib -I.\Source\Startup -I.\Source\uCOS-II\Source -I.\Source\uCOS-II\uC-CPU -I.\Source\uCOS-II\uC-LIB -I.\Source\uCOS-II\Ports -I.\Source\uCGUI\Config -I.\Source\uCGUI\emWinDemo -I.\Source\uCGUI\LCDDriver -I.\Source\uCGUI\uCGUIDemo -I.\Source\uCGUI\LCDDriver\Touch -I.\Source\uCOS-II\Source -I.\Source\uCGUI\Core -I.\Source\uCGUI\WM -I.\Source\uCGUI\Widget -I.\Source\uCGUI\GUIDemo -I.\Source\SDHC\driver -I.\Source\SDHC\fatfs -I.\Source\gui_app -I.\Source\gui_app\pinyin -I.\Source\uCGUI\TouchCalibration -I.\Source\Mot -I.\Source\Net -I.\Source\STM32F10x_DSP_Lib\src\asm\arm -I.\Source\STM32F10x_DSP_Lib\inc -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Lib\ARM -I..\..\..\STM32F4\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\Libraries\CMSIS\Include -I.\Source\Lib -ID:\Keil_ARM\ARM\INC -ID:\Keil_ARM\ARM\INC\ST\STM32F10x -D__MICROLIB -DSTM32F10X_XL -DUSE_STDPERIPH_DRIVER -DARM_MATH_CM3 --omf_browse=.\ouput\diskio.crf Source\SDHC\fatfs\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;23     
;;;24     DSTATUS disk_initialize (
000000  2000              MOVS     r0,#0
;;;25     	BYTE drv				/* Physical drive nmuber (0..) */
;;;26     )
;;;27     {
;;;28     	return 0;
;;;29     }
000002  4770              BX       lr
;;;30     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=1

                  disk_ioctl PROC
;;;126    
;;;127    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;128    	BYTE drv,		/* Physical drive nmuber (0..) */
;;;129    	BYTE ctrl,		/* Control code */
;;;130    	void *buff		/* Buffer to send/receive control data */
;;;131    )
;;;132    {
;;;133    
;;;134    	/*return RES_OK;  */
;;;135    	u8 res;
;;;136    	res = sd_init();//SD_Initialize() 
000002  f7fffffe          BL       sd_init
;;;137    		 /*	if(res)//STM32 SPI的bug,在sd卡操作失败的时候如果不执行下面的语句,可能导致SPI读写异常
;;;138    			{
;;;139    				SD_SPI_SpeedLow();
;;;140    				SD_SPI_ReadWriteByte(0xff);//提供额外的8个时钟
;;;141    				SD_SPI_SpeedHigh();
;;;142    			} */
;;;143    	if(res)return  STA_NOINIT;
000006  2800              CMP      r0,#0
000008  d000              BEQ      |L2.12|
00000a  2001              MOVS     r0,#1
                  |L2.12|
;;;144    	else return RES_OK;
;;;145    }
00000c  bd10              POP      {r4,pc}
;;;146    
                          ENDP


                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=1

                  disk_read PROC
;;;47     
;;;48     DRESULT disk_read (
000000  4608              MOV      r0,r1
;;;49     	BYTE drv,		/* Physical drive nmuber (0..) */
;;;50     	BYTE *buff,		/* Data buffer to store read data */
;;;51     	DWORD sector,	/* Sector address (LBA) */
;;;52     	BYTE count		/* Number of sectors to read (1..255) */
;;;53     )
;;;54     {  /*
000002  b510              PUSH     {r4,lr}
000004  4611              MOV      r1,r2
000006  461a              MOV      r2,r3
;;;55       //memset(buff2, 0, sizeof(buff2));
;;;56     	if(count==1)
;;;57             {
;;;58               SD_ReadBlock(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE);
;;;59               //memcpy(buff,buff2,SECTOR_SIZE);
;;;60     	}
;;;61     	else
;;;62             {
;;;63               SD_ReadMultiBlocks(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE,count);
;;;64               //memcpy(buff,buff2,SECTOR_SIZE * count);
;;;65     	}
;;;66     	  
;;;67     	return RES_OK; */
;;;68     	u8 res;
;;;69     	res=SD_ReadDisk(buff,sector,count);	 
000008  f7fffffe          BL       SD_ReadDisk
;;;70     		 /*	if(res)//STM32 SPI的bug,在sd卡操作失败的时候如果不执行下面的语句,可能导致SPI读写异常
;;;71     			{
;;;72     				SD_SPI_SpeedLow();
;;;73     				SD_SPI_ReadWriteByte(0xff);//提供额外的8个时钟
;;;74     				SD_SPI_SpeedHigh();
;;;75     			}	*/
;;;76     			//处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;77         if(res==0x00)return RES_OK;	 
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L3.18|
;;;78         else 
;;;79     	{
;;;80     		return RES_ERROR;
000010  2001              MOVS     r0,#1
                  |L3.18|
;;;81     	}
;;;82     }
000012  bd10              POP      {r4,pc}
;;;83     
                          ENDP


                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;35     
;;;36     DSTATUS disk_status (
000000  2000              MOVS     r0,#0
;;;37     	BYTE drv		/* Physical drive nmuber (0..) */
;;;38     )
;;;39     {	
;;;40     	return 0;
;;;41     }
000002  4770              BX       lr
;;;42     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=1

                  disk_write PROC
;;;89     #if _READONLY == 0
;;;90     DRESULT disk_write (
000000  4608              MOV      r0,r1
;;;91     	BYTE drv,			/* Physical drive nmuber (0..) */
;;;92     	const BYTE *buff,	/* Data to be written */
;;;93     	DWORD sector,		/* Sector address (LBA) */
;;;94     	BYTE count			/* Number of sectors to write (1..255) */
;;;95     )
;;;96     {
000002  b510              PUSH     {r4,lr}
000004  4611              MOV      r1,r2
000006  461a              MOV      r2,r3
;;;97     /*
;;;98       //memset(buff2, 0, sizeof(buff2));
;;;99     	if(count==1)
;;;100            {
;;;101              //memcpy(buff2,buff,SECTOR_SIZE);
;;;102              SD_WriteBlock(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE);
;;;103    	}
;;;104    	else
;;;105            {
;;;106              //memcpy(buff2,buff,SECTOR_SIZE * count);
;;;107              SD_WriteMultiBlocks(sector << 9 ,(u32 *)(&buff[0]),SECTOR_SIZE,count);
;;;108    	}
;;;109            
;;;110      return RES_OK;  */
;;;111      u8 res;
;;;112    	res=SD_WriteDisk((u8*)buff,sector,count);
000008  f7fffffe          BL       SD_WriteDisk
;;;113    	 //处理返回值，将SPI_SD_driver.c的返回值转成ff.c的返回值
;;;114        if(res == 0x00)return RES_OK;	 
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L5.18|
;;;115        else 
;;;116    	{
;;;117    		return RES_ERROR;
000010  2001              MOVS     r0,#1
                  |L5.18|
;;;118    	}
;;;119    }
000012  bd10              POP      {r4,pc}
;;;120    #endif /* _READONLY */
                          ENDP


                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=1

                  get_fattime PROC
;;;146    
;;;147    DWORD get_fattime(void){
000000  2000              MOVS     r0,#0
;;;148    	return 0;
;;;149    }
000002  4770              BX       lr
;;;150    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Source\\SDHC\\fatfs\\diskio.c"
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REV16|
#line 114 "..\\..\\..\\STM32F4\\STM32F4xx_DSP_StdPeriph_Lib_V1.0.1\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_b3252454____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE, READONLY
	THUMB
	EXPORT |__asm___8_diskio_c_b3252454____REVSH|
#line 128
|__asm___8_diskio_c_b3252454____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
